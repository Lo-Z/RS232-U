<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>RS232-U Firmware Update Tool</title>

  <!-- ========== Styles ========== -->
  <style>
    /* ---------- Theme tokens ---------- */
    :root {
      --bg: #121212;
      --panel: #181818;
      --panel-2: #1f1f1f;
      --text: #e0e0e0;
      --muted: #a9a9a9;
      --accent: #4caf50;
      --border: #2a2a2a;
      --term-green: #00ff00;
      --error: #ff3b30;
      --warn: #ffd166;
    }

    /* ---------- Base ---------- */
    * { box-sizing: border-box; }
    html, body { height: 100%; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.45;
      text-align: left;
    }

    /* ---------- Layout ---------- */
    .wrapper {
      max-width: 760px;
      margin: 32px auto;
      padding: 0 16px 40px;
    }

    header {
      text-align: center;
      margin-bottom: 18px;
    }

    header h1 {
      margin: 0 0 6px;
      font-size: 1.6rem;
      font-weight: 650;
    }

    header p {
      margin: 0;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 18px;
      box-shadow: 0 4px 18px rgba(0, 0, 0, 0.2);
    }

    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
    }

    @media (min-width: 520px) {
      .row.actions {
        grid-template-columns: 1fr auto auto;
        align-items: end;
      }
    }

    /* ---------- Controls ---------- */
    label { display: block; font-size: 0.95rem; }

    input[type="file"],
    button {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--panel-2);
      color: var(--text);
      font-size: 0.98rem;
    }

    button {
      cursor: pointer;
      transition:
        transform 0.02s ease,
        opacity 0.2s ease,
        background-color 0.2s ease;
    }

    button:hover { transform: translateY(-1px); }
    button:disabled { opacity: 0.6; cursor: not-allowed; }

    .status {
      margin-top: 10px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 0.95rem;
      color: var(--muted);
    }

    .status .failed { color: var(--error); }

    /* Flash button color states */
    #flash {
      transition:
        background-color 0.2s ease,
        box-shadow 0.2s ease,
        opacity 0.2s ease;
    }

    #flash:disabled {
      background: #9ca3af; /* gray */
      color: #ffffff;
      cursor: not-allowed;
      opacity: 0.75;
    }

    #flash:not(:disabled) {
      background: #22c55e; /* green (Tailwind green-500) */
      color: #081c0c;
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2) inset;
    }

    /* ---------- Progress ---------- */
    .progress {
      width: 100%;
      height: 12px;
      margin: 14px 0 4px;
      background: #2a2a2a;
      border: 1px solid var(--border);
      border-radius: 999px;
      overflow: hidden;
    }

    .bar {
      height: 100%;
      width: 0%;
      background: var(--accent);
      transition: width 0.15s linear;
    }

    .pct {
      text-align: right;
      font-size: 0.85rem;
      color: var(--muted);
    }

    /* ---------- Debug console ---------- */
    #debug {
      margin: 20px auto 0;
      width: 100%;
      max-width: 720px;
      height: 300px;
      padding: 12px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--term-green);
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      white-space: pre-wrap;
      text-align: left;
      overflow-y: auto;
    }

    #debug .line  { color: var(--term-green); }
    #debug .warn  { color: var(--warn); }
    #debug .error { color: var(--error); font-weight: 600; }

    /* ---------- Notes ---------- */
    .note {
      margin-top: 8px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .kv {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    .kv span {
      background: #141414;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
    }
  </style>
</head>

<body>
  <div class="wrapper">
    <header>
      <h1>RS232-U Firmware Update Tool</h1>
      <p>Connect your device, choose a firmware file, and flash. Don’t unplug during the process.</p>
    </header>

    <section class="card">
      <div class="row">
        <label>
          Firmware (.bin)
          <input id="firmware" type="file" accept=".bin" />
        </label>
      </div>

      <div class="row actions" style="margin-top: 8px;">
        <div id="status" class="status">Status: Not connected</div>
        <button id="connect" type="button">Connect to Device</button>
        <button id="flash" type="button" disabled>Start Flashing</button>
      </div>

      <div id="progress-container" class="progress" aria-label="Flash progress">
        <div id="progress-bar" class="bar"></div>
      </div>
      <div id="progress-text" class="pct">0%</div>

      <div class="note">
        
        <div class="kv">
          <span>Baud: <b>115200</b></span>
          <span>Write Address: <b>0x10000</b></span>
          <span>Mode: <b>ROM Download</b></span>
        </div> 
		Tip: USB Device Title Is TinyUSB Serial (COM#)
      </div>
    </section>

    <div id="debug" role="log" aria-label="Debug Console"></div>
  </div>

  <!-- ========== Script ========== -->
  <script type="module">
    'use strict';

    /* ---------- Global state -------------------------------------------------- */
    let port                  = null; // active SerialPort
    let transport             = null; // esptool transport
    let loader                = null; // esptool loader instance
    let esptoolPromise        = null;
    let __lastSerialDisconnectTs = 0;
    let __connectAttemptTs       = 0;

    let __isConnecting = false; // single-flight guard
    let __connectCalls = 0;     // counter for diagnostics

    const BAUD       = 115200;   // default bootloader baud
    const FLASH_ADDR = 0x10000;  // app partition offset
    const CHIP_LABEL = 'ESP32-S2';

    globalThis.port ||= { getInfo: () => ({ usbVendorId: undefined, usbProductId: undefined }) };

    // Find UI elements (best-effort)
    const FLASH_BUTTON =
      document.getElementById('flashBtn') ||
      document.querySelector('[data-role="flash"]') ||
      document.querySelector('#flash'); // fallback if your id is "flash"

    // Optional: cache firmware file when selected
    let __firmwareFile = null;

    /* ----------------------------------------------------------------------------
     * function setFlashEnabled(isEnabled)
     * What:  Toggle flash button enabled/disabled (CSS makes it green when enabled).
     * Ends:  Updates the #flash button disabled state.
     * -------------------------------------------------------------------------- */
    function setFlashEnabled(isEnabled) {
      if (!FLASH_BUTTON) return;
      FLASH_BUTTON.disabled = !isEnabled;
    } // END setFlashEnabled

    /* ----------------------------------------------------------------------------
     * function updateFlashButtonState()
     * What:  Enable flash only when connected (loader) AND a file is selected.
     * Ends:  Calls setFlashEnabled().
     * -------------------------------------------------------------------------- */
    function updateFlashButtonState() {
      const hasLoader = !!loader;
      const fileFromInput =
        (document.getElementById('firmware') || document.querySelector('input[type=file]'))?.files?.[0];
      const hasFile = !!(__firmwareFile || fileFromInput);
      setFlashEnabled(hasLoader && hasFile);
    } // END updateFlashButtonState

    // Initialize as disabled on load
    setFlashEnabled(false);

    // File input wiring (single-bind guard)
    const fwInput = document.getElementById('firmware') || document.querySelector('input[type=file]');
    if (fwInput && !fwInput.__wired) {
      fwInput.__wired = true;
      fwInput.addEventListener('change', (e) => {
        __firmwareFile = e.target.files?.[0] || null;
        if (__firmwareFile) {
          //log(`Firmware: ${__firmwareFile.name} ${__firmwareFile.size} bytes`);
        }
        updateFlashButtonState();
      });
    }

    // Capture the native getPorts to poll real ports even if shim later.
    try {
      if (navigator.serial?.getPorts && !navigator.serial.__nativeGetPorts) {
        Object.defineProperty(navigator.serial, '__nativeGetPorts', {
          value: navigator.serial.getPorts.bind(navigator.serial),
          configurable: true
        });
      }
    } catch {}

    // Seed ALL common aliases as accessors that resolve to the current port.
    // This guarantees (alias).getInfo exists even if a bundle reads them early.
    (function seedPortAliasAccessors() {
      const names = [
        'port', 'selectedPort', 'SerialPort', 'esptoolPort', '__PORT__',
        'serialPort', '__serialPort', '__selectedPort', 'WebSerialPort', 'ESPTOOL_PORT'
      ];
      if (!('__CURRENT_SERIAL_PORT__' in globalThis)) {
        Object.defineProperty(globalThis, '__CURRENT_SERIAL_PORT__', { value: null, writable: true });
      }
      const placeholder = { getInfo: () => ({ usbVendorId: undefined, usbProductId: undefined }) };
      for (const n of names) {
        const desc = Object.getOwnPropertyDescriptor(globalThis, n);
        if (!desc || desc.configurable) {
          try {
            Object.defineProperty(globalThis, n, {
              configurable: true,
              get() { return globalThis.__CURRENT_SERIAL_PORT__ || placeholder; },
              set(v) { globalThis.__CURRENT_SERIAL_PORT__ = v || null; }
            });
          } catch {}
        }
      }
    })();

    // -- Thenable + phantom array shim for navigator.serial.getPorts() --
    //    Immediately returns an Array with length 0 (so code won't skip the chooser)
    //    If code wrongly does getPorts()[0].getInfo(), index 0 is a non-enumerable getter
    //    returning a harmless object with .getInfo() to avoid crashes
    //    It's also a Promise (thenable), so `await navigator.serial.getPorts()` still works
    (function patchGetPorts() {
      if (!(navigator.serial && navigator.serial.getPorts) || navigator.serial.__shimPhantom) return;

      const nativeGetPorts = navigator.serial.getPorts.bind(navigator.serial);

      function safePlaceholder() {
        return { getInfo: () => ({ usbVendorId: undefined, usbProductId: undefined }) };
      }

      async function resolveRealList() {
        try {
          const list = await nativeGetPorts();
          if (Array.isArray(list) && list.length) return list;
        } catch {}
        if (globalThis.__selectedRealPort) return [globalThis.__selectedRealPort];
        return [];
      }

      navigator.serial.getPorts = function getPortsThenable() {
        // Phantom array that looks empty, but has a safe [0] accessor
        const arr = [];
        Object.defineProperty(arr, '0', {
          enumerable: false,
          configurable: true,
          get() { return safePlaceholder(); }
        });

        // Promise facet
        const p = resolveRealList();
        arr.then    = (...a) => p.then(...a);
        arr.catch   = (...a) => p.catch(...a);
        arr.finally = (...a) => p.finally(...a);
        return arr;
      };

      Object.defineProperty(navigator.serial, '__shimPhantom', { value: true });
    })();

    // --- Promise the bundle can (indirectly) await for a real SerialPort ---
    let __portResolve;
    globalThis.__portReady = new Promise(res => { __portResolve = res; });

    // --- Make getPorts() return the chosen port, or WAIT until one exists ---
    if (navigator.serial?.getPorts && !navigator.serial.__shimAwaitPort) {
      const nativeGetPorts = navigator.serial.getPorts.bind(navigator.serial);

      function pickSelectedPortSync() {
        return (
          globalThis.port ||
          globalThis.selectedPort ||
          globalThis.SerialPort ||
          globalThis.esptoolPort ||
          globalThis.__PORT__ ||
          globalThis.__selectedRealPort ||
          null
        );
      }

      navigator.serial.getPorts = function getPortsThenable() {
        const arr = [];
        Object.defineProperty(arr, '0', {
          enumerable: false,
          configurable: true,
          get() {
            const p = pickSelectedPortSync();
            return p || { getInfo: () => ({ usbVendorId: undefined, usbProductId: undefined }) };
          }
        });

        const p = (async () => {
          try {
            const list = await nativeGetPorts();
            if (Array.isArray(list) && list.length) return list;
          } catch {}
          const chosen = pickSelectedPortSync() || await globalThis.__portReady;
          return chosen ? [chosen] : [];
        })();

        arr.then    = (...a) => p.then(...a);
        arr.catch   = (...a) => p.catch(...a);
        arr.finally = (...a) => p.finally(...a);
        return arr;
      };

      Object.defineProperty(navigator.serial, '__shimAwaitPort', { value: true });
    }

    /* ----------------------------------------------------------------------------
     * function $(selector)
     * What:  Tiny DOM helper.
     * Ends:  Returns the first matching element.
     * -------------------------------------------------------------------------- */
    function $(sel) { return document.querySelector(sel); } // END $

    /* ---------- Log/Status plumbing (safe even if #debug/#status are missing) -- */
    let statusEl = $('#status');
    let debugEl  = $('#debug');

    // Progress UI handles
    let progressBar  = $('#progress-bar');
    let progressText = $('#progress-text');

    /** Set progress 0..100 and update UI. */
    function setProgress(pct) {
      const v = Math.max(0, Math.min(100, Math.floor(Number(pct) || 0)));
      if (progressBar)  progressBar.style.width = v + '%';
      if (progressText) progressText.textContent = v + '%';
    } // END setProgress

    /* ----------------------------------------------------------------------------
     * function setStatus(text)
     * What:  Update the visible status line.
     * Ends:  Writes to #status if present, and console for redundancy.
     * -------------------------------------------------------------------------- */
    function setStatus(text) {
      const msg = `Status: ${text}`;
      if (statusEl) statusEl.textContent = msg;
      console.log('[WebSerial][status]', text);
    } // END setStatus

    /* ----------------------------------------------------------------------------
     * function log(...args)
     * What:  Centralized debug logger with timestamp and #debug sink.
     * Ends:  Appends a line in #debug and prints to console.
     * -------------------------------------------------------------------------- */
    function log(...args) {
	
	  /* Uncommen the Top Sections for date and time stamps in debug */
      //const ts = new Date().toISOString().replace('T', ' ').replace('Z', '');
      //console.log('[WebSerial]', ts, ...args);
      //if (!debugEl) return;
      //try {
        //const line = [ts, ...args.map(v => (typeof v === 'string' ? v : JSON.stringify(v)))].join(' ');
        //debugEl.textContent += line + '\n';
        //debugEl.scrollTop = debugEl.scrollHeight;
      //} catch {}
    
	
	  // Console (no manual timestamp)
	  console.log('[WebSerial]', ...args);

	  // On-page debug console (no timestamp prefix)
	  if (!debugEl) return;
	  try {
		const line = args.map(v => (typeof v === 'string' ? v : JSON.stringify(v))).join(' ');
		debugEl.textContent += line + '\n';
		debugEl.scrollTop = debugEl.scrollHeight;
	  } catch {
		/* ignore rendering issues */
	  }
	
	} // END log

    /* --------------------------------------------------
       Global error breadcrumbs
       -------------------------------------------------- */
    window.addEventListener('error', ev =>
      log('[window.onerror]', ev?.message || ev)
    );
    window.addEventListener('unhandledrejection', ev =>
      log('[unhandled]', ev?.reason?.message || String(ev?.reason))
    );

    // Extra serial connect/disconnect breadcrumbs (native-USB reboot visibility)
    // Track last event timestamps to detect a reboot mid-handshake.
    let __lastSerialEvents = { connect: 0, disconnect: 0 };
    try {
      const safeInfo = p => { try { return p?.getInfo?.() || '(no getInfo)'; } catch { return '(no getInfo)'; } };
      navigator.serial?.addEventListener?.('connect', ev => {
        __lastSerialEvents.connect = Date.now();
        log('[serial event] connect:', safeInfo(ev?.port));
      });
      navigator.serial?.addEventListener?.('disconnect', ev => {
        __lastSerialEvents.disconnect = Date.now();
        log('[serial event] disconnect:', safeInfo(ev?.port));
      });
    } catch {}

    /* ----------------------------------------------------------------------------
     * function onReady(fn)
     * What:  Robust DOM-ready shim; runs immediately if DOM already parsed.
     * Ends:  Executes `fn` exactly once.
     * -------------------------------------------------------------------------- */
    function onReady(fn) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          try { fn(); } catch (e) { console.error('[ready->fn]', e); }
        }, { once: true });
      } else {
        try { fn(); } catch (e) { console.error('[ready->fn]', e); }
      }
    } // END onReady

    /* ----------------------------------------------------------------------------
     * function ensureTerminalAPI(t)
     * What:  Normalize/patch a terminal object so esptool can safely call:
     *        t.clean(), t.write(), t.writeLine()/writeln()/println()
     * Ends:  Returns a terminal object with guaranteed methods.
     * -------------------------------------------------------------------------- */
    function ensureTerminalAPI(t) {
      const fallback = {
        clean   : () => { if (debugEl) debugEl.textContent = ''; },
        write   : (s='') => log(String(s).replace(/\r/g,'')),
        writeLine: (s='') => log(String(s).replace(/\r/g,'')),
        writeln : (s='') => log(String(s).replace(/\r/g,'')),
        println : (s='') => log(String(s).replace(/\r/g,'')),
      };
      const base = (t && typeof t === 'object') ? t : {};
      base.write     = base.write     || fallback.write;
      base.writeLine = base.writeLine || base.writeln || base.println || fallback.writeLine;
      base.writeln   = base.writeln   || base.writeLine;
      base.println   = base.println   || base.writeLine;
      base.clean     = base.clean     || fallback.clean;
      return base;
    } // END ensureTerminalAPI

    // Patch helpers for bundle import: expose the selected port during import.
    // Handles callers that call getPorts(), await getPorts, index getPorts[0],
    // or even read non-standard navigator.serial.ports[0].
    // UPDATE: getPorts() now returns a *thenable array* so `getPorts()[0]` works.
    async function __withPortExposedForBundle(selectedPort, thunk) {
      const aliasNames = [
        'port','selectedPort','SerialPort','esptoolPort','__PORT__',
        'serialPort','__serialPort','__selectedPort','WebSerialPort','ESPTOOL_PORT'
      ];
      const prevGlobal = {};
      for (const n of aliasNames) { prevGlobal[n] = globalThis[n]; globalThis[n] = selectedPort; }

      const ns = navigator.serial;
      let restoreGetPorts = null;
      let restorePortsProp = null;

      function makeThenableArray() {
        const arr = [];
        Object.defineProperty(arr, '0',      { configurable: true, get: () => selectedPort });
        Object.defineProperty(arr, 'length', { configurable: true, get: () => 1 });
        const p = Promise.resolve([selectedPort]);
        arr.then    = (...a) => p.then(...a);
        arr.catch   = (...a) => p.catch(...a);
        arr.finally = (...a) => p.finally(...a);
        return arr;
      }

      if (ns) {
        const nativeGetPorts = typeof ns.getPorts === 'function' ? ns.getPorts.bind(ns) : null;

        // getPorts callable that returns a *thenable array*
        function getPortsCallable() { return makeThenableArray(); }
        // Also support navigator.serial.getPorts[0]
        Object.defineProperty(getPortsCallable, '0', { configurable: true, get: () => selectedPort });

        if (nativeGetPorts) {
          ns.getPorts = getPortsCallable;
          restoreGetPorts = () => { ns.getPorts = nativeGetPorts; };
        }

        // Ensure navigator.serial.ports[0] works
        const portsArrayGetter = () => [selectedPort];
        const hadOwnPorts = Object.prototype.hasOwnProperty.call(ns, 'ports');
        const oldPortsDesc = hadOwnPorts ? Object.getOwnPropertyDescriptor(ns, 'ports') : undefined;

        try {
          Object.defineProperty(ns, 'ports', { configurable: true, enumerable: false, get: portsArrayGetter });
          restorePortsProp = () => {
            if (hadOwnPorts && oldPortsDesc) Object.defineProperty(ns, 'ports', oldPortsDesc);
            else { try { delete ns.ports; } catch {} }
          };
        } catch {}
      }

      try {
        return await thunk();
      } finally {
        if (restoreGetPorts)  try { restoreGetPorts(); }  catch {}
        if (restorePortsProp) try { restorePortsProp(); } catch {}
        for (const n of Object.keys(prevGlobal)) { try { globalThis[n] = prevGlobal[n]; } catch {} }
      }
    } // END __withPortExposedForBundle

    /*-------------------------------------------------------------------------------
    // Make "weird" bundle probes always see the selected SerialPort.
    // Covers: navigator.serial.getPorts[0], navigator.serial.ports[0],
    //         getPorts() (returns [port] as a *thenable array*), and global aliases.
    // UPDATE: getPorts() now returns a *thenable array* so `getPorts()[0]` works.
    --------------------------------------------------------------------------------*/
    function installPortShims(selectedPort) {
      if (!selectedPort) return;

      // 1) Global aliases some builds probe for
      const names = [
        'port','selectedPort','SerialPort','esptoolPort','__PORT__',
        'serialPort','__serialPort','__selectedPort','WebSerialPort','ESPTOOL_PORT'
      ];
      for (const n of names) { try { globalThis[n] = selectedPort; } catch {} }

      // Ensure selectedPort.getInfo exists
      try {
        if (typeof selectedPort.getInfo !== 'function') {
          Object.defineProperty(selectedPort, 'getInfo', {
            value: () => ({ usbVendorId: undefined, usbProductId: undefined })
          });
        }
      } catch {}

      // 2) navigator.serial.* shims
      const ns = navigator.serial;
      try {
        if (!ns.__nativeGetPorts && typeof ns.getPorts === 'function') {
          Object.defineProperty(ns, '__nativeGetPorts', { value: ns.getPorts.bind(ns) });
        }
      } catch {}
      if (!ns) return;

      // 2a) Ensure navigator.serial.ports[0] works
      try {
        Object.defineProperty(ns, 'ports', {
          configurable: true,
          get: () => [selectedPort],
        });
      } catch {}
    } // END installPortShims

    // Best-effort: escalate control-signal failures so outer catch can rebind.
    // UPDATE: throw a sentinel error on the first failure after reboot starts.
    function __shimSetSignals(target, label = 'obj') {
      if (!target || typeof target.setSignals !== 'function' || target.setSignals.__shimmed) return;
      const native = target.setSignals.bind(target);
      target.setSignals = async function patchedSetSignals(signals) {
        try {
          return await native(signals);
        } catch (e) {
          const msg = e?.message || '';
          if (e?.name === 'NetworkError' || /set control signals/i.test(msg)) {
            const started = __connectAttemptTs || 0;
            const sawDiscDuringAttempt =
              (__lastSerialEvents.disconnect && __lastSerialEvents.disconnect >= started);

            // Always escalate so the outer try/catch can run the rebind flow.
            const phase = sawDiscDuringAttempt ? 'post-disconnect' : 'pre-disconnect';
            log(`[${label}.setSignals shim] transient ${phase} — throwing sentinel to rebind:`, msg);

            const err = new Error('setSignals transient');
            err.name = 'NetworkError';
            throw err;
          }
          throw e;
        }
      };
      Object.defineProperty(target.setSignals, '__shimmed', { value: true });
    } // END_of_shimsetsignals

    // Coerce bad baud values and make open() idempotent across bundle calls
    function __shimOpenAndBaud(target, label = 'obj') {
      if (!target) return;

      // Wrap open() to clamp invalid baudRate (e.g., 0)
      if (typeof target.open === 'function' && !target.open.__baudShim) {
        const native = target.open.bind(target);
        const shim = async (opts = {}) => {
          if (opts && typeof opts === 'object') {
            const raw = Number(opts.baudRate ?? opts.baudrate ?? opts.baud);
            if (!Number.isFinite(raw) || raw <= 0) {
              log(`[${label}.open shim] invalid baud=${raw}; using ${BAUD}`);
              opts = { ...opts, baudRate: BAUD };
            }
          }
          return native(opts);
        };
        Object.defineProperty(shim, '__baudShim', { value: true });
        target.open = shim;
      }

      // Wrap setBaudRate / setBaudrate if present
      for (const name of ['setBaudRate', 'setBaudrate']) {
        if (typeof target[name] === 'function' && !target[name].__baudShim) {
          const native = target[name].bind(target);
          const shim = async (rate) => {
            let r = Number(rate);
            if (!Number.isFinite(r) || r <= 0) {
              log(`[${label}.${name} shim] invalid baud=${r}; keeping ${BAUD}`);
              r = BAUD;
            }
            return native(r);
          };
          Object.defineProperty(shim, '__baudShim', { value: true });
          target[name] = shim;
        }
      }
    } // END_Of_ShimOpenandBaud

    /* ----------------------------------------------------------------------------
     * function waitForReenumeration(prevPort, prevInfo, timeoutMs=12000)
     * What:  Wait for device to disconnect/reconnect and return the *new* SerialPort.
     * Notes: Uses native getPorts (not shims) and resolves on the first connect event
     *        whose port !== prevPort. Adds a short settle delay.
     * -------------------------------------------------------------------------- */
    async function waitForReenumeration(prevPort, prevInfo, timeoutMs = 12000) {
      const nativeGetPorts =
        navigator.serial?.__nativeGetPorts ||
        (navigator.serial?.getPorts && navigator.serial.getPorts.bind(navigator.serial)) ||
        null;

      return new Promise((resolve) => {
        let done = false;

        const finish = async (cand) => {
          if (done) return;
          done = true;
          cleanup();
          try { await new Promise(r => setTimeout(r, 250)); } catch {}
          resolve(cand || null);
        };

        const onConnect = (ev) => {
          const cand = ev?.port;
          const sameObj = cand === prevPort;
          try {
            const info = cand?.getInfo?.();
            log('[rebind] connect event candidate:', info || '(no getInfo)', 'sameObj=', sameObj);
          } catch {
            log('[rebind] connect event candidate: (no getInfo) sameObj=', sameObj);
          }
          if (!sameObj && cand) finish(cand);
        };

        const cleanup = () => {
          try { navigator.serial?.removeEventListener?.('connect', onConnect); } catch {}
          clearTimeout(tmr);
        };

        // Listen for the OS connect event
        try { navigator.serial?.addEventListener?.('connect', onConnect); } catch {}

        // Poll with the *native* getter in case the event is missed
        (async function poll() {
          const end = Date.now() + timeoutMs;
          try { await new Promise(r => setTimeout(r, 150)); } catch {}
          while (!done && Date.now() < end) {
            try {
              const getList = navigator.serial?.__nativeGetPorts || navigator.serial?.getPorts;
              const list = await getList?.();
              const cand = Array.isArray(list) ? list.find(p => p && p !== prevPort) : null;
              if (cand) return finish(cand);
            } catch {}
            try { await new Promise(r => setTimeout(r, 200)); } catch {}
          }
          finish(null);
        })();

        const tmr = setTimeout(() => finish(null), timeoutMs + 500);
      });
    } // END-Of_WaitforReenumeration

    /* ----------------------------------------------------------------------------
     * function connect()
     * What:  Opens the Web Serial chooser, safely opens the port, preps esptool
     *        transport/loader, syncs with ROM bootloader, and updates UI state.
     * When:  Called by the Connect button. Single-flight guarded.
     * Ends:  Resolves with detected chip label; leaves `loader` ready for flashing.
     * -------------------------------------------------------------------------- */
    async function connect() {
      const call = ++__connectCalls;
      if (__isConnecting) {
        log(`[connect #${call}] already running; ignoring.`);
        return;
      }
      __isConnecting = true;
      log(`[connect #${call}] start`);

      let openedHere = false;
      let connected  = false;

      try {
        // Environment checks
        if (!('serial' in navigator)) {
          alert('Web Serial not supported. Use Chrome/Edge desktop.');
          throw new Error('Web Serial unsupported');
        }
        if (!window.isSecureContext && location.protocol !== 'file:') {
          alert('Not a secure context. Use HTTPS, http://localhost, or open the file directly.');
          throw new Error('Insecure context');
        }
        try {
          const p = await navigator.permissions?.query?.({ name: 'serial' });
          log('[connect] Permission state:', p?.state);
        } catch {}

        // Always show the chooser
        setStatus('Opening serial chooser…');
        log('[connect] navigator.serial.requestPort()…');
        try {
          port = await navigator.serial.requestPort();
          log('[connect] Port chosen:', typeof port?.getInfo === 'function' ? port.getInfo() : '(no getInfo)');
          installPortShims(port);
          __shimSetSignals(port, 'port');
          __shimOpenAndBaud(port, 'port');

          if (typeof port.getInfo !== 'function') {
            try {
              Object.defineProperty(port, 'getInfo', {
                value: () => ({ usbVendorId: undefined, usbProductId: undefined })
              });
            } catch {}
          }

          // Expose for legacy/variant bundles
          globalThis.port         = port;
          globalThis.selectedPort = port;
          globalThis.SerialPort   = port;
          globalThis.esptoolPort  = port;
          globalThis.__PORT__     = port;

          // Extra aliases
          globalThis.serialPort            = port;
          globalThis.__serialPort          = port;
          globalThis.__selectedPort        = port;
          globalThis.WebSerialPort         = port;
          globalThis.ESPTOOL_PORT          = port;
          globalThis.__selectedRealPort    = port;
          globalThis.__CURRENT_SERIAL_PORT__ = port;

          // Let the shimmed getPorts() resolve to this port
          try { if (typeof __portResolve === 'function') __portResolve(port); } catch {}

        } catch (e) {
          if (e?.name === 'NotFoundError' || e?.name === 'AbortError') {
            setStatus('Connect cancelled.');
            log('[connect] chooser cancelled');
            return;
          }
          if (e?.name === 'SecurityError') {
            alert('Allow Serial in chrome://settings/content/serialPorts');
            throw e;
          }
          throw e;
        }

        // Open if not already open
        if (!port.readable) {
          log('[connect] Opening port @', BAUD, 'baud…');
          try {
            await port.open({ baudRate: BAUD });
            openedHere = true;
          } catch (e) {
            const msg = e?.message || '';
            if (e?.name === 'InvalidStateError' || /already open/i.test(msg)) {
              log('[connect] open(): already open — continuing.');
            } else if (/another app|in use/i.test(msg)) {
              setStatus('Port is already open in another app/tab.');
              throw new Error('Port is already open in another app/tab.');
            } else {
              throw e;
            }
          }
        } else {
          log('[connect] Port appears open already (port.readable present); continuing.');
        }

        // Nudge DTR/RTS (best effort)
        try {
          await port.setSignals({ dataTerminalReady: false, requestToSend: true  }); await new Promise(r => setTimeout(r, 100));
          await port.setSignals({ dataTerminalReady: true,  requestToSend: false }); await new Promise(r => setTimeout(r, 100));
          log('[connect] Toggled DTR/RTS');
        } catch (e) {
          log('[connect] setSignals warning:', e?.message || e);
        }

        // Idempotent-open shim — some bundles call port.open() again during connect()
        try {
          const nativeOpen = port.open?.bind(port);
          if (nativeOpen && !port.__openShim) {
            Object.defineProperty(port, '__openShim', { value: true });
            port.open = async function patchedOpen(opts) {
              if (port.readable) {
                log('[port.open shim] already open — ignoring duplicate open',
                    opts ? JSON.stringify(opts) : '');
                return;
              }
              return nativeOpen(opts);
            };
          }
        } catch (e) {
          log('[port.open shim] warn:', e?.message || String(e));
        }

        // Lazy-load esptool bundle exactly once
        if (!esptoolPromise) {
          if (typeof importEsptoolFromBase64 !== 'function') {
            alert('Bundle helper importEsptoolFromBase64() missing.');
            throw new Error('importEsptoolFromBase64() is missing from the bundle.');
          }

          // Preflight visibility before import
          try {
            const gp = navigator.serial?.getPorts;
            log('[preflight] typeof getPorts =', typeof gp);
            log('[preflight] getPorts[0] type =', typeof gp?.[0],
                'ports[0] type =', typeof navigator.serial?.ports?.[0]);
            const idx0 = gp?.[0];
            if (idx0 && typeof idx0.getInfo === 'function') {
              try { log('[preflight] getPorts[0].getInfo():', idx0.getInfo()); }
              catch (e) { log('[preflight] getPorts[0].getInfo() threw:', e?.message); }
            }
            const arr = await gp?.();
            log('[preflight] await getPorts() len =',
                Array.isArray(arr) ? arr.length : '(n/a)',
                'first ok =', !!arr?.[0],
                'first.getInfo =', typeof arr?.[0]?.getInfo);
          } catch (e) {
            log('[preflight] probe error:', e?.message || String(e));
          }

          // Import while the selected port is exposed
          esptoolPromise = __withPortExposedForBundle(port, async () => {
            log('[connect] esptool bundle import initiated…');
            try {
              const mod = await importEsptoolFromBase64();
              log('[connect] esptool bundle import OK');
              return mod;
            } catch (e) {
              console.error('[connect] import failed:', e?.message || e, e?.stack || '(no stack)');
              try {
                const gp = navigator.serial?.getPorts;
                console.error('[import fail] typeof getPorts =', typeof gp,
                              'getPorts[0] =', typeof gp?.[0],
                              'ports[0] =', typeof navigator.serial?.ports?.[0]);
              } catch {}
              throw e;
            }
          });
        }

        const mod = await esptoolPromise;
        log('[connect] esptool bundle import OK');
        globalThis.__ESPTOOL_MOD__ = mod; // debug: allow flash() to inspect module if needed

        if (typeof prepareEsptool !== 'function') {
          throw new Error('prepareEsptool() is missing from the bundle.');
        }
        const { makeTransport, makeLoader } = prepareEsptool(mod);

        // Terminal used by esptool (and our debug log)
        const term = ensureTerminalAPI({ write: (s = '') => log(String(s).replace(/\r/g, '')) });

        // Build transport
        transport = makeTransport(port);
        log('[connect] transport created:', transport && (transport.constructor?.name || String(transport)));
        __shimSetSignals(transport, 'transport');
        __shimOpenAndBaud(transport, 'transport');

        // Ensure transport.port exists + make transport.open tolerant (before loader build)
        if (transport && !transport.port) {
          log('[connect] transport.port missing; patching with selected port.');
          try { Object.defineProperty(transport, 'port', { value: port, configurable: true }); } catch {}
        }

        try {
          if (transport && typeof transport.open === 'function' && !transport.open.__shim) {
            const nativeTOpen = transport.open.bind(transport);
            const shim = async (...args) => {
              try {
                if (port?.readable) {
                  log('[transport.open shim] already open — skipping transport.open()');
                  return;
                }
                return await nativeTOpen(...args);
              } catch (e) {
                const msg = e?.message || '';
                if (e?.name === 'InvalidStateError' || /already open/i.test(msg)) {
                  log('[transport.open shim] already open — continuing.');
                  return;
                }
                throw e;
              }
            };
            Object.defineProperty(shim, '__shim', { value: true });
            transport.open = shim;
          }
        } catch (e) {
          log('[transport.open shim] warn:', e?.message || String(e));
        }

        // === BUILD LOADER (robust + verbose) ===
        let _loader = null;
        try {
          _loader = await makeLoader(transport, BAUD, term);
          log('[connect] makeLoader(transport, …) OK:', _loader?.constructor?.name || typeof _loader);
        } catch (e1) {
          log('[connect] makeLoader threw:', e1?.message || String(e1));

          // Fallback 1: some bundles export makeLoader(port, baud, term)
          try {
            if (typeof mod.makeLoader === 'function') {
              _loader = await mod.makeLoader(port, BAUD, term);
              log('[connect] makeLoader(port, …) fallback OK');
            } else {
              throw e1;
            }
          } catch (e2) {
            // Fallback 2: construct ESPLoader ourselves
            try {
              const T = mod.Transport || mod.EsptoolTransport;
              const L = mod.ESPLoader || (mod.default && mod.default.ESPLoader);
              if (!T || !L) throw e2;
              const t2 = (transport && transport.port) ? transport : new T(port);
              _loader = new L(t2, BAUD, term);
              log('[connect] ESPLoader(new Transport(port), …) fallback OK');
            } catch (e3) {
              log('[connect] loader fallback failed:', e3?.message || String(e3));
              throw e1; // preserve original context
            }
          }
        }

        loader = _loader;
        if (!loader) throw new Error('Loader factory returned null/undefined.');
        loader.terminal = ensureTerminalAPI(loader.terminal);

        // Optional: try a bundle reset helper (best effort)
        try {
          if (mod.ClassicReset) {
            const Reset = mod.ClassicReset;
            const r = new Reset(transport);
            if (typeof r.run === 'function') {
              await r.run();
              log('[connect] ClassicReset run OK');
            }
          }
        } catch (e) {
          log('[connect] reset helper ignored:', e?.message || String(e));
        }

        // === Resolve entrypoint and sync ===
        const main = loader.main_fn || loader.main || loader.sync || loader.connect || loader.detect;
        log('[connect] resolved main =', main?.name || '(anonymous)');
        if (!main) throw new Error('Loader has no main function on this bundle.');

        setStatus('Syncing with ROM bootloader…');
        log('[connect] Calling loader main…');
        __connectAttemptTs = Date.now();

        // REBIND-SAFE handshake
        let detected;
        try {
          detected = await main.call(loader);
        } catch (e) {
          const msg = e?.message || String(e);
          if (/setSignals|NetworkError/i.test(msg)) {
            log('[rebind] Handshake interrupted (likely USB reboot). Waiting for new port…');
            const prevInfo = (typeof port?.getInfo === 'function') ? port.getInfo() : null;
            const newPort  = await waitForReenumeration(port, prevInfo, 8000);

            if (newPort) {
              // Adopt fresh handle
              port = newPort;
              installPortShims(port);
              __shimSetSignals(port, 'port');
              __shimOpenAndBaud(port, 'port');

              // Refresh global aliases
              globalThis.port = globalThis.selectedPort = globalThis.SerialPort =
              globalThis.esptoolPort = globalThis.__PORT__ = port;
              globalThis.__selectedRealPort = globalThis.__CURRENT_SERIAL_PORT__ = port;

              // Settle & reopen if needed
              try { await new Promise(r => setTimeout(r, 350)); } catch {}
              try {
                const nativeOpen = port.open?.bind(port);
                if (nativeOpen && !port.__openShim) {
                  Object.defineProperty(port, '__openShim', { value: true });
                  port.open = async function patchedOpen(opts) {
                    const br = (opts && Number(opts.baudRate)) || BAUD;
                    if (!br || br <= 0) {
                      log('[port.open shim] invalid baud=', br, '; using', BAUD);
                      opts = { ...(opts || {}), baudRate: BAUD };
                    }
                    if (port.readable) {
                      log('[port.open shim] already open — ignoring duplicate open',
                          opts ? JSON.stringify(opts) : '');
                      return;
                    }
                    return nativeOpen(opts);
                  };
                }
                if (!port.readable) await port.open({ baudRate: BAUD });
              } catch (eOpen) {
                log('[rebind] open on new port failed:', eOpen?.message || String(eOpen));
                throw e;
              }

              // Rebuild transport
              try {
                transport = makeTransport(port);
                log('[rebind] new transport:', transport?.constructor?.name || typeof transport);
                if (!transport.port) { try { Object.defineProperty(transport, 'port', { value: port, configurable: true }); } catch {} }
                __shimSetSignals(transport, 'transport');
                __shimOpenAndBaud(transport, 'transport');

                if (typeof transport.open === 'function' && !transport.open.__shim) {
                  const nativeTOpen = transport.open.bind(transport);
                  const shim = async (...args) => {
                    try {
                      if (port?.readable) {
                        log('[transport.open shim] already open — skipping transport.open()');
                        return;
                      }
                      return await nativeTOpen(...args);
                    } catch (eTO) {
                      const m2 = eTO?.message || '';
                      if (eTO?.name === 'InvalidStateError' || /already open/i.test(m2)) {
                        log('[transport.open shim] already open — continuing.');
                        return;
                      }
                      throw eTO;
                    }
                  };
                  Object.defineProperty(shim, '__shim', { value: true });
                  transport.open = shim;
                }
              } catch (eT) {
                log('[rebind] transport rebuild failed:', eT?.message || String(eT));
                throw eT;
              }

              // Rebuild loader
              try {
                loader = await makeLoader(transport, BAUD, term);
                loader.terminal = ensureTerminalAPI(loader.terminal);
                log('[rebind] new loader:', loader?.constructor?.name || typeof loader);
              } catch (eL) {
                log('[rebind] loader rebuild failed:', eL?.message || String(eL));
                throw eL;
              }

              // Gentle DTR/RTS tickle
              try {
                await port.setSignals?.({ dataTerminalReady: false, requestToSend: true  }); await new Promise(r => setTimeout(r, 120));
                await port.setSignals?.({ dataTerminalReady: true,  requestToSend: false }); await new Promise(r => setTimeout(r, 120));
              } catch (eSig) {
                log('[rebind] post-toggle warning:', eSig?.message || String(eSig));
              }

              try { await new Promise(r => setTimeout(r, 250)); } catch {}
              log('[rebind] Retrying loader main on new port…');
              __connectAttemptTs = Date.now();
              detected = await (loader.main_fn || loader.main || loader.sync || loader.connect || loader.detect).call(loader);

            } else {
              log('[rebind] Timed out waiting for re-enumeration.');
              throw e;
            }
          } else {
            throw e;
          }
        }

        const label = detected || CHIP_LABEL;
        connected = true;

        log('[connect] Connected to', label, 'portInfo=',
            typeof port?.getInfo === 'function' ? port.getInfo() : '(no getInfo)');
        setStatus(`Connected (${label})`);
        updateFlashButtonState();
        return label;

      } catch (e) {
        log('[connect] ERROR:', e?.name || 'Error', '-', e?.message || String(e));
        const msg = e?.message || e?.name || String(e);
        if (/in another app|another application|in use/i.test(msg)) {
          alert('The selected serial port is already open in another app or tab. Close it there and try again.');
        } else if (/Web Serial unsupported|Insecure context/.test(msg)) {
          // Already alerted above
        } else {
          alert(msg);
        }
        throw e;

      } finally {
        // If connect failed and opened the port, best-effort close so next try works
        try {
          log('[connect] finally:', { openedHere, connected, readable: !!port?.readable });
          if (openedHere && !connected && port?.readable) {
            log('[connect] Closing port due to failure…');
            setFlashEnabled(false);
            await port.close();
          }
        } catch {}
        __isConnecting = false;
        log('[connect] end');
      }
    } // end connect()

    /* ----------------------------------------------------------------------------
     * function flashFile(file)
     * Always sends a DTR/RTS pulse after.
     * -------------------------------------------------------------------------- */
    async function flashFile(file) {
      log('[flash] start');
      setProgress(0);
      if (!file)   throw new Error('No firmware selected.');
      if (!loader) throw new Error('Not connected. Click Connect first.');

      const bytes = new Uint8Array(await file.arrayBuffer());
      log('[flash] file:', file.name, 'size:', bytes.length, 'bytes');

      // Helper: detect chip name for reset gating
      const chipName = (() => {
        try {
          if (loader.chip?.CHIP_NAME) return String(loader.chip.CHIP_NAME);
          if (loader.chip?.name)      return String(loader.chip.name);
          if (typeof loader.getChip === 'function') return String(loader.getChip());
        } catch {}
        return '';
      })();
      const is8266 = /8266/i.test(chipName);

      // Progress helper
      const reportProgress = (sent, total) => {
        const pct = Math.floor((sent / total) * 100);
        if (!reportProgress.__last || pct - reportProgress.__last >= 10 || pct === 100) {
          reportProgress.__last = pct;
          log(`[flash] progress ${pct}% (${sent}/${total})`);
          setProgress(pct);
        }
      };

      // Best-effort reboot: only softReset on ESP8266; always DTR/RTS pulse
      const bestEffortReboot = async () => {
        if (is8266 && typeof loader.softReset === 'function') {
          try { await loader.softReset(); log('[flash] softReset (ESP8266) issued'); }
          catch (e) { log('[flash] softReset note:', e?.message || String(e)); }
        }
        try {
          await port?.setSignals?.({ dataTerminalReady: false, requestToSend: true  }); await new Promise(r => setTimeout(r, 80));
          await port?.setSignals?.({ dataTerminalReady: true,  requestToSend: false }); await new Promise(r => setTimeout(r, 80));
          await port?.setSignals?.({ dataTerminalReady: false, requestToSend: false });
          log('[flash] DTR/RTS pulse sent');
        } catch (e) {
          log('[flash] DTR/RTS pulse note:', e?.message || String(e));
        }
      };

      // Try 1: canonical write_flash([[addr, bytes]])
      if (typeof loader.write_flash === 'function') {
        setStatus('Flashing…');
        log('[flash] using loader.write_flash([[addr, bytes]]) at', FLASH_ADDR);
        await loader.write_flash([[FLASH_ADDR, bytes]]);
        setProgress(100);
        await bestEffortReboot();
        setStatus('Flash complete.');
        log('[flash] done via write_flash');
        return;
      }

      // Try 2: low-level flashBegin/flashBlock/flashFinish
      const fb   = loader.flashBegin   || loader.flash_begin;
      const fblk = loader.flashBlock   || loader.flashData  || loader.flash_data;
      const ff   = loader.flashFinish  || loader.flash_finish;

      if (typeof fb === 'function' && typeof fblk === 'function' && typeof ff === 'function') {
        setStatus('Flashing…');
        log('[flash] using low-level flashBegin/flashBlock/flashFinish at', FLASH_ADDR);

        const blockSize =
          loader.FLASH_WRITE_SIZE  ||
          loader.ESP_RAM_BLOCK     ||
          loader.FLASH_WRITE_CHUNK ||
          0x4000;

        const total  = bytes.length;
        const blocks = Math.ceil(total / blockSize);

        if (fb.length >= 4) {
          log('[flash] flashBegin(size, blocks, blockSize, offset)=', total, blocks, blockSize, FLASH_ADDR);
          await fb.call(loader, total, blocks, blockSize, FLASH_ADDR);
        } else {
          log('[flash] flashBegin(size, offset)=', total, FLASH_ADDR);
          await fb.call(loader, total, FLASH_ADDR);
        }

        let sent = 0;
        for (let seq = 0; sent < total; seq++) {
          const chunk = bytes.subarray(sent, Math.min(sent + blockSize, total));
          if (fblk.length >= 2) await fblk.call(loader, chunk, seq);
          else                  await fblk.call(loader, chunk);
          sent += chunk.length;
          reportProgress(sent, total);
        }

        try {
          if (ff.length >= 1) {
            await ff.call(loader, /*reboot*/ true);
            log('[flash] flashFinish(true) requested reboot');
          } else {
            await ff.call(loader);
            log('[flash] flashFinish() done');
          }
        } catch (e) {
          log('[flash] flashFinish note:', e?.message || String(e));
        }

        await bestEffortReboot();
        setStatus('Flash complete.');
        log('[flash] done via flashBegin/Block/Finish');
        return;
      }

      // Try 3: writeFlash(bytes, addr)
      if (typeof loader.writeFlash === 'function' && loader.writeFlash.length >= 2) {
        setStatus('Flashing…');
        log('[flash] using loader.writeFlash(bytes, addr) at', FLASH_ADDR);
        await loader.writeFlash(bytes, FLASH_ADDR);
        setProgress(100);
        await bestEffortReboot();
        setStatus('Flash complete.');
        log('[flash] done via writeFlash(bytes, addr)');
        return;
      }

      // Try 4: program() shapes
      if (typeof loader.program === 'function') {
        setStatus('Flashing…');
        log('[flash] trying loader.program variants…');
        try {
          await loader.program([[FLASH_ADDR, bytes]]);
          await bestEffortReboot();
          setStatus('Flash complete.');
          log('[flash] done via program([[addr,bytes]])');
          setProgress(100);
          return;
        } catch {}

        try {
          await loader.program([{ address: FLASH_ADDR, data: bytes }]);
          await bestEffortReboot();
          setStatus('Flash complete.');
          log('[flash] done via program([{address,data}])');
          setProgress(100);
          return;
        } catch {}

        try {
          await loader.program(bytes, FLASH_ADDR);
          await bestEffortReboot();
          setStatus('Flash complete.');
          log('[flash] done via program(bytes,addr)');
          setProgress(100);
          return;
        } catch {}
      }

      // No usable path found
      try {
        log('[flash] NO suitable flasher found. Own keys:', Object.keys(loader || {}));
        log('[flash] Proto keys:', Object.getOwnPropertyNames(Object.getPrototypeOf(loader) || {}));
      } catch {}
      throw new Error('No flash function found on loader (flashFile/write_flash).');
    } // end flashFile()

    /* ==================== 	BASE64 BUNDLE DEFINITION 	====================
       ----------------------------------------------------------------------------
       ========================================================================== */
    const ESPT_BUNDLE_BASE64 = `
	dmFyIGVzPU9iamVjdC5jcmVhdGU7dmFyIGd0PU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgaXM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgc3M9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIGFzPU9iamVjdC5nZXRQcm90b3R5cGVPZixucz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBHPSh0LGUpPT4oKT0+KHQmJihlPXQodD0wKSksZSk7dmFyIG09KHQsZSk9PigpPT4oZXx8dCgoZT17ZXhwb3J0czp7fX0pLmV4cG9ydHMsZSksZS5leHBvcnRzKSxKPSh0LGUpPT57Zm9yKHZhciBBIGluIGUpZ3QodCxBLHtnZXQ6ZVtBXSxlbnVtZXJhYmxlOiEwfSl9LEVzPSh0LGUsQSxpKT0+e2lmKGUmJnR5cGVvZiBlPT0ib2JqZWN0Inx8dHlwZW9mIGU9PSJmdW5jdGlvbiIpZm9yKGxldCBzIG9mIHNzKGUpKSFucy5jYWxsKHQscykmJnMhPT1BJiZndCh0LHMse2dldDooKT0+ZVtzXSxlbnVtZXJhYmxlOiEoaT1pcyhlLHMpKXx8aS5lbnVtZXJhYmxlfSk7cmV0dXJuIHR9O3ZhciBLPSh0LGUsQSk9PihBPXQhPW51bGw/ZXMoYXModCkpOnt9LEVzKGV8fCF0fHwhdC5fX2VzTW9kdWxlP2d0KEEsImRlZmF1bHQiLHt2YWx1ZTp0LGVudW1lcmFibGU6ITB9KTpBLHQpKTt2YXIgUmk9bSgoY0UsRGkpPT57RGkuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gYXRvYihlKX19KTt2YXIgTWk9bSgoQkUsTm4pPT57Tm4uZXhwb3J0cz17ZW50cnk6MTA3NDUyMTU4MCx0ZXh0OiJDQUQwUHh3QTlEOEFBUFEvQU1EOFB4QUE5RDgyUVFBaCt2L0FJQUE0QWtINS84QWdBQ2dFSUNCMG5PSUdCUUFBQUVIMS80SDIvOEFnQUtnRWlBaWdvSFRnQ0FBTEltWUM1NGIwL3lIeC84QWdBRGtDSGZBQUFLRHIvVDhZYS8wL2hJQUFBRUJBQUFCWXEvMC9wT3Y5UHpaQkFMSDUveUNnZEJBUklPWE9BSllhQm9IMi81S2hBWkNaRVpxWXdDQUF1QW1SOC8rZ29IU2FpTUFnQUpJWUFKQ1E5QnZKd01EMHdDQUF3bGdBbXB2QUlBQ2lTUURBSUFDU0dBQ0I2ditRa1BTQWdQU0htVWVCNWYrU29RR1FtUkdhbU1BZ0FNZ0pvZVgvc2VQL2g1d1h4Z0VBZk9pSEd0N0dDQURBSUFDSkNzQWdBTGtKUmdJQXdDQUF1UXJBSUFDSkNaSFgvNXFJREFuQUlBQ1NXQUFkOEFBQStDRDBQL2d3OUQ4MlFRQ1IvZi9BSUFDSUNZQ0FKRlpJLzVINi84QWdBSWdKZ0lBa1Zrai9IZkFBQUFBUUlQUS9BQ0QwUHdBQUFBZzJRUUFRRVNDbC9QOGgrdjhNQ01BZ0FJSmlBSkg2LzRINC84QWdBSkpvQU1BZ0FKZ0lWbm4vd0NBQWlBSjg4b0FpTUNBZ0JCM3dBQUFBQUVBMlFRQVFFU0RsKy84V2F2K0I3UCtSKy8vQUlBQ1NhQURBSUFDWUNGWjUveDN3QUFBTVFQMC8vLy8vQUFRZzlEODJRUUFoL1A4NFFoYURCaEFSSUdYNC94YjZCUXo0REFRM3FBMllJb0NaRUlLZ0FaQklnMEJBZEJBUklDWDYveEFSSUNYei80Z2lEQnRBbUJHUXF3SE1GSUNyQWJIdC83Q1pFTEhzLzhBZ0FKSnJBSkhPLzhBZ0FLSnBBTUFnQUtnSlZuci9IQWtNR2tDYWc1QXp3SnFJT1VLSkloM3dBQUFza2dCQU5rRUFvcURBZ2YzLzRBZ0FIZkFBQURaQkFJS2d3SzBDaDVJUm9xRGJnZmYvNEFnQW9xRGNSZ1FBQUFBQWdxRGJoNUlJZ2ZMLzRBZ0FvcURkZ2ZELzRBZ0FIZkEyUVFBNk1zWUNBQUNpQWdBYkloQVJJS1g3L3plUzhSM3dBQUFBZk5vRlFOZ3VCa0NjMmdWQUhOc0ZRRFloSWFMUkVJSDYvK0FJQUVZTEFBQUFEQlJBUkJGQVEyUE5CTDBCclFLQjlmL2dDQUNnb0hUOFdzMEVFTEVnb3RFUWdmSC80QWdBU2lKQU04QldBLzBpb2dzUUlyQWdvaUN5MFJDQjdQL2dDQUN0QWh3TEVCRWdwZmYvTFFPR0FBQWlvR01kOEFBQS9HY0FRTkNTQUVBSWFBQkFOa0VoWXFFSHdHWVJHbVpaQml3S1l0RVFEQVZTWmhxQjkvL2dDQUFNR0VDSUVVZTRBa1pGQUswR2dkVC80QWdBaGpRQUFKS2tIVkJ6d09DWkVScVpRSGRqaVFuTkI3MEJJS0lnZ2MzLzRBZ0FrcVFkNEprUkdwbWdvSFNJQ1l5cURBaUNaaFo5Q0lZV0FBQUFrcVFkNEprUkVKbUFnbWtBRUJFZ0plci92UWV0QVJBUklLWHQveEFSSUNYcC84MEhFTEVnWUtZZ2didi80QWdBa3FRZDRKa1JHcG1JQ1hBaWdIQlZnRGUxc0pLaEI4Q1pFUnFabUFtQWRjQ1h0d0pHM1ArRzV2OE1DSUpHYktLa0d4Q3FvSUhLLytBSUFGWUsvN0tpQzZJR2JCQzdzQkFSSU9XV0FQZnFFdlpIRDdLaURSQzdzSHE3b2tzQUczZUc4Zjk4NjdlYXdXWkhDSUltR2plNEFvZTFuQ0tpQ3hBaXNHQzJJSzBDZ1p2LzRBZ0FFQkVncGQvL3JRSWNDeEFSSUNYai94QVJJS1hlL3l3S2diSC80QWdBSGZBSUlQUS9jT0w2UDBna0JrRHdJZ1pBTm1FQUVCRWc1Y3IvRUtFZ2dmdi80QWdBUFFvTUV2d3FpQUdTb2dDUWlCQ0pBUkFSSUtYUC81SHkvNkNpQWNBZ0FJSXBBS0NJSU1BZ0FJSnBBTEloQUtIdC80SHUvK0FJQUtBamd4M3dBQUQvRHdBQU5rRUFnVHYvREJtU1NBQXduRUdaS0pINy96a1lLVGd3TUxTYUlpb3pNRHhCREFJcFdEbElFQkVnSmZqL0xRcU1HaUtneFIzd0FBQlFMUVpBTmtFQVFTei9XRFJRTTJNV1l3UllGRnBUVUZ4QlJnRUFFQkVnWmNyL2lFU21HQVNJSkllbDd4QVJJS1hDL3hacS82Z1V6UU85QW9IeC8rQUlBS0NnZEl4S1VxREVVbVFGV0JRNlZWa1VXRFF3VmNCWk5CM3dBQURBL0Q5UFNFRkpxT3Y5UDNEZ0MwQVU0QXRBREFEMFB6aEE5RC8vL3dBQWpJQUFBQkJBQUFDczYvMC92T3Y5UDJDUTlELy9qLy8vWkpEMFAyaVE5RDlja1BRL0JNRDhQd2pBL0Q4RTdQMC9GQUQwUC9ELy93Q282LzAvRE1EOFB5UkEvVDk4YUFCQTdHY0FRRmlHQUVCc0tnWkFPRElHUUJRc0JrRE1MQVpBVEN3R1FEU0ZBRURNa0FCQWVDNEdRRER2QlVCWWtnQkFUSUlBUURiQkFDSFovd3dLSW1FSVFxQUFnZTcvNEFnQUlkVC9NZFgveGdBQVNRSkxJamN5K0JBUklDWEMvd3hMb3NFZ0VCRWdwY1gvSXFFQkVCRWc1Y0QvUVl6K2tDSVJLaVF4eXYreHl2L0FJQUJKQWlGei9nd01ERm95WWdDQjNQL2dDQUF4eGY5U29RSEFJQUFvQXl3S1VDSWd3Q0FBS1FPQkxQL2dDQUNCMWYvZ0NBQWh2di9BSUFBb0FzeTZITU13SWhBaXd2Z01FeUNqZ3d3TGdjNy80QWdBOGJmL0RCM0NvQUd5b0FIaW9RQkEzUkVBekJHQXV3R2lvQUNCeC8vZ0NBQWhzUDlSdi80cVJHTFZLOEFnQUNnRUZuTC93Q0FBT0FRTUJ3d1N3Q0FBZVFRaVFSQWlBd0VNS0NKQkVZSlJDWGxSSnBJSEhEZDNFaDNHQndBaUF3TnlBd0tBSWhGd0lpQm1RaEFvSThBZ0FDZ0NLVkVHQVFBY0lpSlJDUkFSSUdXeS93eUxvc0VRRUJFZ0piYi9nZ01ESWdNQ2dJZ1JJSWdnSVpQL0lDRDBoN0ljb3FEQUVCRWc1YkQvb3FEdUVCRWdaYkQvRUJFZzVhNy9SdHYvQUFBaUF3RWNOeWMzTlBZaUdFYnZBQUFBSXNJdklDQjA5a0p3Y1lUL2NDS2dLQUtnQWdBaXd2NGdJSFFjRnllM0FrYm1BSEYvLzNBaW9DZ0NvQUlBY3NJd2NIQjB0bGZKaHVBQUxFa01CeUtnd0pjWUFvYmVBSGxSREhLdEJ4QVJJS1dwLzYwSEVCRWdKYW4vRUJFZ3BhZi9FQkVnWmFmL0RJdWl3UkFpd3Y4UUVTQ2xxdjlXSXYxR0tBQU1FbFpvTTRKaEQ0RjYvK0FJQUlqeG9DaURSc2tBSm9nRkRCSkd4d0FBZUNNb015Q0hJSUNBdEZiSS9oQVJJQ1hHL3lwM25Cckc5LzhBb0t4QmdXNy80QWdBVmlyOUl0THdJS2ZBekNJR25BQUFvSUQwVmhqK2hnUUFvS0QxaWZHQlp2L2dDQUNJOFZiYStvQWl3QXdZQUlnUklLZkFKempoQmdRQUFBQ2dyRUdCWGYvZ0NBQlc2dmdpMHZBZ3A4QldvdjdHaWdBQURBY2lvTUFtaUFJR3FRQU1CeTBIUnFjQUpyajFCbjBBREJJbXVBSUdvUUM0TTZnakRBY1FFU0Rsb1ArZ0o0T0duQUFNR1dhNFhJaERJS2tSREFjaW9NS0h1Z0lHbWdDNFU2SWpBcEpoRGhBUklPVy8vNWpob0plRGhnMEFEQmxtdURHSVF5Q3BFUXdISXFEQ2g3b0NSbzhBS0RPNFU2Z2pJSGlDbWVFUUVTRGx2UDhoTC80TUNKamhpV0lpMGl0NUlxQ1lneTBKeG9JQWtTbitEQWVpQ1FBaW9NWjNtZ0pHZ1FCNEk0TEk4Q0tnd0llWEFTaFpEQWVTb085R0FnQjZvNklLR0J0M29Ka3doeWZ5Z2dNRmNnTUVnSWdSY0lnZ2NnTUdBSGNSZ0hjZ2dnTUhnSWdCY0lnZ2dKbkFncURCREFlUUtKUEdiUUNCRWY0aW9NYVNDQUI5Q1JhWkdwZzREQWNpb01oM0dRSUdad0FvV0pKSUFFWmlBQnlKREFjTUVwY1lBZ1ppQVBoejZHUFlVOGhEdURPb0k0RUovK0FJQUF3SWZRcWdLSU1HV3dBTUVpWklBa1pXQUpIeS9vSHkvc0FnQUhnSk1DSVJnSGNRSUhjZ3FDUEFJQUI1Q1pIdC9nd0x3Q0FBZUFtQWR4QWdkeURBSUFCNUNaSHAvc0FnQUhnSmdIY1FJSGNnd0NBQWVRbVI1ZjdBSUFCNENZQjNFQ0FuSU1BZ0FDa0pnZXorNEFnQUJpQUFBQUFBZ0pBMERBY2lvTUIzR1FJR1BRQ0FoRUdMczN6OHhnNEFxRHVKOFpuaHVjSEowWUhtL3VBSUFMakJpUEVvSzNnYnFBdVk0Y2pSY0hJUUpnSU53Q0FBMkFvZ0xERFFJaEFnZHlEQUlBQjVDaHVac3NzUWh6bkF4b0QvWmtnQ1JuLy9EQWNpb01DR0pnQU1FaWE0QXNZaEFDSEMvb2hUZUNPSkFpSEIvbmtDREFJR0hRQ3h2ZjRNQjlnTERCcUN5UENkQnkwSGdDcVQwSnFESUprUUlxREdkNWxnd2JmK2ZRbm9EQ0tneVljK1U0RHdGQ0tnd0ZhdkJDMEpoZ0lBQUNxVG1HbExJcGtIblFvZy9zQXFmWWN5N1JhcDJQa01lUXZHWVA4TUVtYUlHQ0duL29JaUFJd1lncURJREFkNUFpR2ovbmtDREJLQUo0TU1CMFlCQUFBTUJ5S2cveUNnZEJBUklDVnkvM0NnZEJBUklHVngveEFSSUNWdy8xYnl0eUlEQVJ3bkp6Y2Y5aklDUnR6K0lzTDlJQ0IwRFBjbnR3TEcyUDV4a3Y1d0lxQW9BcUFDQUFCeW9OSjNFazl5b05SM0VuY0cwdjZJTTZLaWNjQ3FFWGdqaWZHQmx2N2dDQUFoaC82UmlQN0FJQUFvQW9qeElEUTF3Q0lSa0NJUUlDTWdnQ0tDREFwd3NzS0JqZjdnQ0FDaW8raUJpdjdnQ0FER3dQNEFBTmhUeUVPNE02Z2pFQkVnWlhYL0JyeitBTElEQXlJREFvQzdFU0M3SUxMTDhLTERHQkFSSUtXUi93YTEvZ0FpQXdOeUF3S0FJaEZ3SWlCeGIvMGl3dkNJTjRBaVl4YVNxNGdYaW9LQWpFRkdBZ0NKOFJBUklLVmEvNGp4bUVlbUdRU1lKNWVvNnhBUklPVlMveFpxLzZnWHpRS3l3eGlCYlA3Z0NBQ01PaktneERsWE9CY3FNemtYT0RjZ0k4QXBONGFiL2lJREE0SURBbkxER0lBaUVUZzFnQ0lnSXNMd1ZzTUo5bElDaGlVQUlxREpSaW9BTVUvK2dVLzk2QU1wY2VDSXdJbGhpQ2F0Q1lleUFRdzZtZUdwMGVuQkVCRWdwVkwvcU5HQlJ2NnBBZWpCb1VYKzNRaTlCOExCSFBMQkdJbnhnVTcrNEFnQXVDYk5DcWh4bU9HZ3U4QzVKcUFpd0xnRHFuZW9ZWWp4cXJzTUNya0R3S21EZ0x2QW9OQjB6SnJpMjRDdERlQ3BneGJxQWEwSWlmR1o0Y25SRUJFZ3BZRC9pUEdZNGNqUmlRTkdBUUFBQUF3Y25ReU1zamcxakhQQVB6SEFNOENXcy9YV2ZBQWlvTWNwVlFabi9sYWNtU2cxRmtLWklxRElCdnYvcUNOV21waUJMZjdnQ0FDaW9uSEFxaEdCSnY3Z0NBQ0JLdjdnQ0FDR1cvNEFBQ2d6Rm5LV0RBcUJKUDdnQ0FDaW8raUJIdjdnQ0FEZ0FnQUdWUDRkOEFBQUFEWkJBSjBDZ3FEQUtBT0htUS9NTWd3U2hnY0FEQUlwQTN6aWhnOEFKaElISmlJWWhnTUFBQUNDb051QUtTT0htU29NSWlrRGZQSkdDQUFBQUNLZzNDZVpDZ3dTS1FNdENBWUVBQUFBZ3FEZGZQS0htUVlNRWlrRElxRGJIZkFBQUE9PSIsdGV4dF9zdGFydDoxMDc0NTIwMDY0LGRhdGE6IkRNRDhQK3puQzBCLzZBdEFaKzBMUUFicEMwQ2Y2QXRBQnVrTFFHWHBDMENDNmd0QTlPb0xRSjNxQzBDVjV3dEFHdW9MUUhUcUMwQ0k2UXRBR09zTFFMRHBDMEFZNnd0QWJlZ0xRTXJvQzBBRzZRdEFaZWtMUUlYb0MwREk2d3RBS2UwTFFMam1DMEJMN1F0QXVPWUxRTGptQzBDNDVndEF1T1lMUUxqbUMwQzQ1Z3RBdU9ZTFFMam1DMEJ2Nnd0QXVPWUxRRW5zQzBBcDdRdEEiLGRhdGFfc3RhcnQ6MTA3MzYwNTU0NCxic3Nfc3RhcnQ6MTA3MzUyODgzMn19KTt2YXIgeGk9bSgod0UsSm4pPT57Sm4uZXhwb3J0cz17ZW50cnk6MTA3NzQxMzMwNCx0ZXh0OiJBUkczQndCZ1RzYURxWWNBU3NnM1Njby9Kc3BTeEFiT0lzeTNCQUJnZlZvVENRa0F3RXdUZFBRL0RlRHlRR0pFSTZnMEFVSkowa1N5U1NKS0JXR0NnSWhBZ3ljSkFCTjE5UStDbDMwVTR4bEUvOG0vRXdjQURKUkJxb2RqR09VQWhVZUZ4aU9nQlFCNVZZS0FCVWRqaCtZQUNVWmpqY1lBZlZXQ2dFSUZFd2V3RFVHRlk1WG5Bb2xIbk1IMXQ1TUd3QTFqRnRVQW1NRVRCUUFNZ29DVEJ0QU5mVlZqbGRjQW1NRVRCYkFOZ29DM2Rjcy9RUkdUaFFXNkJzWmhQMk5GQlFhM2Q4cy9rNGVIc1FPbkJ3Z0Qxa2NJRTNYMUQ1TUdGZ0RDQnNHQ0k1TFhDREtYSXdDbkFBUFhSd2lSWjVPSEJ3UmpIdmNDTi9mS1B4TUhoN0doWjdxWEE2WUhDTGMyeXorM2Q4cy9rNGVIc1pPR2hyVmpIK1lBSTZiSENDT2cxd2dqa2djSUlhRDVWK01HOWZ5eVFFRUJnb0FqcHRjSUk2RG5DTjIzTnljQVlIeExuWXYxL3pjM0FHQjhTNTJMOWYrQ2dFRVJCc2JkTjdjbkFHQWpwZ2NDTndjQUNKakRtRU45LzhoWHNrQVRSZlgvQllsQkFZS0FRUkVHeHRrL2ZkMDNCd0JBdHljQVlKakROeWNBWUJ4RC9mK3lRRUVCZ29CQkVTTEVOOFRLUDVNSHhBQkt3QU9wQndFR3hpYkNZd29KQkVVM09jVzlSeE1FeEFDQlJHUFdKd0VFUkwySWs3UVVBSDAzaFQ4Y1JEY0dnQUFUbDhjQW1lQTNCZ0FCdC9iL0FIV1B0eVlBWU5qQ2tNS1lRbjMvUVVlUjRBVkhNd25wUUxxWEl5Z2tBUnpFc2tBaVJKSkVBa2xCQVlLQVFSRUd4aE1IQUF4akVPVUNFd1d3RFpjQXlQL25nSURqRXdYQURiSkFRUUVYQThqL1p3Q0Q0aE1Ic0EzakdPWCtsd0RJLytlQWdPRVRCZEFOeGJkQkVTTEVKc0lHeGlxRXN3UzFBR01YbEFDeVFDSkVra1JCQVlLQUEwVUVBQVVFUlRmdHR4TUZBQXdYQThqL1p3QUQzblZ4SnNQTzN2MTBoV245Y3BPRWhQcVRod2tISXNWS3dkTGMxdHFtbHdiSEZwR3poQ2NBS29rbWhTNkVsekRJLytlQWdKT1Rod2tIQldxS2w3T0tSMEVwNUFWbmZYVVRCSVg1a3djSEI2S1hNNFFuQUJNRmhmcVRCd2NIcXBlaWhUT0ZKd0NYTU1qLzU0Q0FrQ0tGd1VXNVB3RkZoV0lXa2JwQUtrU2FSQXBKOWxsbVd0WmFTV0dDZ0tLSlkzT0tBSVZwVG9iV2hVcUZsd0RJLytlQVFPSVRkZlVQQWUxT2h0YUZKb1dYTU1qLzU0REFpMDZaTXdRMFFWbTNFd1V3QmxXL2NYSDljazdQVXMxV3kxN0hCdGNpMVNiVFN0RmF5V0xGWnNOcXdlN2Vxb2tXa1JNRkFBSXVpcktLdG9zQ3dwY0F5UC9uZ0VCSWhXZGo3RmNSaFdSOWRCTUVoUHFUaHdRSG9wY3poQ2NBSW9XWE1Nai81NEFnaFgxN0V3dzcrWk1NaS9rVGh3UUhrNGNFQjJLWDVwY0JTVE1NSndDempDY0FFazFqZTAwSlkzR3BBM21nZlRXbWhZZ1lTVFZkTlNhR2pCZ2loWmN3eVAvbmdDQ0JwcGttbVdOMVNRT3pCNmxCWS9GM0E3TUVLa0ZqODVvQTFvUW1ob3dZVG9XWEFNai81NERnMHhOMTlROVYzUUxFZ1VSNVhZMU5vd0VCQUdLRmx3REkvK2VBWU1SOStRTkZNUURtaFMweFkwNEZBT1BpbmY2Rlo1T0hCd2VtbDRxWDJwY2ppcWY0aFFUNXQrTVdwZjJSUitPRzlQWUZaMzExa3djSEJ4TUVoZm1pbHpPRUp3QVRCWVg2a3djSEI2cVhNNFVuQUtLRmx5REkvK2VBZ0hmbE95S0Z3VVh4TThVN0V3VUFBcGNBeVAvbmdPQTJoV0lXa2JwUUtsU2FWQXBaK2tscVN0cEtTa3U2U3lwTW1rd0tUZlpkVFdHQ2dBRVJCczRpekZFeE53VE9QMndBRXdWRS81Y0F5UC9uZ0tES3FvY0ZSWlhuc2tlVDl3Y2dQc1o1T1RjbkFHQWNSN2NHUUFBVEJVVC8xWThjeDdKRmx3REkvK2VBSU1nek5hQUE4a0JpUkFWaGdvQkJFYmZIeWo4R3hwT0h4d0FGUnlPQTV3QVQxOFVBbU1jRlozMFh6TVBJeC9tTk9wV3FsYkdCak1zanFnY0FRVGNad1JNRlVBeXlRRUVCZ29BQkVTTE1OOFRLUDVNSHhBQW15c1JIVHNZR3prcklxb2tUQk1RQVkvT1ZBSzZFcWNBREtVUUFKcGtUV2NrQUhFaGpWZkFBSEVSalh2a0M0VDU5M1VoQUpvYk9oWmNBeVAvbmdDQzdFM1gxRHdIRmt3ZEFERnpJWEVDbWwxekFYRVNGajF6RThrQmlSTkpFUWtteVNRVmhnb0RkTm0yL3QxZEJTUmx4azRmM2hBRkZQczZHM3FMY3B0cksyTTdXMHRUVzB0clEzczdpek9iSzZzanV4cGNBeVAvbmdJQ3R0MGZLUHpkM3l6K1Rod2NBRXdlSHVtUGc1eFNsT1pGRmFBaXhNWVU1dC9mS1A1T0hoN0VoWno2WEl5RDNDTGNGT0VDM0J6aEFBVWFUaHdjTGs0VUZBRGRKeWo4VlJTTWcrUUNYQU1qLzU0RGdHemNIQUdCY1J4TUZBQUszeE1vL2srY1hFRnpIbHdESS8rZUFvQnEzUndCZ2lGK0JSYmQ1eXo5eGlXRVZFelVWQUpjQXlQL25nT0N3d1dmOUZ4TUhBQkNGWmtGbXR3VUFBUUZGazRURUFMZEt5ajhOYXBjQXlQL25nT0NyazRtSnNSTUpDUUFUaThvQUpwcURwOGtJOWQrRHE4a0loVWNqcGdrSUl3THhBb1BIR3dBSlJ5TVQ0UUtqQXZFQ0F0Uk5SMk9MNXdaUlIyT0o1d1lwUjJPZjV3Q0R4enNBQThjckFLSUgyWThSUjJPVzV3Q0RwNHNBbkVNKzFFRTJvVVZJRUpFK2c4YzdBQVBIS3dDaUI5bVBFV2RCQjJOKzl3SVRCYkFObHdESS8rZUFRSlFUQmNBTmx3REkvK2VBZ0pNVEJlQU9sd0RJLytlQXdKS0JOcjIzSTZBSEFKRUhiYjNKUnlNVDhRSjl0d1BIR3dEUlJtUG41Z0tGUm1QbTVnQUJUQk1FOEErZHFIa1hFM2YzRDhsRzQram0vcmQyeXo4S0I1T0d4cm8ybHhoREFvZVRCZ2NEay9iMkR4Rkc0Mm5XL0JNSDl3SVRkL2NQalVaajd1WUl0M2JMUHdvSGs0YUd2emFYR0VNQ2h4TUhRQUpqbXVjUUF0UWRSQUZGbHdESS8rZUFJSW9CUllFOFRUeEZQS0ZGU0JCOUZFazBmZkFCVEFGRUUzWDBEeVU4RTNYOER3MDhVVHpqRVFUc2c4Y2JBRWxIWTJYM01BbEg0M24zNnZVWGsvZjNEejFINDJQMzZqZDN5eitLQnhNSGg4QzZsNXhEZ29jRlJKM3JjQkNCUlFGRmx3REkvK2VBUUlrZDRkRkZhQkFWTkFGRU1hZ0ZSSUh2bHdESS8rZUF3STB6TktBQUthQWhSMk9GNXdBRlJBRk1ZYmNEcklzQUE2VExBTE5uakFEU0IvWDNtVGxsOWNGc0lwejlISDE5TXdXTVFGM2NzM2VWQVpYandXd3pCWXhBWSthTUF2MThNd1dNUUYzUU1ZR1hBTWovNTRCZ2lsMzVacFQxdHpHQmx3REkvK2VBWUlsZDhXcVUwYmRCZ1pjQXlQL25nS0NJV2ZrekJKUkJ3YmNoUitPSzUvQUJUQk1FQUF3NXQwRkh6YjlCUndWRTQ1M245b09seXdBRHBZc0FWVEs1djBGSEJVVGprK2YyQTZjTEFaRm5ZK2puSG9PbFN3RURwWXNBTVRHQnQwRkhCVVRqbE9mMGc2Y0xBUkZuWTJuM0hBT255d0NEcFVzQkE2V0xBRE9FNXdMZE5pT3NCQUFqSklxd0NiOER4d1FBWXdNSEZBT25pd0RCRnhNRUFBeGpFL2NBd0VnQlI1TUc4QTVqUnZjQ2c4ZGJBQVBIU3dBQlRLSUgyWThEeDJzQVFnZGRqNFBIZXdEaUI5bVA0NFQyNWhNRUVBeUZ0VE9HNndBRFJvWUJCUWV4anVHM2c4Y0VBUDNIM0VSam5RY1V3RWdqZ0FRQVZiMWhSMk9XNXdLRHA4c0JBNmVMQVlPbVN3RURwZ3NCZzZYTEFBT2xpd0NYOE1mLzU0QmdlU3FNTXpTZ0FBRzlBVXdGUkNtMUVVY0ZST09kNSthM2x3Qmd0RU5sZDMwWEJXYjVqdEdPQTZXTEFMVER0RWVCUmZtTzBZNjB4L1JEK1k3Ump2VEQxRjkxajFHUDJOK1g4TWYvNTRCQWR3VzFFL2YzQU9NWEIrcVQzRWNBRTRTTEFBRk1mVjNqZDV6YlNFU1g4TWYvNTREQVlSaEVWRUFRUVBtT1l3ZW5BUnhDRTBmMy8zMlAyWTRVd2dVTVFRVFp2eEZIdGJWQlJ3VkU0NXJuM29Pbml3QURwMHNCSXlUNUFDTWk2UURKczRNbFNRREJGNUhsaWM4QlRCTUVZQXlodXdNbmlRQmpadmNHRS9jM0FPTWJCK0lES0lrQUFVWUJSek1GNkVDemh1VUFZMm4zQU9NSEJ0SWpKS2tBSXlMWkFBMnpNNGJyQUJCT0VRZVF3Z1ZHNmI4aFJ3VkU0NVRuMkFNa2lRQVp3Qk1FZ0F3akpBa0FJeUlKQURNMGdBQzlzd0ZNRXdRZ0RNVzVBVXdUQklBTTViRUJUQk1Fa0F6RnNSTUhJQTFqZytjTUV3ZEFEZU9SNTdvRHhEc0FnOGNyQUNJRVhZeVg4TWYvNTRCZ1h3T3N4QUJCRkdOemhBRWlqT01QRExiQVFHS1VNWUNjU0dOVjhBQ2NSR05hOUFydjhJL2hkZDNJUUdLR2s0V0xBWmZ3eC8vbmdHQmJBY1dUQjBBTTNNamNRT0tYM01EY1JMT0hoMEhjeEpmd3gvL25nRUJhRmI0SlpSTUZCWEVEck1zQUE2U0xBSmZ3eC8vbmdFQk10d2NBWU5oTHR3WUFBY0VXazFkSEFSSUhkWSs5aTltUHM0ZUhBd0ZGczlXSEFwZnd4Ly9uZ09CTUV3V0FQcGZ3eC8vbmdPQkkzYlNEcGtzQkE2WUxBWU9seXdBRHBZc0E3L0F2OThHOGc4VTdBSVBIS3dBVGhZc0JvZ1hkamNFVnFUcHR2Ty93NzlxQnR3UEVPd0NEeHlzQUU0eUxBU0lFWFl6Y1JFRVV4ZU9SUjRWTFkvNkhDSk1Ia0F6Y3lIbTBBNmNOQUNMUUJVaXpoK3hBUHRhREo0cXdZM1AwQUExSVFzWTZ4Ty93YjlZaVJ6SklOOFhLUCtLRmZCQ1Roc29BRUJBVEJVVUNsL0RILytlQTRFazM5OG8va3dqSEFJSlhBNmVJc0lPbERRQWRqQjJQUHB5eVZ5T2s2TENxaTc2Vkk2QzlBSk9IeWdDZGpRSEZvV2RqbHZVQVdvVmRPQ09nYlFFSnhOeEVtY1BqUUhENVk5OExBSk1IY0F5RnY0Vkx0MzNMUDdmTXlqK1RqWTI2azR6TUFPbS80NVVMbnR4RTQ0SUhucE1IZ0F5eHQ0T25pd0RqbXdlY0FVV1g4TWYvNTREQU9RbGxFd1VGY1pmd3gvL25nQ0EybC9ESC8rZUE0RGxOdWdPa3l3RGpCZ1NhQVVXWDhNZi81NEFnTnhNRmdENlg4TWYvNTRDZ013S1VRYnIyVUdaVTFsUkdXYlpaSmxxV1dnWmI5a3RtVE5aTVJrMjJUUWxoZ29BPSIsdGV4dF9zdGFydDoxMDc3NDExODQwLGRhdGE6IkRFREtQK0FJT0VBc0NUaEFoQWs0UUZJS09FQytDamhBYkFvNFFLZ0hPRUFPQ2poQVRnbzRRSmdKT0VCWUJ6aEF6QWs0UUZnSE9FQzZDRGhBL2dnNFFDd0pPRUNFQ1RoQXpBZzRRQklJT0VCQ0NEaEF5QWc0UUJZTk9FQXNDVGhBMWdzNFFNb01PRUNrQmpoQTlBdzRRS1FHT0VDa0JqaEFwQVk0UUtRR09FQ2tCamhBcEFZNFFLUUdPRUNrQmpoQWNnczRRS1FHT0VEeUN6aEF5Z3c0UUE9PSIsZGF0YV9zdGFydDoxMDcwMjk1OTc2LGJzc19zdGFydDoxMDcwMjE5MjY0fX0pO3ZhciBRaT1tKChfRSx2bik9Pnt2bi5leHBvcnRzPXtlbnRyeToxMDc3NDEzNTg0LHRleHQ6IlFSRWl4Q2JDQnNhM053UmdFVWMzUk1nLzJNdTNOQVJnRXdRRUFOeEFrWXVSNTdKQUlrU1NSRUVCZ29DSVFCeEFFM1gxRDRLWDNiY0JFYmNIQUdCT3hvT3Bod0JLeURkSnlEOG15bExFQnM0aXpMY0VBR0I5V2hNSkNRREFUQk4wOUQ4TjRQSkFZa1FqcURRQlFrblNSTEpKSWtvRllZS0FpRUNESndrQUUzWDFENEtYZlJUakdVVC95YjhUQndBTWxFR3FoMk1ZNVFDRlI0WEdJNkFGQUhsVmdvQUZSMk9INWdBSlJtT054Z0I5VllLQVFnVVRCN0FOUVlWamxlY0NpVWVjd2ZXM2t3YkFEV01XMVFDWXdSTUZBQXlDZ0pNRzBBMTlWV09WMXdDWXdSTUZzQTJDZ0xkMXlUOUJFWk9GeGJvR3htRS9ZMFVGQnJkM3lUK1RoMGV5QTZjSENBUFdSd2dUZGZVUGt3WVdBTUlHd1lJamt0Y0lNcGNqQUtjQUE5ZEhDSkZuazRjSEJHTWU5d0kzOThnL0V3ZEhzcUZudXBjRHBnY0l0emJKUDdkM3lUK1RoMGV5azRaR3RtTWY1Z0FqcHNjSUk2RFhDQ09TQndnaG9QbFg0d2IxL0xKQVFRR0NnQ09tMXdnam9PY0kzYmMzSndCZ2ZFdWRpL1gvTnpjQVlIeExuWXYxLzRLQVFSRUd4dDAzdHljQVlDT21Cd0kzQndBSW1NT1lRMzMveUZleVFCTkY5ZjhGaVVFQmdvQkJFUWJHMlQ5OTNUY0hBRUMzSndCZ21NTTNKd0JnSEVQOS83SkFRUUdDZ0VFUklzUTN4TWcva3dlRUFVckFBNmtIQVFiR0pzSmpDZ2tFUlRjNXhiMUhFd1NFQVlGRVk5WW5BUVJFdllpVHRCUUFmVGVGUHh4RU53YUFBQk9YeHdDWjREY0dBQUczOXY4QWRZKzNKZ0JnMk1LUXdwaENmZjlCUjVIZ0JVY3pDZWxBdXBjaktDUUJITVN5UUNKRWtrUUNTVUVCZ29BQkVRYk9Jc3dsTnpjRXpqOXNBQk1GUlArWEFNai81NEFnOEtxSEJVV1Y1N0pIay9jSElEN0dpVGMzSndCZ0hFZTNCa0FBRXdWRS85V1BITWV5UlpjQXlQL25nS0R0TXpXZ0FQSkFZa1FGWVlLQVFSRzN4OGcvQnNhVGg0Y0JCVWNqZ09jQUU5ZkZBSmpIQldkOUY4ekR5TWY1alRxVnFwV3hnWXpMSTZvSEFFRTNHY0VUQlZBTXNrQkJBWUtBQVJFaXpEZkV5RCtUQjRRQkpzckVSMDdHQnM1S3lLcUpFd1NFQVdQemxRQ3VoS25BQXlsRUFDYVpFMW5KQUJ4SVkxWHdBQnhFWTE3NUFyVTlmZDFJUUNhR3pvV1hBTWovNTRBZzRSTjE5UThCeFpNSFFBeGN5RnhBcHBkY3dGeEVoWTljeFBKQVlrVFNSRUpKc2trRllZS0FhVFZ0djBFUkJzYVhBTWovNTRBQTFnTkZoUUd5UUhVVkV6VVZBRUVCZ29CQkVRYkd4VGNkeVRkSHlEOFRCd2NBWEVPTnh4QkhIY0szQmd4Z21FWU5pbkdiVVkrWXhnVm11RTRUQmdiQThZOTlkaE1HOWo5eGo5bVB2TTZ5UUVFQmdvQkJFUWJHZVQ4UndRMUZza0JCQVJjRHlQOW5BSVBNUVJFR3hpYkNJc1NxaEpjQXlQL25nT0RKclQ4TnlUZEh5RCtUQmdjQWc5ZkdBQk1FQndDRkI4SUh3WU1qbHZZQWt3WUFER09HMUFBVEIrQURZM1gzQUcwM0l4WUVBTEpBSWtTU1JFRUJnb0JCRVFiR0V3Y0FER01hNVFBVEJiQU5SVGNUQmNBTnNrQkJBVm0vRXdld0RlTWI1ZjV4TnhNRjBBMzF0MEVSSXNRbXdnYkdLb1N6QkxVQVl4ZVVBTEpBSWtTU1JFRUJnb0FEUlFRQUJRUk5QKzIzTlhFbXkwN0gvWEtGYWYxMElzMUt5VkxGVnNNR3o1T0VoUG9Xa1pPSENRZW1seGdJczRUbkFDcUpKb1V1aEpjQXlQL25nRUFZazRjSkJ4Z0lCV3E2bDdPS1IwRXg1QVZuZlhXVEJZWDZrd2NIQnhNRmhma1VDS3FYTTRYWEFKTUhCd2V1bDdPRjF3QXF4cGNBeVAvbmdBQVZNa1hCUlpVM0FVV0ZZaGFSK2tCcVJOcEVTa202U1NwS21rb05ZWUtBb29samM0b0FoV2xPaHRhRlNvV1hBTWovNTRBQXd4TjE5UThCN1U2RzFvVW1oWmNBeVAvbmdFQVFUcGt6QkRSQlViY1RCVEFHVmI4VEJRQU1TYjB4Y2YxeUJXZE8xMUxWVnROZXp3YmZJdDBtMjByWld0Rml6V2JMYXNsdXgvMTNGcEVUQndjSFBwY2NDTHFYUHNZanFnZjRxb2t1aXJLS3RvdkZNNU1IQUFJWndiY0hBZ0EraFpjQXlQL25nT0FJaFdkajVWY1RCV1I5ZVJNSmlmcVRCd1FIeXBjWUNET0o1d0JLaFpjQXlQL25nR0FIZlhzVEREdjVrd3lMK1JNSEJBZVRCd1FIRkFoaWwrYVhnVVF6RE5jQXM0elhBRkpOWTN4TkNXUHhwQU5CcUprL29vVUlBWTAxdVRjaWhnd0JTb1dYQU1qLzU0QkFBNktab3BSajlVUURzNGVrUVdQeGR3TXpCSnBBWS9PS0FGYUVJb1lNQVU2Rmx3REkvK2VBUUxJVGRmVVBWZDBDekFGRWVWMk5UYU1KQVFCaWhaY0F5UC9uZ0lDa2Zma0RSVEVCNW9XUlBHTlBCUURqNG8zK2hXZVRod2NIb3BjWUNMcVgycGNqaXFmNEJRVHh0K01WcGYyUlIrTUY5UFlGWjMxMWt3Y0hCNU1GaGZvVEJZWDVGQWlxbHpPRjF3Q1RCd2NIcnBlemhkY0FLc2FYQU1qLzU0QmcrWEU5TWtYQlJXVXpVVDFWT2JjSEFnQVo0Wk1IQUFJK2haY0F5UC9uZ0dEMmhXSVdrZnBRYWxUYVZFcFp1bGtxV3BwYUNsdjZTMnBNMmt4S1RicE5LV0dDZ0xkWFFVa1pjWk9IOTRRQlJZYmVvdHltMnNyWXp0YlMxTmJTMnREZXp1TE01c3JxeU83R1BzNlhBTWovNTRCQW5MRXhEYzIzQkF4Z25FUTNSTWcvRXdRRUFCekV2RXg5ZHhNSDl6OWN3UG1QaytjSFFMek1Fd1ZBQnBjQXlQL25nR0NTSEVUeG01UG5Gd0NjeEFFNUljRzNod0JnTjBmWVVKT0dod29UQnhlcW1NSVRod2NKSXlBSEFEYzNIWThqb0FZQUV3ZW5FcE9HQnd1WXdwT0h4d3FZUXpjR0FJQlJqNWpESTZBR0FMZEh5RDgzZDhrL2s0Y0hBQk1IUjdzaG9DT2dCd0NSQitQdDUvNUJPNUZGYUFoeE9XRXp0L2ZJUDVPSFI3SWhaejZYSXlEM0NMY0hPRUEzU2NnL2s0ZUhEaU1nK1FDM2Vjay9VVFlUQ1FrQWs0bEpzbU1KQlJDM0p3eGdSVWU0MTRWRlJVV1hBTWovNTREZzM3Y0ZPRUFCUnBPRkJRQkZSWmNBeVAvbmdPRGd0emNFWUJGSG1NczNCUUlBbHdESS8rZUFJT0NYQU1qLzU0Q2c4TGRIQUdDY1h3bmw4WXZoRnhPMUZ3Q0JSWmNBeVAvbmdJQ1R3V2UzeE1nLy9SY1RCd0FRaFdaQlpyY0ZBQUVCUlpPRWhBRzNTc2cvRFdxWEFNai81NEFBamhPTGlnRW1tb09ueVFqMTM0T3J5UWlGUnlPbUNRZ2pBdkVDZzhjYkFBbEhJeFBoQXFNQzhRSUMxRTFIWTRIbkNGRkhZNC9uQmlsSFk1L25BSVBIT3dBRHh5c0FvZ2ZaanhGSFk1Ym5BSU9uaXdDY1F6N1VwVG1oUlVnUVVUYUR4enNBQThjckFLSUgyWThSWjBFSFkzVDNCQk1Gc0EzOU5CTUZ3QTNsTkJNRjRBN05OS2t4UWJlM0JUaEFBVWFUaFlVREZVV1hBTWovNTRCQTBUY0hBR0JjUnhNRkFBS1Q1eGNRWE1jSnQ4bEhJeFB4QWsyM0E4Y2JBTkZHWStmbUFvVkdZK2JtQUFGTUV3VHdENFdvZVJjVGQvY1B5VWJqNk9iK3QzYkpQd29IazRhR3V6YVhHRU1DaDVNR0J3T1Q5dllQRVViamFkYjhFd2YzQWhOMzl3K05SbVBvNWdxM2Rzay9DZ2VUaGtiQU5wY1lRd0tIRXdkQUFtT1Y1eElDMUIxRUFVV0JOQUZGY1RSVk5rMDJvVVZJRUgwVWRUUjE5QUZNQVVRVGRmUVBsVHdUZGZ3UHZUUlpOdU1lQk9xRHh4c0FTVWRqWmZjeUNVZmpkdmZxOVJlVDkvY1BQVWZqWVBmcU4zZkpQNG9IRXdkSHdicVhuRU9DaHdWRW9ldTNCd0JBQTZkSEFabEhjQkNCUlFGRlkvM25BSmZRelAvbmdBQ3pCVVFGNmRGRmFCQTlQQUZFSGFDWHNNei81NEJnL2UyM0JVU0I3NWZ3eC8vbmdPQndNelNnQUNtZ0lVZGpoZWNBQlVRQlRMMjNBNnlMQUFPa3l3Q3paNHdBMGdmMTkrL3czNEI5OGNGc0lwejlISDE5TXdXTVFFM1lzM2VWQVpYandXd3pCWXhBWSthTUF2MThNd1dNUUVuY01ZR1g4TWYvNTREZ2ExWDVacFQxdHpHQmwvREgvK2VBNEdwVjhXcVUwYmRCZ1pmd3gvL25nS0JwVWZrekJKUkJ3YmNoUitPTTUrNEJUQk1FQUF6TnZVRkh6YjlCUndWRTQ1em45b09seXdBRHBZc0FYVEt4djBGSEJVVGprdWYyQTZjTEFaRm5ZK3JuSG9PbFN3RURwWXNBNy9BUC9EVy9RVWNGUk9PUzUvU0Rwd3NCRVdkamF2Y2NBNmZMQUlPbFN3RURwWXNBTTRUbkF1L3dqL2tqckFRQUl5U0tzREczQThjRUFHTURCeFFEcDRzQXdSY1RCQUFNWXhQM0FNQklBVWVUQnZBT1kwYjNBb1BIV3dBRHgwc0FBVXlpQjltUEE4ZHJBRUlIWFkrRHgzc0E0Z2ZaaitPRTl1UVRCQkFNZ2JVemh1c0FBMGFHQVFVSHNZN2h0NFBIQkFEOXg5eEVZNTBIRk1CSUk0QUVBSDIxWVVkamx1Y0NnNmZMQVFPbml3R0Rwa3NCQTZZTEFZT2x5d0FEcFlzQWwvREgvK2VBb0ZrcWpETTBvQURGdXdGTUJVVHRzeEZIQlVUam11Zm10NWNBWUxSRFpYZDlGd1ZtK1k3UmpnT2xpd0MwdzdSSGdVWDVqdEdPdE1mMFEvbU8wWTcwdzlSZmRZOVJqOWpmbC9ESC8rZUF3RmNCdlJQMzl3RGpGUWZxazl4SEFCT0Vpd0FCVEgxZDQzZWMyVWhFbC9ESC8rZUFRRVFZUkZSQUVFRDVqbU1IcHdFY1FoTkg5Lzk5ajltT0ZNSUZERUVFMmI4UlI2VzFRVWNGUk9PWDU5NkRwNHNBQTZkTEFTTXErUUFqS09rQVRidURKUWtCd1JlUjVZblBBVXdUQkdBTUpic0RKMGtCWTJiM0JoUDNOd0RqR1FmaUF5aEpBUUZHQVVjekJlaEFzNGJsQUdOcDl3RGpCd2JRSXlxcEFDTW8yUUFKc3pPRzZ3QVFUaEVIa01JRlJ1bS9JVWNGUk9PUjU5Z0RKRWtCR2NBVEJJQU1JeW9KQUNNb0NRQXpOSUFBcGJNQlRCTUVJQXpCdVFGTUV3U0FET0d4QVV3VEJKQU13YkVUQnlBTlk0UG5EQk1IUUEzam51ZTJBOFE3QUlQSEt3QWlCRjJNbC9ESC8rZUFJRUlEck1RQVFSUmpjNFFCSW96akRBeTB3RUJpbERHQW5FaGpWZkFBbkVSalcvUUs3L0RQeG5YZHlFQmlocE9GaXdHWDhNZi81NEFnUGdIRmt3ZEFETnpJM0VEaWw5ekEzRVN6aDRkQjNNU1g4TWYvNTRBQVBUbTJDV1VUQlFWeEE2ekxBQU9raXdDWDhNZi81NERBTHJjSEFHRFlTN2NHQUFIQkZwTlhSd0VTQjNXUHZZdlpqN09IaHdNQlJiUFZod0tYOE1mLzU0Q2dMeE1GZ0Q2WDhNZi81NEJnSzhHMGc2WkxBUU9tQ3dHRHBjc0FBNldMQU8vd3ovZHR0SVBGT3dDRHh5c0FFNFdMQWFJRjNZM0JGZS93cjlCSnZPL3dEOEE5dndQRU93Q0R4eXNBRTR5TEFTSUVYWXpjUkVFVXplT1JSNFZMWS8rSENKTUhrQXpjeUoyMEE2Y05BQ0xRQlVpemgreEFQdGFESjRxd1kzUDBBQTFJUXNZNnhPL3dqN3NpUnpKSU44WElQK0tGZkJDVGhvb0JFQkFUQlFVRGwvREgvK2VBQUN3Mzk4Zy9rd2lIQVlKWEE2ZUlzSU9sRFFBZGpCMlBQcHl5VnlPazZMQ3FpNzZWSTZDOUFKT0hpZ0dkalFIRm9XZGpsL1VBV29YdjhFL0dJNkJ0QVFuRTNFU1p3K05QY1BkajN3c0Frd2R3REwyM2hVdTNmY2svdDh6SVA1T05UYnVUakl3QjZiL2prQXVjM0VUampRZWFrd2VBREttM2c2ZUxBT09XQjVydjhBL1BDV1VUQlFWeGwvREgvK2VBd0JqdjhNL0psL0RILytlQUFCeHBzZ09reXdEakFnU1k3L0NQekJNRmdENlg4TWYvNTRCZ0Z1L3diOGNDbEsyeTcvRHZ4dlpRWmxUV1ZFWlp0bGttV3BaYUJsdjJTMlpNMWt4R1RiWk5DV0dDZ0E9PSIsdGV4dF9zdGFydDoxMDc3NDExODQwLGRhdGE6IkdFRElQOEFLT0VBUUN6aEFhQXM0UURZTU9FQ2lERGhBVUF3NFFISUpPRUR5Q3poQU1ndzRRSHdMT0VBaUNUaEFzQXM0UUNJSk9FQ2FDamhBNEFvNFFCQUxPRUJvQ3poQXJBbzRRTllKT0VBZ0NqaEFxQW80UVBvT09FQVFDemhBdWcwNFFMSU9PRUJpQ0RoQTJnNDRRR0lJT0VCaUNEaEFZZ2c0UUdJSU9FQmlDRGhBWWdnNFFHSUlPRUJpQ0RoQVZnMDRRR0lJT0VEWURUaEFzZzQ0UUE9PSIsZGF0YV9zdGFydDoxMDcwMTY0OTE2LGJzc19zdGFydDoxMDcwMDg4MTkyfX0pO3ZhciB1aT1tKChmRSxXbik9PntXbi5leHBvcnRzPXtlbnRyeToxMDgyMTMyMTY0LHRleHQ6IlFSRWl4Q2JDQnNhMzl3QmdFVWMzQklSQTJNdTM5QUJnRXdRRUFOeEFrWXVSNTdKQUlrU1NSRUVCZ29DSVFCeEFFM1gxRDRLWDNiY0JFYmNIQUdCT3hvT3Bod0JLeURjSmhFQW15bExFQnM0aXpMY0VBR0I5V2hNSkNRREFUQk4wOUQ4TjRQSkFZa1FqcURRQlFrblNSTEpKSWtvRllZS0FpRUNESndrQUUzWDFENEtYZlJUakdVVC95YjhUQndBTWxFR3FoMk1ZNVFDRlI0WEdJNkFGQUhsVmdvQUZSMk9INWdBSlJtT054Z0I5VllLQVFnVVRCN0FOUVlWamxlY0NpVWVjd2ZXM2t3YkFEV01XMVFDWXdSTUZBQXlDZ0pNRzBBMTlWV09WMXdDWXdSTUZzQTJDZ0xjMWhVQkJFWk9GaGJvR3htRS9ZMFVGQnJjM2hVQ1Rod2V5QTZjSENBUFdSd2dUZGZVUGt3WVdBTUlHd1lJamt0Y0lNcGNqQUtjQUE5ZEhDSkZuazRjSEJHTWU5d0kzdDRSQUV3Y0hzcUZudXBjRHBnY0l0L2FFUUxjM2hVQ1Rod2V5azRZR3RtTWY1Z0FqcHNjSUk2RFhDQ09TQndnaG9QbFg0d2IxL0xKQVFRR0NnQ09tMXdnam9PY0kzYmMzTndCZ2ZFdWRpL1gvTnljQVlIeExuWXYxLzRLQVFSRUd4dDAzdHpjQVlDT21Cd0kzQndBSW1NT1lRMzMveUZleVFCTkY5ZjhGaVVFQmdvQkJFUWJHMlQ5OTNUY0hBRUMzTndCZ21NTTNOd0JnSEVQOS83SkFRUUdDZ0VFUklzUTNoSVJBa3dkRUFVckFBNmtIQVFiR0pzSmpDZ2tFUlRjNXhiMUhFd1JFQVlGRVk5WW5BUVJFdllpVHRCUUFmVGVGUHh4RU53YUFBQk9YeHdDWjREY0dBQUczOXY4QWRZKzNOZ0JnMk1LUXdwaENmZjlCUjVIZ0JVY3pDZWxBdXBjaktDUUJITVN5UUNKRWtrUUNTVUVCZ29BQkVRYk9Jc3dsTnpjRWhrQnNBQk1GQlArWEFJRC81NENnODZxSEJVV1Y1N0pIay9jSElEN0dpVGMzTndCZ0hFZTNCa0FBRXdVRS85V1BITWV5UlpjQWdQL25nQ0R4TXpXZ0FQSkFZa1FGWVlLQVFSRzNoNFJBQnNhVGgwY0JCVWNqZ09jQUU5ZkZBSmpIQldkOUY4ekR5TWY1alRxVnFwV3hnWXpMSTZvSEFFRTNHY0VUQlZBTXNrQkJBWUtBQVJFaXpEZUVoRUNUQjBRQkpzckVSMDdHQnM1S3lLcUpFd1JFQVdQemxRQ3VoS25BQXlsRUFDYVpFMW5KQUJ4SVkxWHdBQnhFWTE3NUFyVTlmZDFJUUNhR3pvV1hBSUQvNTRBZzVCTjE5UThCeFpNSFFBeGN5RnhBcHBkY3dGeEVoWTljeFBKQVlrVFNSRUpKc2trRllZS0FhVFZ0djBFUkJzYVhBSUQvNTRDQTFnTkZoUUd5UUhVVkV6VVZBRUVCZ29CQkVRYkd4VGNOeGJjSGhFQ1Rod2NBMUVPWnpqZG5DV0FUQjhjUUhFTTNCdjMvZlJieGp6Y0dBd0R4anRXUEhNT3lRRUVCZ29CQkVRYkdiVGNSd1ExRnNrQkJBUmNEZ1A5bkFJUE1RUkVHeGliQ0lzU3FoSmNBZ1AvbmdLREpXVGNOeVRjSGhFQ1RCZ2NBZzllR0FCTUVCd0NGQjhJSHdZTWpsUFlBa3dZQURHT0cxQUFUQitBRFkzWDNBRzAzSXhRRUFMSkFJa1NTUkVFQmdvQkJFUWJHRXdjQURHTWE1UUFUQmJBTlJUY1RCY0FOc2tCQkFWbS9Fd2V3RGVNYjVmNXhOeE1GMEEzMXQwRVJJc1Ftd2diR0tvU3pCTFVBWXhlVUFMSkFJa1NTUkVFQmdvQURSUVFBQlFSTlArMjNOWEVteTA3SC9YS0ZhZjEwSXMxS3lWTEZWc01HejVPRWhQb1drWk9IQ1FlbWx4Z0lzNFRuQUNxSkpvVXVoSmNBZ1AvbmdFQXhrNGNKQnhnSUJXcTZsN09LUjBFeDVBVm5mWFdUQllYNmt3Y0hCeE1GaGZrVUNLcVhNNFhYQUpNSEJ3ZXVsN09GMXdBcXhwY0FnUC9uZ0FBdU1rWEJSWlUzQVVXRlloYVIra0JxUk5wRVNrbTZTU3BLbWtvTllZS0Fvb2xqYzRvQWhXbE9odGFGU29XWEFJRC81NERBeGhOMTlROEI3VTZHMW9VbWhaY0FnUC9uZ0VBcFRwa3pCRFJCVWJjVEJUQUdWYjhUQlFBTVNiMHhjZjF5QldkTzExTFZWdE5lendiZkl0MG0yMHJaV3RGaXpXYkxhc2x1eC8xM0ZwRVRCd2NIUHBjY0NMcVhQc1lqcWdmNHFva3VpcktLdG92MU01TUhBQUlad2JjSEFnQStoWmNBZ1AvbmdDQWdoV2RqNVZjVEJXUjllUk1KaWZxVEJ3UUh5cGNZQ0RPSjV3QktoWmNBZ1AvbmdHQWdmWHNURER2NWt3eUwrUk1IQkFlVEJ3UUhGQWhpbCthWGdVUXpETmNBczR6WEFGSk5ZM3hOQ1dQeHBBTkJxSmsvb29VSUFZMDF1VGNpaGd3QlNvV1hBSUQvNTRCQUhLS1pvcFJqOVVRRHM0ZWtRV1B4ZHdNekJKcEFZL09LQUZhRUlvWU1BVTZGbHdDQS8rZUFBTFlUZGZVUFZkMEN6QUZFZVYyTlRhTUpBUUJpaFpjQWdQL25nRUNrZmZrRFJURUI1b1dGTkdOUEJRRGo0bzMraFdlVGh3Y0hvcGNZQ0xxWDJwY2ppcWY0QlFUeHQrTVZwZjJSUitNRjlQWUZaMzExa3djSEI1TUZoZm9UQllYNUZBaXFsek9GMXdDVEJ3Y0hycGV6aGRjQUtzYVhBSUQvNTRCZ0VuRTlNa1hCUldVelVUM0JNYmNIQWdBWjRaTUhBQUkraFpjQWdQL25nS0FOaFdJV2tmcFFhbFRhVkVwWnVsa3FXcHBhQ2x2NlMycE0ya3hLVGJwTktXR0NnTGRYUVVrWmNaT0g5NFFCUlliZW90eW0yc3JZenRiUzFOYlMydERlenVMTTVzcnF5TzdHUHM2WEFJRC81NERBbmFFNUVjMjNad2xnazRmSEVKaER0d2FFUUNPaTVnQzNCZ01BVlkrWXd5MDVCYzIzSnd0Z04wZllVSk9HaDhFVEJ4ZXFtTUlUaGdmQUl5QUdBQ09nQmdDVGhnZkNtTUtUaDhmQm1FTTNCZ1FBVVkrWXd5T2dCZ0MzQjRSQU56ZUZRSk9IQndBVEJ3ZTdJYUFqb0FjQWtRZmo3ZWYrWFR1UlJXZ0l5VEY5TTdlM2hFQ1Rod2V5SVdjK2x5TWc5d2kzQjRCQU53bUVRSk9IaHc0aklQa0F0em1GUUYwK0V3a0pBSk9KQ2JKakJnVVF0d2NCWUJNSEVBSWpxT2NNaFVWRlJaY0FnUC9uZ0FENXR3V0FRQUZHazRVRkFFVkZsd0NBLytlQVFQcTM5d0JnRVVlWXl6Y0ZBZ0NYQUlELzU0Q0ErYmNYQ1dDSVg0RkZ0NFNFUUhHSllSVVROUlVBbHdDQS8rZUFnSi9CWi8wWEV3Y0FFSVZtUVdhM0JRQUJBVVdUaEVRQnR3cUVRQTFxbHdDQS8rZUFRSlVUaTBvQkpwcURwOGtJOWQrRHE4a0loVWNqcGdrSUl3THhBb1BIR3dBSlJ5TVQ0UUtqQXZFQ0F0Uk5SMk9CNXdoUlIyT1A1d1lwUjJPZjV3Q0R4enNBQThjckFLSUgyWThSUjJPVzV3Q0RwNHNBbkVNKzFGVXhvVVZJRUVVK2c4YzdBQVBIS3dDaUI5bVBFV2RCQjJOMDl3UVRCYkFOS1Q0VEJjQU5FVDRUQmVBT09UYWRPVUczdHdXQVFBRkdrNFdGQXhWRmx3Q0EvK2VBUU9zM0J3QmdYRWNUQlFBQ2srY1hFRnpITWJmSlJ5TVQ4UUpOdHdQSEd3RFJSbVBuNWdLRlJtUG01Z0FCVEJNRThBK0ZxSGtYRTNmM0Q4bEc0K2ptL3JjMmhVQUtCNU9HUnJzMmx4aERBb2VUQmdjRGsvYjJEeEZHNDJuVy9CTUg5d0lUZC9jUGpVWmo2K1lJdHphRlFBb0hrNFlHd0RhWEdFTUNoeE1IUUFKam1PY1FBdFFkUkFGRnRUUUJSV1U4d1Q3NU5xRkZTQkI5Rk9FOGRmUUJUQUZFRTNYMEQwVTBFM1g4RDJrOFRUN2pIZ1RxZzhjYkFFbEhZMmozTUFsSDQzYjM2dlVYay9mM0R6MUg0MkQzNmpjM2hVQ0tCeE1IQjhHNmw1eERnb2NGUkozcmNCQ0JSUUZGbC9CLy8rZUFnSEVkNGRGRmFCQ3RQQUZFTWFnRlJJSHZsL0IvLytlQVFIY3pOS0FBS2FBaFIyT0Y1d0FGUkFGTVliY0RySXNBQTZUTEFMTm5qQURTQi9YMzcvRC9oWDN4d1d3aW5QMGNmWDB6Qll4QVZkeXpkNVVCbGVQQmJETUZqRUJqNW93Qy9Yd3pCWXhBVmRBeGdaZndmLy9uZ01CelZmbG1sUFczTVlHWDhILy81NERBY2xYeGFwVFJ0MEdCbC9CLy8rZUFBSEpSK1RNRWxFSEJ0eUZINDRubjhBRk1Fd1FBRERHM1FVZk52MEZIQlVUam5PZjJnNlhMQUFPbGl3RDFNckcvUVVjRlJPT1M1L1lEcHdzQmtXZGo2dWNlZzZWTEFRT2xpd0R2OEQrQk5iOUJSd1ZFNDVMbjlJT25Dd0VSWjJOcTl4d0RwOHNBZzZWTEFRT2xpd0F6aE9jQzcvQ3YvaU9zQkFBakpJcXdNYmNEeHdRQVl3TUhGQU9uaXdEQkZ4TUVBQXhqRS9jQXdFZ0JSNU1HOEE1alJ2Y0NnOGRiQUFQSFN3QUJUS0lIMlk4RHgyc0FRZ2RkajRQSGV3RGlCOW1QNDRIMjVoTUVFQXlwdlRPRzZ3QURSb1lCQlFleGp1RzNnOGNFQVAzSDNFUmpuUWNVd0VnamdBUUFmYlZoUjJPVzV3S0RwOHNCQTZlTEFZT21Td0VEcGdzQmc2WExBQU9saXdDWDhILy81NENBWWlxTU16U2dBQ20xQVV3RlJCRzFFVWNGUk9PYTUrYTNsd0JndEY5bGQzMFhCV2I1anRHT0E2V0xBTFRmdEZlQlJmbU8wWTYwMS9SZitZN1JqdlRmOUZOMWoxR1ArTk9YOEgvLzU0Q2daU205RS9mM0FPTVZCK3FUM0VjQUU0U0xBQUZNZlYzamRKemJTRVNYOEgvLzU0QWdTQmhFVkVBUVFQbU9Zd2VuQVJ4Q0UwZjMvMzJQMlk0VXdnVU1RUVRadnhGSHBiVkJSd1ZFNDVmbjNvT25pd0FEcDBzQkl5ajVBQ01tNlFCMXU0TWx5UURCRjVIbGljOEJUQk1FWUF5SnV3TW5DUUZqWnZjR0UvYzNBT01aQitJREtBa0JBVVlCUnpNRjZFQ3podVVBWTJuM0FPTUVCdElqS0trQUl5YlpBREc3TTRickFCQk9FUWVRd2dWRzZiOGhSd1ZFNDVIbjJBTWtDUUVad0JNRWdBd2pLQWtBSXlZSkFETTBnQUNsc3dGTUV3UWdETzJ4QVV3VEJJQU16YkVCVEJNRWtBenB1Uk1ISUExamcrY01Fd2RBRGVPYjU3Z0R4RHNBZzhjckFDSUVYWXlYOEgvLzU0Q0FTQU9zeEFCQkZHTnpoQUVpak9NSkRMYkFRR0tVTVlDY1NHTlY4QUNjUkdOYjlBcnY4Ty9MZGQzSVFHS0drNFdMQVpmd2YvL25nSUJFQWNXVEIwQU0zTWpjUU9LWDNNRGNSTE9IaDBIY3hKZndmLy9uZ0dCREpiWUpaUk1GQlhFRHJNc0FBNlNMQUpmd2YvL25nS0F5dHdjQVlOaEx0d1lBQWNFV2sxZEhBUklIZFkrOWk5bVBzNGVIQXdGRnM5V0hBcGZ3Zi8vbmdBQTBFd1dBUHBmd2YvL25nRUF2NmJ5RHBrc0JBNllMQVlPbHl3QURwWXNBNy9Bdi9ORzBnOFU3QUlQSEt3QVRoWXNCb2dYZGpjRVY3L0RQMVhXMDcvQXZ4VDIvQThRN0FJUEhLd0FUaklzQklnUmRqTnhFUVJUTjQ1RkhoVXRqLzRjSWt3ZVFETnpJUWJRRHB3MEFJdEFGU0xPSDdFQSsxb01uaXJCamMvUUFEVWhDeGpyRTcvQ3Z3Q0pITWtnM2hZUkE0b1Y4RUpPR1NnRVFFQk1GeFFLWDhILy81NENnTVRlM2hFQ1RDRWNCZ2xjRHA0aXdnNlVOQUIyTUhZOCtuTEpYSTZUb3NLcUx2cFVqb0wwQWs0ZEtBWjJOQWNXaFoyT1g5UUJhaGUvd2I4c2pvRzBCQ2NUY1JKbkQ0MDl3OTJQZkN3Q1RCM0FNdmJlRlM3YzloVUMzaklSQWs0ME51NU9NVEFIcHYrT2RDNXpjUk9PS0I1eVRCNEFNcWJlRHA0c0E0NU1Ibk8vd2I5TUpaUk1GQlhHWDhILy81NENnSE8vdzc4Nlg4SC8vNTRCZ0lWV3lBNlRMQU9NUEJKanY4Ty9RRXdXQVBwZndmLy9uZ0VBYTcvQ1B6QUtVVWJMdjhBL005bEJtVk5aVVJsbTJXU1phbGxvR1cvWkxaa3pXVEVaTnRrMEpZWUtBQUFBPSIsdGV4dF9zdGFydDoxMDgyMTMwNDMyLGRhdGE6IkZBQ0VRRzRLZ0VDK0NvQkFGZ3VBUU9RTGdFQlFESUJBL2d1QVFEb0pnRUNnQzRCQTRBdUFRQ29MZ0VEcUNJQkFYZ3VBUU9vSWdFQklDb0JBamdxQVFMNEtnRUFXQzRCQVdncUFRSjRKZ0VET0NZQkFWZ3FBUUtnT2dFQytDb0JBYUEyQVFHQU9nRUFxQ0lCQWlBNkFRQ29JZ0VBcUNJQkFLZ2lBUUNvSWdFQXFDSUJBS2dpQVFDb0lnRUFxQ0lCQUJBMkFRQ29JZ0VDR0RZQkFZQTZBUUE9PSIsZGF0YV9zdGFydDoxMDgyNDY5Mjk2LGJzc19zdGFydDoxMDgyMzkyNTc2fX0pO3ZhciBGaT1tKChDRSx6bik9Pnt6bi5leHBvcnRzPXtlbnRyeToxMDgyMTMyMTY0LHRleHQ6IlFSRWl4Q2JDQnNhMzl3QmdFVWMzQklSQTJNdTM5QUJnRXdRRUFOeEFrWXVSNTdKQUlrU1NSRUVCZ29DSVFCeEFFM1gxRDRLWDNiY0JFYmNIQUdCT3hvT3Bod0JLeURjSmhFQW15bExFQnM0aXpMY0VBR0I5V2hNSkNRREFUQk4wOUE4TjRQSkFZa1FqcURRQlFrblNSTEpKSWtvRllZS0FpRUNESndrQUUzWDFENEtYZlJUakdVVC95YjhUQndBTWxFR3FoMk1ZNVFDRlI0WEdJNkFGQUhsVmdvQUZSMk9INWdBSlJtT054Z0I5VllLQVFnVVRCN0FOUVlWamxlY0NpVWVjd2ZXM2t3YkFEV01XMVFDWXdSTUZBQXlDZ0pNRzBBMTlWV09WMXdDWXdSTUZzQTJDZ0xjMWhVQkJFWk9GaGJvR3htRS9ZMFVGQnJjM2hVQ1Rod2V5QTZjSENBUFdSd2dUZGZVUGt3WVdBTUlHd1lJamt0Y0lNcGNqQUtjQUE5ZEhDSkZuazRjSEJHTWU5d0kzdDRSQUV3Y0hzcUZudXBjRHBnY0l0L2FFUUxjM2hVQ1Rod2V5azRZR3RtTWY1Z0FqcHNjSUk2RFhDQ09TQndnaG9QbFg0d2IxL0xKQVFRR0NnQ09tMXdnam9PY0kzYmMzTndCZ2ZFdWRpL1gvTnljQVlIeExuWXYxLzRLQVFSRUd4dDAzdHpjQVlDT21Cd0kzQndBSW1NT1lRMzMveUZleVFCTkY5ZjhGaVVFQmdvQkJFUWJHMlQ5OTNUY0hBRUMzTndCZ21NTTNOd0JnSEVQOS83SkFRUUdDZ0VFUklzUTNoSVJBa3dkRUFVckFBNmtIQVFiR0pzSmpDZ2tFUlRjNXhiMUhFd1JFQVlGRVk5WW5BUVJFdllpVHRCUUFmVGVGUHh4RU53YUFBQk9YeHdDWjREY0dBQUczOXY4QWRZKzNOZ0JnMk1LUXdwaENmZjlCUjVIZ0JVY3pDZWxBdXBjaktDUUJITVN5UUNKRWtrUUNTVUVCZ29BQkVRYk9Jc3dsTnpjRXpqOXNBQk1GUlArWEFJRC81NENnOHFxSEJVV1Y1N0pIay9jSElEN0dpVGMzTndCZ0hFZTNCa0FBRXdWRS85V1BITWV5UlpjQWdQL25nQ0R3TXpXZ0FQSkFZa1FGWVlLQVFSRzNoNFJBQnNhVGgwY0JCVWNqZ09jQUU5ZkZBSmpIQldkOUY4ekR5TWY1alRxVnFwV3hnWXpMSTZvSEFFRTNHY0VUQlZBTXNrQkJBWUtBQVJFaXpEZUVoRUNUQjBRQkpzckVSMDdHQnM1S3lLcUpFd1JFQVdQemxRQ3VoS25BQXlsRUFDYVpFMW5KQUJ4SVkxWHdBQnhFWTE3NUFyVTlmZDFJUUNhR3pvV1hBSUQvNTRBZzR4TjE5UThCeFpNSFFBeGN5RnhBcHBkY3dGeEVoWTljeFBKQVlrVFNSRUpKc2trRllZS0FhVFZ0djBFUkJzYVhBSUQvNTRCQTFnTkZoUUd5UUhVVkV6VVZBRUVCZ29CQkVRYkd4VGNOeGJjSGhFQ1Rod2NBMUVPWnpqZG5DV0FUQndjUkhFTTNCdjMvZlJieGp6Y0dBd0R4anRXUEhNT3lRRUVCZ29CQkVRYkdiVGNSd1ExRnNrQkJBUmNEZ1A5bkFJUE1RUkVHeGliQ0lzU3FoSmNBZ1AvbmdPREpXVGNOeVRjSGhFQ1RCZ2NBZzllR0FCTUVCd0NGQjhJSHdZTWpsUFlBa3dZQURHT0cxQUFUQitBRFkzWDNBRzAzSXhRRUFMSkFJa1NTUkVFQmdvQkJFUWJHRXdjQURHTWE1UUFUQmJBTlJUY1RCY0FOc2tCQkFWbS9Fd2V3RGVNYjVmNXhOeE1GMEEzMXQwRVJJc1Ftd2diR0tvU3pCTFVBWXhlVUFMSkFJa1NTUkVFQmdvQURSUVFBQlFSTlArMjNOWEVteTA3SC9YS0ZhZjEwSXMxS3lWTEZWc01HejVPRWhQb1drWk9IQ1FlbWx4Z0lzNFRuQUNxSkpvVXVoSmNBZ1AvbmdJQXNrNGNKQnhnSUJXcTZsN09LUjBFeDVBVm5mWFdUQllYNmt3Y0hCeE1GaGZrVUNLcVhNNFhYQUpNSEJ3ZXVsN09GMXdBcXhwY0FnUC9uZ0VBcE1rWEJSWlUzQVVXRlloYVIra0JxUk5wRVNrbTZTU3BLbWtvTllZS0Fvb2xqYzRvQWhXbE9odGFGU29XWEFJRC81NERBeFJOMTlROEI3VTZHMW9VbWhaY0FnUC9uZ0lBa1Rwa3pCRFJCVWJjVEJUQUdWYjhUQlFBTVNiMHhjZjF5QldkTzExTFZWdE5lendiZkl0MG0yMHJaV3RGaXpXYkxhc2x1eC8xM0ZwRVRCd2NIUHBjY0NMcVhQc1lqcWdmNHFva3VpcktLdG92MU01TUhBQUlad2JjSEFnQStoWmNBZ1AvbmdDQWRoV2RqNVZjVEJXUjllUk1KaWZxVEJ3UUh5cGNZQ0RPSjV3QktoWmNBZ1AvbmdLQWJmWHNURER2NWt3eUwrUk1IQkFlVEJ3UUhGQWhpbCthWGdVUXpETmNBczR6WEFGSk5ZM3hOQ1dQeHBBTkJxSmsvb29VSUFZMDF1VGNpaGd3QlNvV1hBSUQvNTRDQUY2S1pvcFJqOVVRRHM0ZWtRV1B4ZHdNekJKcEFZL09LQUZhRUlvWU1BVTZGbHdDQS8rZUFBTFVUZGZVUFZkMEN6QUZFZVYyTlRhTUpBUUJpaFpjQWdQL25nRUNrZmZrRFJURUI1b1dGTkdOUEJRRGo0bzMraFdlVGh3Y0hvcGNZQ0xxWDJwY2ppcWY0QlFUeHQrTVZwZjJSUitNRjlQWUZaMzExa3djSEI1TUZoZm9UQllYNUZBaXFsek9GMXdDVEJ3Y0hycGV6aGRjQUtzYVhBSUQvNTRDZ0RYRTlNa1hCUldVelVUM0JNYmNIQWdBWjRaTUhBQUkraFpjQWdQL25nS0FLaFdJV2tmcFFhbFRhVkVwWnVsa3FXcHBhQ2x2NlMycE0ya3hLVGJwTktXR0NnTGRYUVVrWmNaT0g5NFFCUlliZW90eW0yc3JZenRiUzFOYlMydERlenVMTTVzcnF5TzdHUHM2WEFJRC81NENBbmFFNURjRTNad2xnRXdjSEVSeER0d2FFUUNPaTlnQzNCdjMvL1JiMWo4Rm0xWThjd3hVNUJjMjNKd3RnTjBmWVVKT0doOEVUQnhlcW1NSVRoZ2ZBSXlBR0FDT2dCZ0NUaGdmQ21NS1RoOGZCbUVNM0JnUUFVWStZd3lPZ0JnQzNCNFJBTnplRlFKT0hCd0FUQndlN0lhQWpvQWNBa1FmajdlZitSVHVSUldnSWRUbGxNN2UzaEVDVGh3ZXlJV2MrbHlNZzl3aTNCNEJBTndtRVFKT0hodzRqSVBrQXR6bUZRRVUrRXdrSkFKT0pDYkpqQlFVUXR3Y0JZRVZISTZEbkRJVkZSVVdYQUlELzU0QUE5cmNGZ0VBQlJwT0ZCUUJGUlpjQWdQL25nQUQzdC9jQVlCRkhtTXMzQlFJQWx3Q0EvK2VBUVBhM0Z3bGdpRitCUmJlRWhFQnhpV0VWRXpVVkFKY0FnUC9uZ0FDZXdXZjlGeE1IQUJDRlprRm10d1VBQVFGRms0UkVBYmNLaEVBTmFwY0FnUC9uZ0FDVUU0dEtBU2FhZzZmSkNQWGZnNnZKQ0lWSEk2WUpDQ01DOFFLRHh4c0FDVWNqRStFQ293THhBZ0xVVFVkamdlY0lVVWRqaitjR0tVZGpuK2NBZzhjN0FBUEhLd0NpQjltUEVVZGpsdWNBZzZlTEFKeERQdFJGTWFGRlNCQjFOb1BIT3dBRHh5c0FvZ2ZaanhGblFRZGpkUGNFRXdXd0RSaytFd1hBRFFFK0V3WGdEaWsyalRsQnQ3Y0ZnRUFCUnBPRmhRTVZSWmNBZ1AvbmdBRG9Od2NBWUZ4SEV3VUFBcFBuRnhCY3h6RzN5VWNqRS9FQ1RiY0R4eHNBMFVaajUrWUNoVVpqNXVZQUFVd1RCUEFQaGFoNUZ4TjM5dy9KUnVQbzV2NjNOb1ZBQ2dlVGhrYTdOcGNZUXdLSGt3WUhBNVAyOWc4UlJ1TnAxdndUQi9jQ0UzZjNENDFHWSt2bUNMYzJoVUFLQjVPR0JzQTJseGhEQW9jVEIwQUNZNWpuRUFMVUhVUUJSYVUwQVVWVlBQRTI2VGFoUlVnUWZSVFJQSFgwQVV3QlJCTjE5QTl4UEJOMS9BOVpQSDAyNHg0RTZvUEhHd0JKUjJObzl6QUpSK04yOStyMUY1UDM5dzg5UitOZzkrbzNONFZBaWdjVEJ3ZkJ1cGVjUTRLSEJVU2Q2M0FRZ1VVQlJaZndmLy9uZ0FCeEhlSFJSV2dRblR3QlJER29CVVNCNzVmd2YvL25nQUIyTXpTZ0FDbWdJVWRqaGVjQUJVUUJUR0czQTZ5TEFBT2t5d0N6WjR3QTBnZjE5Ky93djRWOThjRnNJcHo5SEgxOU13V01RRlhjczNlVkFaWGp3V3d6Qll4QVkrYU1BdjE4TXdXTVFGWFFNWUdYOEgvLzU0Q0FjbFg1WnBUMXR6R0JsL0IvLytlQWdIRlY4V3FVMGJkQmdaZndmLy9uZ01Cd1Vma3pCSlJCd2JjaFIrT0o1L0FCVEJNRUFBd3h0MEZIemI5QlJ3VkU0NXpuOW9PbHl3QURwWXNBNVRLeHYwRkhCVVRqa3VmMkE2Y0xBWkZuWStybkhvT2xTd0VEcFlzQTcvRC9nRFcvUVVjRlJPT1M1L1NEcHdzQkVXZGphdmNjQTZmTEFJT2xTd0VEcFlzQU00VG5BdS93Yi80anJBUUFJeVNLc0RHM0E4Y0VBR01EQnhRRHA0c0F3UmNUQkFBTVl4UDNBTUJJQVVlVEJ2QU9ZMGIzQW9QSFd3QUR4MHNBQVV5aUI5bVBBOGRyQUVJSFhZK0R4M3NBNGdmWmorT0I5dVlUQkJBTXFiMHpodXNBQTBhR0FRVUhzWTdodDRQSEJBRDl4OXhFWTUwSEZNQklJNEFFQUgyMVlVZGpsdWNDZzZmTEFRT25pd0dEcGtzQkE2WUxBWU9seXdBRHBZc0FsL0IvLytlQVFHRXFqRE0wb0FBcHRRRk1CVVFSdFJGSEJVVGptdWZtdDVjQVlMUmZaWGQ5RndWbStZN1JqZ09saXdDMDM3UlhnVVg1anRHT3ROZjBYL21PMFk3MDMvUlRkWTlSai9qVGwvQi8vK2VBSUdRcHZSUDM5d0RqRlFmcWs5eEhBQk9FaXdBQlRIMWQ0M1NjMjBoRWwvQi8vK2VBSUVnWVJGUkFFRUQ1am1NSHB3RWNRaE5IOS85OWo5bU9GTUlGREVFRTJiOFJSNlcxUVVjRlJPT1g1OTZEcDRzQUE2ZExBU01vK1FBakp1a0FkYnVESmNrQXdSZVI1WW5QQVV3VEJHQU1pYnNESndrQlkyYjNCaFAzTndEakdRZmlBeWdKQVFGR0FVY3pCZWhBczRibEFHTnA5d0RqQkFiU0l5aXBBQ01tMlFBeHV6T0c2d0FRVGhFSGtNSUZSdW0vSVVjRlJPT1I1OWdESkFrQkdjQVRCSUFNSXlnSkFDTW1DUUF6TklBQXBiTUJUQk1FSUF6dHNRRk1Fd1NBRE0yeEFVd1RCSkFNNmJrVEJ5QU5ZNFBuREJNSFFBM2ptK2U0QThRN0FJUEhLd0FpQkYyTWwvQi8vK2VBUUVjRHJNUUFRUlJqYzRRQklvempDUXkyd0VCaWxER0FuRWhqVmZBQW5FUmpXL1FLNy9DdnkzWGR5RUJpaHBPRml3R1g4SC8vNTRCQVF3SEZrd2RBRE56STNFRGlsOXpBM0VTemg0ZEIzTVNYOEgvLzU0QWdRaVcyQ1dVVEJRVnhBNnpMQUFPa2l3Q1g4SC8vNTRDZ01yY0hBR0RZUzdjR0FBSEJGcE5YUndFU0IzV1B2WXZaajdPSGh3TUJSYlBWaHdLWDhILy81NERBTXhNRmdENlg4SC8vNTRCQUwrbThnNlpMQVFPbUN3R0RwY3NBQTZXTEFPL3c3L3ZSdElQRk93Q0R4eXNBRTRXTEFhSUYzWTNCRmUvd2o5VjF0Ty93NzhROXZ3UEVPd0NEeHlzQUU0eUxBU0lFWFl6Y1JFRVV6ZU9SUjRWTFkvK0hDSk1Ia0F6Y3lFRzBBNmNOQUNMUUJVaXpoK3hBUHRhREo0cXdZM1AwQUExSVFzWTZ4Ty93YjhBaVJ6SklONFdFUU9LRmZCQ1Roa29CRUJBVEJjVUNsL0IvLytlQUlERTN0NFJBa3doSEFZSlhBNmVJc0lPbERRQWRqQjJQUHB5eVZ5T2s2TENxaTc2Vkk2QzlBSk9IU2dHZGpRSEZvV2RqbC9VQVdvWHY4Qy9MSTZCdEFRbkUzRVNadytOUGNQZGozd3NBa3dkd0RMMjNoVXUzUFlWQXQ0eUVRSk9ORGJ1VGpFd0I2Yi9qblF1YzNFVGppZ2Vja3dlQURLbTNnNmVMQU9PVEI1enY4Qy9UQ1dVVEJRVnhsL0IvLytlQW9CenY4Sy9PbC9CLy8rZUE0Q0JWc2dPa3l3RGpEd1NZNy9DdjBCTUZnRDZYOEgvLzU0QkFHdS93VDh3Q2xGR3k3L0RQeS9aUVpsVFdWRVpadGxrbVdwWmFCbHYyUzJaTTFreEdUYlpOQ1dHQ2dBQUEiLHRleHRfc3RhcnQ6MTA4MjEzMDQzMixkYXRhOiJGQUNFUUhJS2dFRENDb0JBR2d1QVFPZ0xnRUJVRElCQUFneUFRRDRKZ0VDa0M0QkE1QXVBUUM0TGdFRHVDSUJBWWd1QVFPNElnRUJNQ29CQWtncUFRTUlLZ0VBYUM0QkFYZ3FBUUtJSmdFRFNDWUJBV2dxQVFLd09nRURDQ29CQWJBMkFRR1FPZ0VBdUNJQkFqQTZBUUM0SWdFQXVDSUJBTGdpQVFDNElnRUF1Q0lCQUxnaUFRQzRJZ0VBdUNJQkFDQTJBUUM0SWdFQ0tEWUJBWkE2QVFBPT0iLGRhdGFfc3RhcnQ6MTA4MjQ2OTI5Nixic3Nfc3RhcnQ6MTA4MjM5MjU3Nn19KTt2YXIgVGk9bSgoSUUsam4pPT57am4uZXhwb3J0cz17ZW50cnk6MTA4MjEzMjE2NCx0ZXh0OiJRUkVpeENiQ0JzYTM5d0JnRVVjM1JJQkEyTXUzOUFCZ0V3UUVBTnhBa1l1UjU3SkFJa1NTUkVFQmdvQ0lRQnhBRTNYMUQ0S1gzYmNCRWJjSEFHQk94b09waHdCS3lEZEpnRUFteWxMRUJzNGl6TGNFQUdCOVdoTUpDUURBVEJOMDlBOE40UEpBWWtRanFEUUJRa25TUkxKSklrb0ZZWUtBaUVDREp3a0FFM1gxRDRLWGZSVGpHVVQveWI4VEJ3QU1sRUdxaDJNWTVRQ0ZSNFhHSTZBRkFIbFZnb0FGUjJPSDVnQUpSbU9OeGdCOVZZS0FRZ1VUQjdBTlFZVmpsZWNDaVVlY3dmVzNrd2JBRFdNVzFRQ1l3Uk1GQUF5Q2dKTUcwQTE5VldPVjF3Q1l3Uk1Gc0EyQ2dMZDFnVUJCRVpPRmhib0d4bUUvWTBVRkJyZDNnVUNUaHdleUE2Y0hDQVBXUndnVGRmVVBrd1lXQU1JR3dZSWprdGNJTXBjakFLY0FBOWRIQ0pGbms0Y0hCR01lOXdJMzk0QkFFd2NIc3FGbnVwY0RwZ2NJdHphQlFMZDNnVUNUaHdleWs0WUd0bU1mNWdBanBzY0lJNkRYQ0NPU0J3Z2hvUGxYNHdiMS9MSkFRUUdDZ0NPbTF3Z2pvT2NJM2JjM053QmdmRXVkaS9YL055Y0FZSHhMbll2MS80S0FRUkVHeHQwM3R6Y0FZQ09tQndJM0J3QUltTU9ZUTMzL3lGZXlRQk5GOWY4RmlVRUJnb0JCRVFiRzJUOTkzVGNIQUVDM053QmdtTU0zTndCZ0hFUDkvN0pBUVFHQ2dFRVJJc1EzeElCQWt3ZEVBVXJBQTZrSEFRYkdKc0pqQ2drRVJUYzV4YjFIRXdSRUFZRkVZOVluQVFSRXZZaVR0QlFBZlRlRlB4eEVOd2FBQUJPWHh3Q1o0RGNHQUFHMzl2OEFkWSszTmdCZzJNS1F3cGhDZmY5QlI1SGdCVWN6Q2VsQXVwY2pLQ1FCSE1TeVFDSkVra1FDU1VFQmdvQUJFUWJPSXN3bE56Y0V6ajlzQUJNRlJQK1hBSUQvNTRDZzg2cUhCVVdWNTdKSGsvY0hJRDdHaVRjM053QmdIRWUzQmtBQUV3VkUvOVdQSE1leVJaY0FnUC9uZ0NEeE16V2dBUEpBWWtRRllZS0FRUkczeDRCQUJzYVRoMGNCQlVjamdPY0FFOWZGQUpqSEJXZDlGOHpEeU1mNWpUcVZxcFd4Z1l6TEk2b0hBRUUzR2NFVEJWQU1za0JCQVlLQUFSRWl6RGZFZ0VDVEIwUUJKc3JFUjA3R0JzNUt5S3FKRXdSRUFXUHpsUUN1aEtuQUF5bEVBQ2FaRTFuSkFCeElZMVh3QUJ4RVkxNzVBclU5ZmQxSVFDYUd6b1dYQUlELzU0QWc1Qk4xOVE4QnhaTUhRQXhjeUZ4QXBwZGN3RnhFaFk5Y3hQSkFZa1RTUkVKSnNra0ZZWUtBYVRWdHYwRVJCc2FYQUlELzU0Q0ExZ05GaFFHeVFIVVZFelVWQUVFQmdvQkJFUWJHeFRjTnhiZEhnRUNUaHdjQTFFT1p6amRuQ1dBVEI0Y09IRU0zQnYzL2ZSYnhqemNHQXdEeGp0V1BITU95UUVFQmdvQkJFUWJHYlRjUndRMUZza0JCQVJjRGdQOW5BSVBNUVJFR3hpYkNJc1NxaEpjQWdQL25nS0RKV1RjTnlUZEhnRUNUQmdjQWc5ZUdBQk1FQndDRkI4SUh3WU1qbFBZQWt3WUFER09HMUFBVEIrQURZM1gzQUcwM0l4UUVBTEpBSWtTU1JFRUJnb0JCRVFiR0V3Y0FER01hNVFBVEJiQU5SVGNUQmNBTnNrQkJBVm0vRXdld0RlTWI1ZjV4TnhNRjBBMzF0MEVSSXNRbXdnYkdLb1N6QkxVQVl4ZVVBTEpBSWtTU1JFRUJnb0FEUlFRQUJRUk5QKzIzTlhFbXkwN0gvWEtGYWYxMElzMUt5VkxGVnNNR3o1T0VoUG9Xa1pPSENRZW1seGdJczRUbkFDcUpKb1V1aEpjQWdQL25nSUF2azRjSkJ4Z0lCV3E2bDdPS1IwRXg1QVZuZlhXVEJZWDZrd2NIQnhNRmhma1VDS3FYTTRYWEFKTUhCd2V1bDdPRjF3QXF4cGNBZ1AvbmdFQXNNa1hCUlpVM0FVV0ZZaGFSK2tCcVJOcEVTa202U1NwS21rb05ZWUtBb29samM0b0FoV2xPaHRhRlNvV1hBSUQvNTREQXhoTjE5UThCN1U2RzFvVW1oWmNBZ1AvbmdJQW5UcGt6QkRSQlViY1RCVEFHVmI4VEJRQU1TYjB4Y2YxeUJXZE8xMUxWVnROZXp3YmZJdDBtMjByWld0Rml6V2JMYXNsdXgvMTNGcEVUQndjSFBwY2NDTHFYUHNZanFnZjRxb2t1aXJLS3RvdjFNNU1IQUFJWndiY0hBZ0EraFpjQWdQL25nR0FlaFdkajVWY1RCV1I5ZVJNSmlmcVRCd1FIeXBjWUNET0o1d0JLaFpjQWdQL25nS0FlZlhzVEREdjVrd3lMK1JNSEJBZVRCd1FIRkFoaWwrYVhnVVF6RE5jQXM0elhBRkpOWTN4TkNXUHhwQU5CcUprL29vVUlBWTAxdVRjaWhnd0JTb1dYQUlELzU0Q0FHcUtab3BSajlVUURzNGVrUVdQeGR3TXpCSnBBWS9PS0FGYUVJb1lNQVU2Rmx3Q0EvK2VBQUxZVGRmVVBWZDBDekFGRWVWMk5UYU1KQVFCaWhaY0FnUC9uZ0VDa2Zma0RSVEVCNW9XRk5HTlBCUURqNG8zK2hXZVRod2NIb3BjWUNMcVgycGNqaXFmNEJRVHh0K01WcGYyUlIrTUY5UFlGWjMxMWt3Y0hCNU1GaGZvVEJZWDVGQWlxbHpPRjF3Q1RCd2NIcnBlemhkY0FLc2FYQUlELzU0Q2dFSEU5TWtYQlJXVXpVVDNCTWJjSEFnQVo0Wk1IQUFJK2haY0FnUC9uZ09BTGhXSVdrZnBRYWxUYVZFcFp1bGtxV3BwYUNsdjZTMnBNMmt4S1RicE5LV0dDZ0xkWFFVa1pjWk9IOTRRQlJZYmVvdHltMnNyWXp0YlMxTmJTMnREZXp1TE01c3JxeU83R1BzNlhBSUQvNTREQW5hRTVEY0UzWndsZ0V3ZUhEaHhEdDBhQVFDT2k5Z0MzQnYzLy9SYjFqOEZtMVk4Y3d4VTVCYzIzSnd0Z04wZllVSk9HaDhFVEJ4ZXFtTUlUaGdmQUl5QUdBQ09nQmdDVGhnZkNtTUtUaDhmQm1FTTNCZ1FBVVkrWXd5T2dCZ0MzUjRCQU4zZUJRSk9IQndBVEJ3ZTdJYUFqb0FjQWtRZmo3ZWYrUlR1UlJXZ0lkVGxsTTdmM2dFQ1Rod2V5SVdjK2x5TWc5d2kzQjRCQU4wbUFRSk9IaHc0aklQa0F0M21CUUVVK0V3a0pBSk9KQ2JKakJnVVF0d2NCWUJNSEVBSWpwT2NLaFVWRlJaY0FnUC9uZ09EMnR3V0FRQUZHazRVRkFFVkZsd0NBLytlQUlQaTM5d0JnRVVlWXl6Y0ZBZ0NYQUlELzU0Qmc5N2NYQ1dDSVg0RkZ0OFNBUUhHSllSVVROUlVBbHdDQS8rZUFJSi9CWi8wWEV3Y0FFSVZtUVdhM0JRQUJBVVdUaEVRQnQwcUFRQTFxbHdDQS8rZUE0SlFUaTBvQkpwcURwOGtJOWQrRHE4a0loVWNqcGdrSUl3THhBb1BIR3dBSlJ5TVQ0UUtqQXZFQ0F0Uk5SMk9CNXdoUlIyT1A1d1lwUjJPZjV3Q0R4enNBQThjckFLSUgyWThSUjJPVzV3Q0RwNHNBbkVNKzFIazVvVVZJRUcwMmc4YzdBQVBIS3dDaUI5bVBFV2RCQjJOMDl3UVRCYkFORVQ0VEJjQU5PVFlUQmVBT0lUYUZPVUczdHdXQVFBRkdrNFdGQXhWRmx3Q0EvK2VBSU9rM0J3QmdYRWNUQlFBQ2srY1hFRnpITWJmSlJ5TVQ4UUpOdHdQSEd3RFJSbVBuNWdLRlJtUG01Z0FCVEJNRThBK0ZxSGtYRTNmM0Q4bEc0K2ptL3JkMmdVQUtCNU9HUnJzMmx4aERBb2VUQmdjRGsvYjJEeEZHNDJuVy9CTUg5d0lUZC9jUGpVWmo2K1lJdDNhQlFBb0hrNFlHd0RhWEdFTUNoeE1IUUFKam1PY1FBdFFkUkFGRm5UUUJSVTA4NlRiaE5xRkZTQkI5Rk1rOGRmUUJUQUZFRTNYMEQyazhFM1g4RDFFOGRUYmpIZ1RxZzhjYkFFbEhZMmozTUFsSDQzYjM2dlVYay9mM0R6MUg0MkQzNmpkM2dVQ0tCeE1IQjhHNmw1eERnb2NGUkozcmNCQ0JSUUZGbC9CLy8rZUFJSEVkNGRGRmFCQ1ZQQUZFTWFnRlJJSHZsL0IvLytlQTRIWXpOS0FBS2FBaFIyT0Y1d0FGUkFGTVliY0RySXNBQTZUTEFMTm5qQURTQi9YMzcvQ2ZoWDN4d1d3aW5QMGNmWDB6Qll4QVZkeXpkNVVCbGVQQmJETUZqRUJqNW93Qy9Yd3pCWXhBVmRBeGdaZndmLy9uZ0dCelZmbG1sUFczTVlHWDhILy81NEJnY2xYeGFwVFJ0MEdCbC9CLy8rZUFvSEZSK1RNRWxFSEJ0eUZINDRubjhBRk1Fd1FBRERHM1FVZk52MEZIQlVUam5PZjJnNlhMQUFPbGl3RGRNckcvUVVjRlJPT1M1L1lEcHdzQmtXZGo2dWNlZzZWTEFRT2xpd0R2OE4rQU5iOUJSd1ZFNDVMbjlJT25Dd0VSWjJOcTl4d0RwOHNBZzZWTEFRT2xpd0F6aE9jQzcvQlAvaU9zQkFBakpJcXdNYmNEeHdRQVl3TUhGQU9uaXdEQkZ4TUVBQXhqRS9jQXdFZ0JSNU1HOEE1alJ2Y0NnOGRiQUFQSFN3QUJUS0lIMlk4RHgyc0FRZ2RkajRQSGV3RGlCOW1QNDRIMjVoTUVFQXlwdlRPRzZ3QURSb1lCQlFleGp1RzNnOGNFQVAzSDNFUmpuUWNVd0VnamdBUUFmYlZoUjJPVzV3S0RwOHNCQTZlTEFZT21Td0VEcGdzQmc2WExBQU9saXdDWDhILy81NEFnWWlxTU16U2dBQ20xQVV3RlJCRzFFVWNGUk9PYTUrYTNsd0JndEY5bGQzMFhCV2I1anRHT0E2V0xBTFRmdEZlQlJmbU8wWTYwMS9SZitZN1JqdlRmOUZOMWoxR1ArTk9YOEgvLzU0QkFaU205RS9mM0FPTVZCK3FUM0VjQUU0U0xBQUZNZlYzamRKemJTRVNYOEgvLzU0REFSeGhFVkVBUVFQbU9Zd2VuQVJ4Q0UwZjMvMzJQMlk0VXdnVU1RUVRadnhGSHBiVkJSd1ZFNDVmbjNvT25pd0FEcDBzQkl5ajVBQ01tNlFCMXU0TWx5UURCRjVIbGljOEJUQk1FWUF5SnV3TW5DUUZqWnZjR0UvYzNBT01aQitJREtBa0JBVVlCUnpNRjZFQ3podVVBWTJuM0FPTUVCdElqS0trQUl5YlpBREc3TTRickFCQk9FUWVRd2dWRzZiOGhSd1ZFNDVIbjJBTWtDUUVad0JNRWdBd2pLQWtBSXlZSkFETTBnQUNsc3dGTUV3UWdETzJ4QVV3VEJJQU16YkVCVEJNRWtBenB1Uk1ISUExamcrY01Fd2RBRGVPYjU3Z0R4RHNBZzhjckFDSUVYWXlYOEgvLzU0QWdTQU9zeEFCQkZHTnpoQUVpak9NSkRMYkFRR0tVTVlDY1NHTlY4QUNjUkdOYjlBcnY4SS9MZGQzSVFHS0drNFdMQVpmd2YvL25nQ0JFQWNXVEIwQU0zTWpjUU9LWDNNRGNSTE9IaDBIY3hKZndmLy9uZ0FCREpiWUpaUk1GQlhFRHJNc0FBNlNMQUpmd2YvL25nRUF5dHdjQVlOaEx0d1lBQWNFV2sxZEhBUklIZFkrOWk5bVBzNGVIQXdGRnM5V0hBcGZ3Zi8vbmdLQXpFd1dBUHBmd2YvL25nT0F1NmJ5RHBrc0JBNllMQVlPbHl3QURwWXNBNy9EUCs5RzBnOFU3QUlQSEt3QVRoWXNCb2dYZGpjRVY3L0J2MVhXMDcvRFB4RDIvQThRN0FJUEhLd0FUaklzQklnUmRqTnhFUVJUTjQ1RkhoVXRqLzRjSWt3ZVFETnpJUWJRRHB3MEFJdEFGU0xPSDdFQSsxb01uaXJCamMvUUFEVWhDeGpyRTcvQlB3Q0pITWtnM3hZQkE0b1Y4RUpPR1NnRVFFQk1GeFFLWDhILy81NEJBTVRmM2dFQ1RDRWNCZ2xjRHA0aXdnNlVOQUIyTUhZOCtuTEpYSTZUb3NLcUx2cFVqb0wwQWs0ZEtBWjJOQWNXaFoyT1g5UUJhaGUvd0Q4c2pvRzBCQ2NUY1JKbkQ0MDl3OTJQZkN3Q1RCM0FNdmJlRlM3ZDlnVUMzeklCQWs0ME51NU9NVEFIcHYrT2RDNXpjUk9PS0I1eVRCNEFNcWJlRHA0c0E0NU1Ibk8vd0Q5TUpaUk1GQlhHWDhILy81NEJBSE8vd2o4Nlg4SC8vNTRBQUlWV3lBNlRMQU9NUEJKanY4SS9RRXdXQVBwZndmLy9uZ09BWjcvQXZ6QUtVVWJMdjhLL0w5bEJtVk5aVVJsbTJXU1phbGxvR1cvWkxaa3pXVEVaTnRrMEpZWUtBIix0ZXh0X3N0YXJ0OjEwODIxMzA0MzIsZGF0YToiRkVDQVFIUUtnRURFQ29CQUhBdUFRT29MZ0VCV0RJQkFCQXlBUUVBSmdFQ21DNEJBNWd1QVFEQUxnRUR3Q0lCQVpBdUFRUEFJZ0VCT0NvQkFsQXFBUU1RS2dFQWNDNEJBWUFxQVFLUUpnRURVQ1lCQVhBcUFRSzRPZ0VERUNvQkFiZzJBUUdZT2dFQXdDSUJBamc2QVFEQUlnRUF3Q0lCQU1BaUFRREFJZ0VBd0NJQkFNQWlBUURBSWdFQXdDSUJBQ2cyQVFEQUlnRUNNRFlCQVpnNkFRQT09IixkYXRhX3N0YXJ0OjEwODIyMjM1MzYsYnNzX3N0YXJ0OjEwODIxNDY4MTZ9fSk7dmFyIHBpPW0oKGxFLFpuKT0+e1puLmV4cG9ydHM9e2VudHJ5OjEwODIxMzIxNjQsdGV4dDoiUVJFaXhDYkNCc2EzOXdCZ0VVYzNCSU5BMk11MzlBQmdFd1FFQU54QWtZdVI1N0pBSWtTU1JFRUJnb0NJUUJ4QUUzWDFENEtYM2JjQkViY0hBR0JPeG9PcGh3Qkt5RGNKZzBBbXlsTEVCczRpekxjRUFHQjlXaE1KQ1FEQVRCTjA5QThONFBKQVlrUWpxRFFCUWtuU1JMSkpJa29GWVlLQWlFQ0RKd2tBRTNYMUQ0S1hmUlRqR1VUL3liOFRCd0FNbEVHcWgyTVk1UUNGUjRYR0k2QUZBSGxWZ29BRlIyT0g1Z0FKUm1PTnhnQjlWWUtBUWdVVEI3QU5RWVZqbGVjQ2lVZWN3Zlcza3diQURXTVcxUUNZd1JNRkFBeUNnSk1HMEExOVZXT1Yxd0NZd1JNRnNBMkNnTGMxaEVCQkVaT0ZoYm9HeG1FL1kwVUZCcmMzaEVDVGh3ZXlBNmNIQ0FQV1J3Z1RkZlVQa3dZV0FNSUd3WUlqa3RjSU1wY2pBS2NBQTlkSENKRm5rNGNIQkdNZTl3STN0NE5BRXdjSHNxRm51cGNEcGdjSXQvYURRTGMzaEVDVGh3ZXlrNFlHdG1NZjVnQWpwc2NJSTZEWENDT1NCd2dob1BsWDR3YjEvTEpBUVFHQ2dDT20xd2dqb09jSTNiYzNOd0JnZkV1ZGkvWC9OeWNBWUh4TG5ZdjEvNEtBUVJFR3h0MDN0emNBWUNPbUJ3STNCd0FJbU1PWVEzMy95RmV5UUJORjlmOEZpVUVCZ29CQkVRYkcyVDk5M1RjSEFFQzNOd0JnbU1NM053QmdIRVA5LzdKQVFRR0NnRUVSSXNRM2hJTkFrd2RFQVVyQUE2a0hBUWJHSnNKakNna0VSVGM1eGIxSEV3UkVBWUZFWTlZbkFRUkV2WWlUdEJRQWZUZUZQeHhFTndhQUFCT1h4d0NaNERjR0FBRzM5djhBZFkrM05nQmcyTUtRd3BoQ2ZmOUJSNUhnQlVjekNlbEF1cGNqS0NRQkhNU3lRQ0pFa2tRQ1NVRUJnb0FCRVFiT0lzd2xOemNFaFVCc0FCTUZCUCtYQUlELzU0QWc4cXFIQlVXVjU3SkhrL2NISUQ3R2lUYzNOd0JnSEVlM0JrQUFFd1VFLzlXUEhNZXlSWmNBZ1AvbmdLRHZNeldnQVBKQVlrUUZZWUtBUVJHM2g0TkFCc2FUaDBjQkJVY2pnT2NBRTlmRkFKakhCV2Q5Rjh6RHlNZjVqVHFWcXBXeGdZekxJNm9IQUVFM0djRVRCVkFNc2tCQkFZS0FBUkVpekRlRWcwQ1RCMFFCSnNyRVIwN0dCczVLeUtxSkV3UkVBV1B6bFFDdWhLbkFBeWxFQUNhWkUxbkpBQnhJWTFYd0FCeEVZMTc1QXJVOWZkMUlRQ2FHem9XWEFJRC81NENnNGhOMTlROEJ4Wk1IUUF4Y3lGeEFwcGRjd0Z4RWhZOWN4UEpBWWtUU1JFSkpza2tGWVlLQWFUVnR2MEVSQnNhWEFJRC81NEJBMWdORmhRR3lRSFVWRXpVVkFFRUJnb0JCRVFiR3hUY054YmNIZzBDVGh3Y0ExRU9aempkbkNXQVRCOGNRSEVNM0J2My9mUmJ4anpjR0F3RHhqdFdQSE1PeVFFRUJnb0JCRVFiR2JUY1J3UTFGc2tCQkFSY0RnUDluQUlQTVFSRUd4aWJDSXNTcWhKY0FnUC9uZ09ESldUY055VGNIZzBDVEJnY0FnOWVHQUJNRUJ3Q0ZCOElId1lNamxQWUFrd1lBREdPRzFBQVRCK0FEWTNYM0FHMDNJeFFFQUxKQUlrU1NSRUVCZ29CQkVRYkdFd2NBREdNYTVRQVRCYkFOUlRjVEJjQU5za0JCQVZtL0V3ZXdEZU1iNWY1eE54TUYwQTMxdDBFUklzUW13Z2JHS29TekJMVUFZeGVVQUxKQUlrU1NSRUVCZ29BRFJRUUFCUVJOUCsyM05YRW15MDdIL1hLRmFmMTBJczFLeVZMRlZzTUd6NU9FaFBvV2taT0hDUWVtbHhnSXM0VG5BQ3FKSm9VdWhKY0FnUC9uZ0VBcGs0Y0pCeGdJQldxNmw3T0tSMEV4NUFWbmZYV1RCWVg2a3djSEJ4TUZoZmtVQ0txWE00WFhBSk1IQndldWw3T0Yxd0FxeHBjQWdQL25nQUFtTWtYQlJaVTNBVVdGWWhhUitrQnFSTnBFU2ttNlNTcEtta29OWVlLQW9vbGpjNG9BaFdsT2h0YUZTb1dYQUlELzU0QkF4Uk4xOVE4QjdVNkcxb1VtaFpjQWdQL25nRUFoVHBrekJEUkJVYmNUQlRBR1ZiOFRCUUFNU2IweGNmMXlCV2RPMTFMVlZ0TmV6d2JmSXQwbTIwclpXdEZpeldiTGFzbHV4LzEzRnBFVEJ3Y0hQcGNjQ0xxWFBzWWpxZ2Y0cW9rdWlyS0t0b3YxTTVNSEFBSVp3YmNIQWdBK2haY0FnUC9uZ09BWmhXZGo1VmNUQldSOWVSTUppZnFUQndRSHlwY1lDRE9KNXdCS2haY0FnUC9uZ0dBWWZYc1RERHY1a3d5TCtSTUhCQWVUQndRSEZBaGlsK2FYZ1VRekROY0FzNHpYQUZKTlkzeE5DV1B4cEFOQnFKay9vb1VJQVkwMXVUY2loZ3dCU29XWEFJRC81NEJBRktLWm9wUmo5VVFEczRla1FXUHhkd016QkpwQVkvT0tBRmFFSW9ZTUFVNkZsd0NBLytlQWdMUVRkZlVQVmQwQ3pBRkVlVjJOVGFNSkFRQmloWmNBZ1AvbmdFQ2tmZmtEUlRFQjVvV0ZOR05QQlFEajRvMytoV2VUaHdjSG9wY1lDTHFYMnBjamlxZjRCUVR4dCtNVnBmMlJSK01GOVBZRlozMTFrd2NIQjVNRmhmb1RCWVg1RkFpcWx6T0Yxd0NUQndjSHJwZXpoZGNBS3NhWEFJRC81NEJnQ25FOU1rWEJSV1V6VVQzQk1iY0hBZ0FaNFpNSEFBSStoWmNBZ1AvbmdHQUhoV0lXa2ZwUWFsVGFWRXBadWxrcVdwcGFDbHY2UzJwTTJreEtUYnBOS1dHQ2dMZFhRVWtaY1pPSDk0UUJSWWJlb3R5bTJzcll6dGJTMU5iUzJ0RGV6dUxNNXNycXlPN0dQczZYQUlELzU0Q0FuYUU1RGNFM1p3bGdFd2ZIRUJ4RHR3YURRQ09pOWdDM0J2My8vUmIxajhGbTFZOGN3eFU1QmMyM0p3dGdOMGZZVUpPR3g4RVRCeGVxbU1JVGhnZkFJeUFHQUNPZ0JnQ1Roa2ZDbU1LVGh3ZkNtRU0zQmdRQVVZK1l3eU9nQmdDM0I0TkFOemVFUUpPSEJ3QVRCd2U3SWFBam9BY0FrUWZqN2VmK1JUdVJSV2dJZFRsbE03ZTNnMENUaHdleUlXYytseU1nOXdpM0I0QkFOd21EUUpPSGh3NGpJUGtBdHptRVFFVStFd2tKQUpPSkNiSmpCUVVRdHdjQllFVkhJNnJuQ0lWRlJVV1hBSUQvNTREQThyY0ZnRUFCUnBPRkJRQkZSWmNBZ1AvbmdNRHp0L2NBWUJGSG1NczNCUUlBbHdDQS8rZUFBUE8zRndsZ2lGK0JSYmVFZzBCeGlXRVZFelVWQUpjQWdQL25nSUNkd1dmOUZ4TUhBQkNGWmtGbXR3VUFBUUZGazRSRUFiY0tnMEFOYXBjQWdQL25nSUNURTR0S0FTYWFnNmZKQ1BYZmc2dkpDSVZISTZZSkNDTUM4UUtEeHhzQUNVY2pFK0VDb3dMeEFnTFVUVWRqZ2VjSVVVZGpqK2NHS1Vkam4rY0FnOGM3QUFQSEt3Q2lCOW1QRVVkamx1Y0FnNmVMQUp4RFB0UkZNYUZGU0JCMU5vUEhPd0FEeHlzQW9nZlpqeEZuUVFkamRQY0VFd1d3RFJrK0V3WEFEUUUrRXdYZ0RpazJqVGxCdDdjRmdFQUJScE9GaFFNVlJaY0FnUC9uZ01Ea053Y0FZRnhIRXdVQUFwUG5GeEJjeHpHM3lVY2pFL0VDVGJjRHh4c0EwVVpqNStZQ2hVWmo1dVlBQVV3VEJQQVBoYWg1RnhOMzl3L0pSdVBvNXY2M05vUkFDZ2VUaGthN05wY1lRd0tIa3dZSEE1UDI5ZzhSUnVOcDF2d1RCL2NDRTNmM0Q0MUdZK3ZtQ0xjMmhFQUtCNU9HQnNBMmx4aERBb2NUQjBBQ1k1am5FQUxVSFVRQlJhVTBBVVZWUFBFMjZUYWhSVWdRZlJUUlBIWDBBVXdCUkJOMTlBOXhQQk4xL0E5WlBIMDI0eDRFNm9QSEd3QkpSMk5vOXpBSlIrTjI5K3IxRjVQMzl3ODlSK05nOStvM040UkFpZ2NUQndmQnVwZWNRNEtIQlVTZDYzQVFnVVVCUlpmd2YvL25nQUJ4SGVIUlJXZ1FuVHdCUkRHb0JVU0I3NWZ3Zi8vbmdJQjFNelNnQUNtZ0lVZGpoZWNBQlVRQlRHRzNBNnlMQUFPa3l3Q3paNHdBMGdmMTkrL3d2NFY5OGNGc0lwejlISDE5TXdXTVFGWGNzM2VWQVpYandXd3pCWXhBWSthTUF2MThNd1dNUUZYUU1ZR1g4SC8vNTRBQWNsWDVacFQxdHpHQmwvQi8vK2VBQUhGVjhXcVUwYmRCZ1pmd2YvL25nRUJ3VWZrekJKUkJ3YmNoUitPSjUvQUJUQk1FQUF3eHQwRkh6YjlCUndWRTQ1em45b09seXdBRHBZc0E1VEt4djBGSEJVVGprdWYyQTZjTEFaRm5ZK3JuSG9PbFN3RURwWXNBNy9EL2dEVy9RVWNGUk9PUzUvU0Rwd3NCRVdkamF2Y2NBNmZMQUlPbFN3RURwWXNBTTRUbkF1L3diLzRqckFRQUl5U0tzREczQThjRUFHTURCeFFEcDRzQXdSY1RCQUFNWXhQM0FNQklBVWVUQnZBT1kwYjNBb1BIV3dBRHgwc0FBVXlpQjltUEE4ZHJBRUlIWFkrRHgzc0E0Z2ZaaitPQjl1WVRCQkFNcWIwemh1c0FBMGFHQVFVSHNZN2h0NFBIQkFEOXg5eEVZNTBIRk1CSUk0QUVBSDIxWVVkamx1Y0NnNmZMQVFPbml3R0Rwa3NCQTZZTEFZT2x5d0FEcFlzQWwvQi8vK2VBd0dBcWpETTBvQUFwdFFGTUJVUVJ0UkZIQlVUam11Zm10NWNBWUxSTFpYZDlGd1ZtK1k3UmpnT2xpd0MweS9SRGdVWDVqdEdPOU1QMFMvbU8wWTcweTdSRGRZOVJqN2pEbC9CLy8rZUFvR01wdlJQMzl3RGpGUWZxazl4SEFCT0Vpd0FCVEgxZDQzU2MyMGhFbC9CLy8rZUFJRWdZUkZSQUVFRDVqbU1IcHdFY1FoTkg5Lzk5ajltT0ZNSUZERUVFMmI4UlI2VzFRVWNGUk9PWDU5NkRwNHNBQTZkTEFTTW8rUUFqSnVrQWRidURKY2tBd1JlUjVZblBBVXdUQkdBTWlic0RKd2tCWTJiM0JoUDNOd0RqR1FmaUF5Z0pBUUZHQVVjekJlaEFzNGJsQUdOcDl3RGpCQWJTSXlpcEFDTW0yUUF4dXpPRzZ3QVFUaEVIa01JRlJ1bS9JVWNGUk9PUjU5Z0RKQWtCR2NBVEJJQU1JeWdKQUNNbUNRQXpOSUFBcGJNQlRCTUVJQXp0c1FGTUV3U0FETTJ4QVV3VEJKQU02YmtUQnlBTlk0UG5EQk1IUUEzam0rZTRBOFE3QUlQSEt3QWlCRjJNbC9CLy8rZUF3RVlEck1RQVFSUmpjNFFCSW96akNReTJ3RUJpbERHQW5FaGpWZkFBbkVSalcvUUs3L0N2eTNYZHlFQmlocE9GaXdHWDhILy81NERBUWdIRmt3ZEFETnpJM0VEaWw5ekEzRVN6aDRkQjNNU1g4SC8vNTRDZ1FTVzJDV1VUQlFWeEE2ekxBQU9raXdDWDhILy81NENnTXJjSEFHRFlTN2NHQUFIQkZwTlhSd0VTQjNXUHZZdlpqN09IaHdNQlJiUFZod0tYOEgvLzU0REFNeE1GZ0Q2WDhILy81NEJBTCttOGc2WkxBUU9tQ3dHRHBjc0FBNldMQU8vdzcvdlJ0SVBGT3dDRHh5c0FFNFdMQWFJRjNZM0JGZS93ajlWMXRPL3c3OFE5dndQRU93Q0R4eXNBRTR5TEFTSUVYWXpjUkVFVXplT1JSNFZMWS8rSENKTUhrQXpjeUVHMEE2Y05BQ0xRQlVpemgreEFQdGFESjRxd1kzUDBBQTFJUXNZNnhPL3diOEFpUnpKSU40V0RRT0tGZkJDVGhrb0JFQkFUQmNVQ2wvQi8vK2VBSURFM3Q0TkFrd2hIQVlKWEE2ZUlzSU9sRFFBZGpCMlBQcHl5VnlPazZMQ3FpNzZWSTZDOUFKT0hTZ0dkalFIRm9XZGpsL1VBV29YdjhDL0xJNkJ0QVFuRTNFU1p3K05QY1BkajN3c0Frd2R3REwyM2hVdTNQWVJBdDR5RFFKT05EYnVUakV3QjZiL2puUXVjM0VUamlnZWNrd2VBREttM2c2ZUxBT09UQjV6djhDL1RDV1VUQlFWeGwvQi8vK2VBb0J6djhLL09sL0IvLytlQTRDQlZzZ09reXdEakR3U1k3L0N2MEJNRmdENlg4SC8vNTRCQUd1L3dUOHdDbEZHeTcvRFB5L1pRWmxUV1ZFWlp0bGttV3BaYUJsdjJTMlpNMWt4R1RiWk5DV0dDZ0FBQSIsdGV4dF9zdGFydDoxMDgyMTMwNDMyLGRhdGE6IkZBQ0RRSElLZ0VEQ0NvQkFHZ3VBUU9nTGdFQlVESUJBQWd5QVFENEpnRUNrQzRCQTVBdUFRQzRMZ0VEdUNJQkFZZ3VBUU80SWdFQk1Db0JBa2dxQVFNSUtnRUFhQzRCQVhncUFRS0lKZ0VEU0NZQkFXZ3FBUUt3T2dFRENDb0JBYkEyQVFHUU9nRUF1Q0lCQWpBNkFRQzRJZ0VBdUNJQkFMZ2lBUUM0SWdFQXVDSUJBTGdpQVFDNElnRUF1Q0lCQUNBMkFRQzRJZ0VDS0RZQkFaQTZBUUE9PSIsZGF0YV9zdGFydDoxMDgyNDAzNzYwLGJzc19zdGFydDoxMDgyMzI3MDQwfX0pO3ZhciBVaT1tKChkRSxYbik9PntYbi5leHBvcnRzPXtlbnRyeToxMzQxMTk1OTE4LHRleHQ6IlFSRWl4Q2JDQnNhM0p3MVFFVWMzQlBWUDJNdTNKQTFRRXdRRUFOeEFrWXVSNTdKQUlrU1NSRUVCZ29DSVFCeEFFM1gxRDRLWDNiY0JFYmVuREZCT3hvT3Bod0JLeURjSjlVOG15bExFQnM0aXpMZWtERkI5V2hNSkNRREFUQk4wOUQ4TjRQSkFZa1FqcURRQlFrblNSTEpKSWtvRllZS0FpRUNESndrQUUzWDFENEtYZlJUakdVVC95YjhUQndBTWxFR3FoMk1ZNVFDRlI0WEdJNkFGQUhsVmdvQUZSMk9INWdBSlJtT054Z0I5VllLQVFnVVRCN0FOUVlWamxlY0NpVWVjd2ZXM2t3YkFEV01XMVFDWXdSTUZBQXlDZ0pNRzBBMTlWV09WMXdDWXdSTUZzQTJDZ0xjMTlrOUJFWk9GUmJvR3htRS9ZMFVGQnJjMzlrK1RoOGV4QTZjSENBUFdSd2dUZGZVUGt3WVdBTUlHd1lJamt0Y0lNcGNqQUtjQUE5ZEhDSkZuazRjSEJHTWU5d0kzdC9WUEV3ZkhzYUZudXBjRHBnY0l0L2IxVDdjMzlrK1RoOGV4azRiR3RXTWY1Z0FqcHNjSUk2RFhDQ09TQndnaG9QbFg0d2IxL0xKQVFRR0NnQ09tMXdnam9PY0kzYmMzMXdoUWZFdWRpL1gvTjhjSVVIeExuWXYxLzRLQVFSRUd4dDAzdDljSVVDT21Cd0kzQndBSW1NT1lRMzMveUZleVFCTkY5ZjhGaVVFQmdvQkJFUWJHMlQ5OTNUY0hBRUMzMXdoUW1NTTMxd2hRSEVQOS83SkFRUUdDZ0VFUklzUTNoUFZQa3djRUFVckFBNmtIQVFiR0pzSmpDZ2tFUlRjNXhiMUhFd1FFQVlGRVk5WW5BUVJFdllpVHRCUUFmVGVGUHh4RU53YUFBQk9YeHdDWjREY0dBQUczOXY4QWRZKzMxZ2hRMk1LUXdwaENmZjlCUjVIZ0JVY3pDZWxBdXBjaktDUUJITVN5UUNKRWtrUUNTVUVCZ29BQkVRYk9Jc3dsTnpjRTlFOXNBQk1GeFA2WEFNLy81NEFnODZxSEJVV1Y1N0pIay9jSElEN0dpVGMzMXdoUUhFZTNCa0FBRXdYRS90V1BITWV5UlpjQXovL25nS0R3TXpXZ0FQSkFZa1FGWVlLQVFSRzNoL1ZQQnNhVGh3Y0JCVWNqZ09jQUU5ZkZBSmpIQldkOUY4ekR5TWY1alRxVnFwV3hnWXpMSTZvSEFFRTNHY0VUQlZBTXNrQkJBWUtBQVJFaXpEZUU5VStUQndRQkpzckVSMDdHQnM1S3lLcUpFd1FFQVdQemxRQ3VoS25BQXlsRUFDYVpFMW5KQUJ4SVkxWHdBQnhFWTE3NUFyVTlmZDFJUUNhR3pvV1hBTS8vNTRDZzR4TjE5UThCeFpNSFFBeGN5RnhBcHBkY3dGeEVoWTljeFBKQVlrVFNSRUpKc2trRllZS0FhVFZ0djBFUkJzYVhBTS8vNTRCQTFnTkZoUUd5UUdrVkV6VVZBRUVCZ29CQkVRYkd4VGNSd1JsRnNrQkJBUmNEei85bkFPUFBRUkVHeGliQ0lzU3FoSmNBei8vbmdBRE5kVDhOeVRjSDlVK1RCZ2NBZzlkR0FCTUVCd0NGQjhJSHdZTWprdllBa3dZQURHT0cxQUFUQitBRFkzWDNBRzAzSXhJRUFMSkFJa1NTUkVFQmdvQkJFUWJHRXdjQURHTWE1UUFUQmJBTlJUY1RCY0FOc2tCQkFWbS9Fd2V3RGVNYjVmNXhOeE1GMEEzMXQwRVJJc1Ftd2diR0tvU3pCTFVBWXhlVUFMSkFJa1NTUkVFQmdvQURSUVFBQlFSTlArMjNOWEVteTA3SC9YS0ZhZjEwSXMxS3lWTEZWc01HejVPRWhQb1drWk9IQ1FlbWx4Z0lzNFRuQUNxSkpvVXVoSmNBei8vbmdPQVprNGNKQnhnSUJXcTZsN09LUjBFeDVBVm5mWFdUQllYNmt3Y0hCeE1GaGZrVUNLcVhNNFhYQUpNSEJ3ZXVsN09GMXdBcXhwY0F6Ly9uZ0tBV01rWEJSWlUzQVVXRlloYVIra0JxUk5wRVNrbTZTU3BLbWtvTllZS0Fvb2xqYzRvQWhXbE9odGFGU29XWEFNLy81NENneVJOMTlROEI3VTZHMW9VbWhaY0F6Ly9uZ09BUlRwa3pCRFJCVWJjVEJUQUdWYjhUQlFBTVNiMHhjZjF5QldkTzExTFZWdE5lendiZkl0MG0yMHJaV3RGaXpXYkxhc2x1eC8xM0ZwRVRCd2NIUHBjY0NMcVhQc1lqcWdmNHFva3VpcktLdG9zTk5aTUhBQUlad2JjSEFnQStoWmNBei8vbmdJQUtoV2RqNVZjVEJXUjllUk1KaWZxVEJ3UUh5cGNZQ0RPSjV3QktoWmNBei8vbmdBQUpmWHNURER2NWt3eUwrUk1IQkFlVEJ3UUhGQWhpbCthWGdVUXpETmNBczR6WEFGSk5ZM3hOQ1dQeHBBTkJxSmsvb29VSUFZMDF1VGNpaGd3QlNvV1hBTS8vNTREZ0JLS1pvcFJqOVVRRHM0ZWtRV1B4ZHdNekJKcEFZL09LQUZhRUlvWU1BVTZGbHdEUC8rZUE0TGdUZGZVUFZkMEN6QUZFZVYyTlRhTUpBUUJpaFpjQXovL25nS0NuZmZrRFJURUI1b1ZaUEdOUEJRRGo0bzMraFdlVGh3Y0hvcGNZQ0xxWDJwY2ppcWY0QlFUeHQrTVZwZjJSUitNRjlQWUZaMzExa3djSEI1TUZoZm9UQllYNUZBaXFsek9GMXdDVEJ3Y0hycGV6aGRjQUtzYVhBTS8vNTRBQSszRTlNa1hCUldVelVUM2RPYmNIQWdBWjRaTUhBQUkraFpjQXovL25nQUQ0aFdJV2tmcFFhbFRhVkVwWnVsa3FXcHBhQ2x2NlMycE0ya3hLVGJwTktXR0NnTGRYUVVrWmNaT0g5NFFCUlliZW90eW0yc3JZenRiUzFOYlMydERlenVMTTVzcnF5TzdHUHM2WEFNLy81NERnb0hreEJjVTNSOWhRdDJjUlVCTUhGNnFZenlPZ0J3QWpyQWNBbU5QWVQ3Y0dCQUJWajlqUEk2QUhBcmNIOVU4M04vWlBrNGNIQUJNSHg3b2hvQ09nQndDUkIrUHQ1LzdWTTVGRmFBakZPZkU3dDdmMVQ1T0h4N0VoWno2WEl5RDNDTGNIOFU4M0NmVlBrNGVIRGlNZytRQzNPZlpQS1RtVGljbXhFd2tKQUdNRkJSQzNadzFRRXdjUUFyalBoVVZGUlpjQXovL25nS0RtdHdYeFR3RkdrNFVGQUVWRmx3RFAvK2VBb09lM0p3MVFFVWVZeXpjRkFnQ1hBTS8vNTREZzVyY0hEbENJWDRGRnQ0VDFUM0dKWVJVVE5SVUFsd0RQLytlQVlLWEJaLzBYRXdjQUVJVm1RV2EzQlFBQkFVV1RoQVFCdHdyMVR3MXFsd0RQLytlQUlKc1Rpd29CSnBxRHA4a0k5ZCtEcThrSWhVY2pwZ2tJSXdMeEFvUEhHd0FKUnlNVDRRS2pBdkVDQXRSTlIyT0I1d2hSUjJPUDV3WXBSMk9mNXdDRHh6c0FBOGNyQUtJSDJZOFJSMk9XNXdDRHA0c0FuRU0rMU5FNW9VVklFTVUyZzhjN0FBUEhLd0NpQjltUEVXZEJCMk4wOXdRVEJiQU5xVFlUQmNBTmtUWVRCZUFPUFQ1ZE1VRzN0d1h4VHdGR2s0V0ZBeFZGbHdEUC8rZUFvTmczcHd4UVhFY1RCUUFDaytjWEVGekhNYmZKUnlNVDhRSk50d1BIR3dEUlJtUG41Z0tGUm1QbTVnQUJUQk1FOEErRnFIa1hFM2YzRDhsRzQram0vcmMyOWs4S0I1T0dCcnMybHhoREFvZVRCZ2NEay9iMkR4Rkc0Mm5XL0JNSDl3SVRkL2NQalVaajYrWUl0emIyVHdvSGs0Ykd2emFYR0VNQ2h4TUhRQUpqbCtjUUF0UWRSQUZGY1R3QlJlVTBBVEg5UHFGRlNCQjlGQ0UyZGZRQlRBRkVFM1gwRDhFOEUzWDhEK2swelRiakhnVHFnOGNiQUVsSFkydjNNQWxINDNiMzZ2VVhrL2YzRHoxSDQyRDM2amMzOWsrS0J4TUh4OEM2bDV4RGdvY0ZSSjNyY0JDQlJRRkZsL0RPLytlQW9IY2Q0ZEZGYUJCdE5BRkVNYWdGUklIdmwvRE8vK2VBSUgwek5LQUFLYUFoUjJPRjV3QUZSQUZNWWJjRHJJc0FBNlRMQUxObmpBRFNCL1gzMFRCbDljRnNJcHo5SEgxOU13V01RRjNjczNlVkFaWGp3V3d6Qll4QVkrYU1BdjE4TXdXTVFGM1FNWUdYOE03LzU0REFlVjM1WnBUMXR6R0JsL0RPLytlQXdIaGQ4V3FVMGJkQmdaZnd6di9uZ0FCNFdma3pCSlJCd2JjaFIrT0s1L0FCVEJNRUFBdzV0MEZIemI5QlJ3VkU0NTNuOW9PbHl3QURwWXNBT1R5NXYwRkhCVVRqaytmMkE2Y0xBWkZuWSs3bkhvT2xTd0VEcFlzQTcvQy9oejIvUVVjRlJPT1Q1L1NEcHdzQkVXZGpidmNjQTZmTEFJT2xTd0VEcFlzQU00VG5BdS93UDRVanJBUUFJeVNLc0RtM0E4Y0VBR01IQnhRRHA0c0F3UmNUQkFBTVl4UDNBTUJJQVVlVEJ2QU9ZMGIzQW9QSFd3QUR4MHNBQVV5aUI5bVBBOGRyQUVJSFhZK0R4M3NBNGdmWmorT0M5dVlUQkJBTXNiMHpodXNBQTBhR0FRVUhzWTdodDRQSEJBRDl5OXhFWTVFSEZzQklJNEFFQUVXOVlVZGpsdWNDZzZmTEFRT25pd0dEcGtzQkE2WUxBWU9seXdBRHBZc0FsL0RPLytlQWdHZ3FqRE0wb0FBeHRRRk1CVVFadFJGSEJVVGptK2ZtdHhjT1VQUmZaWGQ5RndWbStZN1JqZ09saXdDVGhRY0k5TitVUWZtTzBZNlV3Wk9GUndpVVFmbU8wWTZVd2JSZmdVVjFqMUdQdU4rWDhNNy81NEFnYXhHOUUvZjNBT01SQitxVDNFY0FFNFNMQUFGTWZWM2pjWnpiU0VTWDhNNy81NEFnVGhoRVZFQVFRUG1PWXdlbkFSeENFMGYzLzMyUDJZNFV3Z1VNUVFUWnZ4RkhoYlZCUndWRTQ1VG4zb09uaXdBRHAwc0JJeWI1QUNNazZRQmR1NE1saVFEQkY1SGxpYzhCVEJNRVlBeXhzd01ueVFCalp2Y0dFL2MzQU9NVkIrSURLTWtBQVVZQlJ6TUY2RUN6aHVVQVkybjNBT01CQnRJakpxa0FJeVRaQUJtN000YnJBQkJPRVFlUXdnVkc2YjhoUndWRTQ1N24xZ01reVFBWndCTUVnQXdqSmdrQUl5UUpBRE0wZ0FDTnN3Rk1Fd1FnRE5XeEFVd1RCSUFNOGJrQlRCTUVrQXpSdVJNSElBMWpnK2NNRXdkQURlT1k1N2dEeERzQWc4Y3JBQ0lFWFl5WDhNNy81NEFBVGdPc3hBQkJGR056aEFFaWpPTUdETGJBUUdLVU1ZQ2NTR05WOEFDY1JHTmI5QXJ2OE8vUmRkM0lRR0tHazRXTEFaZnd6di9uZ0FCS0FjV1RCMEFNM01qY1FPS1gzTURjUkxPSGgwSGN4SmZ3enYvbmdPQklEYllKWlJNRkJYRURyTXNBQTZTTEFKZnd6di9uZ0tBNHQ2Y01VTmhMdHdZQUFjRVdrMWRIQVJJSGRZKzlpOW1QczRlSEF3RkZzOVdIQXBmd3p2L25nQUE2RXdXQVBwZnd6di9uZ0VBMTBieURwa3NCQTZZTEFZT2x5d0FEcFlzQTcvRFAvbjI4ZzhVN0FJUEhLd0FUaFlzQm9nWGRqY0VWNy9EUDIxMjA3L0F2eXoyL0E4UTdBSVBIS3dBVGpJc0JJZ1Jkak54RVFSVE40NUZIaFV0ai80Y0lrd2VRRE56SXJid0RwdzBBSXRBRlNMT0g3RUErMW9NbmlyQmpjL1FBRFVoQ3hqckU3L0N2eGlKSE1rZzNoZlZQNG9WOEVKT0dDZ0VRRUJNRmhRS1g4TTcvNTRCZ056ZTM5VStUQ0FjQmdsY0RwNGl3ZzZVTkFCMk1IWTgrbkxKWEk2VG9zS3FMdnBVam9MMEFrNGNLQVoyTkFjV2haMk9YOVFCYWhlL3diOUVqb0cwQkNjVGNSSm5ENDA5dzkyUGZDd0NUQjNBTXZiZUZTN2M5OWsrM2pQVlBrNDNOdXBPTURBSHB2K09hQzV6Y1JPT0hCNXlUQjRBTXFiZURwNHNBNDVBSG5PL3dEOVlKWlJNRkJYR1g4TTcvNTRDZ0lwZnd6di9uZ0tBblRiSURwTXNBNHc0RW1PL3d6OU1UQllBK2wvRE8vK2VBZ0NBQ2xGbXk5bEJtVk5aVVJsbTJXU1phbGxvR1cvWkxaa3pXVEVaTnRrMEpZWUtBQUFBPSIsdGV4dF9zdGFydDoxMzQxMTk0MjQwLGRhdGE6IkVBRDFUd1lLOFU5V0N2RlByZ3J4VDRRTDhVL3dDL0ZQbmd2eFQ5UUk4VTlBQy9GUGdBdnhUOElLOFUrRUNQRlA5Z3J4VDRRSThVL2dDZkZQSmdyeFQxWUs4VSt1Q3ZGUDhnbnhUemdKOFU5b0NmRlA3Z254VDBBTzhVOVdDdkZQQ0EzeFR3QU84VS9FQi9GUEpBN3hUOFFIOFUvRUIvRlB4QWZ4VDhRSDhVL0VCL0ZQeEFmeFQ4UUg4VS9FQi9GUHBBenhUOFFIOFU4bURmRlBBQTd4VHc9PSIsZGF0YV9zdGFydDoxMzQxNTMzMTAwLGJzc19zdGFydDoxMzQxNDU2Mzg0fX0pO3ZhciBQaT1tKChTRSxWbik9PntWbi5leHBvcnRzPXtlbnRyeToxMDczOTA3NzE2LHRleHQ6IkNBQUFZQndBQUdCSUFQMC9FQUFBWURaQkFDSDcvOEFnQURnQ1Fmci93Q0FBS0FRZ0lKU2M0a0g0LzBZRUFBdzRNSWdCd0NBQXFBaUlCS0NnZE9BSUFBc2laZ0xvaHZUL0lmSC93Q0FBT1FJZDhBQUE3Q3YrUDJTci9UK0VnQUFBUUVBQUFLVHIvVC93Sy80L05rRUFzZm4vSUtCMEVCRWdKUWdCbGhvR2dmYi9rcUVCa0prUm1wakFJQUM0Q1pIei82Q2dkSnFJd0NBQWtoZ0FrSkQwRzhuQXdQVEFJQURDV0FDYW04QWdBS0pKQU1BZ0FKSVlBSUhxLzVDUTlJQ0E5SWVaUjRIbC81S2hBWkNaRVpxWXdDQUF5QW1oNWYreDQvK0huQmZHQVFCODZJY2Ezc1lJQU1BZ0FJa0t3Q0FBdVFsR0FnREFJQUM1Q3NBZ0FJa0prZGYvbW9nTUNjQWdBSkpZQUIzd0FBQlVJRUEvVkRCQVB6WkJBSkg5LzhBZ0FJZ0pnSUFrVmtqL2tmci93Q0FBaUFtQWdDUldTUDhkOEFBQUFDd2dRRDhBSUVBL0FBQUFDRFpCQUJBUklLWDgveUg2L3d3SXdDQUFnbUlBa2ZyL2dmai93Q0FBa21nQXdDQUFtQWhXZWYvQUlBQ0lBbnp5Z0NJd0lDQUVIZkFBQUFBQVFEWkJBQkFSSU9YNy94WnEvNEhzLzVINy84QWdBSkpvQU1BZ0FKZ0lWbm4vSGZBQUFGaUEvVC8vLy84QUJDQkFQelpCQUNIOC96aENGb01HRUJFZ1pmai9Gdm9GRFBnTUJEZW9EWmdpZ0prUWdxQUJrRWlEUUVCMEVCRWdKZnIvRUJFZ0pmUC9pQ0lNRzBDWUVaQ3JBY3dVZ0tzQnNlMy9zSmtRc2V6L3dDQUFrbXNBa2M3L3dDQUFvbWtBd0NBQXFBbFdldjhjQ1F3YVFKcURrRFBBbW9nNVFva2lIZkFBQUhEaStqOElJRUEvaEdJQlFLUmlBVUEyWVFBUUVTQmw3Zjh4K2YrOUFhMERnZnIvNEFnQVRRb01FdXpxaUFHU29nQ1FpQkNKQVJBUklPWHgvNUh5LzZDaUFjQWdBSWdKb0lnZ3dDQUFpUW00QWEwRGdlNy80QWdBb0NTREhmQUFBUDhQQUFBMlFRQ0J4ZjhNR1pKSUFEQ2NRWmtva2Z2L09SZ3BPREF3dEpvaUtqTXdQRUVNQWlsWU9VZ1FFU0FsK1A4dENvd2FJcURGSGZBQUFNeHhBVUEyUVFCQnR2OVlORkF6WXhaakJGZ1VXbE5RWEVGR0FRQVFFU0RsN1ArSVJLWVlCSWdraDZYdkVCRWdKZVgvRm1yL3FCVE5BNzBDZ2ZILzRBZ0FvS0IwakVwU29NUlNaQVZZRkRwVldSUllOREJWd0ZrMEhmQUErUHovUDBRQS9UOU1BUDAvQURJQlFPd3hBVUF3TXdGQU5tRUFmTWl0QW9lVExUSDMvOFlGQUtnRERCd1FzU0NCOS8vZ0NBQ0JLLytpQVFDSUNPQUlBS2dEZ2ZQLzRBZ0E1aHJjeGdvQUFBQm1BeVlNQTgwQkRDc3lZUUNCN3YvZ0NBQ1lBWUhvL3plWkRhZ0laaG9JTWViL3dDQUFva01BbVFnZDhFQUEvVDhBQVAwL2pERUJRRFpCQUNIOC80SGMvOGdDcUFpeCt2K0IrLy9nQ0FBTUNJa0NIZkJnTHdGQU5rRUFnZjcvNEFnQWdnb1lEQW1DeVA0TUVvQXBreDN3K0N2K1AvUXIvajhZQUV3L2pBQk1QLy96Ly84MlFRQVFFU0RsL1A4V1dnU2grUCtJQ3J6WWdmZi9tQWk4YWJIMi8zek13Q0FBaUF1UWtCVEFpQkNRaUNEQUlBQ0pDNGdLc2ZIL0REcGdxaEhBSUFDWUM2Q0lFS0h1LzZDWkVKQ0lJTUFnQUlrTEhmQW9Ld0ZBTmtFQUVCRWdaZmYvdkJxUjBmK0lDUnVvcVFtUjBQOE1Db3FaSWtrQWdzakJEQm1BcVlPZ2dIVE1pcUt2UUtvaUlKaVRqUGtRRVNBbDh2L0dBUUN0QW9Idi8rQUlBQjN3TmtFQW9xREFFQkVnNWZyL0hmQUFBRFpCQUlLZ3dLMENoNUlSb3FEYkVCRWdaZm4vb3FEY1JnUUFBQUFBZ3FEYmg1SUlFQkVnSmZqL29xRGRFQkVncGZmL0hmQTJRUUE2TXNZQ0FLSUNBQ0xDQVJBUklLWDcvemVTOEIzd0FBQUFiRklBUUl4eUFVQ01VZ0JBREZNQVFEWWhJYUxSRUlINi8rQUlBRVlMQUFBQURCUkFSQkZBUTJQTkJMMEJyUUtCOWYvZ0NBQ2dvSFQ4V3MwRUVMRWdvdEVRZ2ZILzRBZ0FTaUpBTThCV0EvMGlvZ3NRSXJBZ29pQ3kwUkNCN1AvZ0NBQ3RBaHdMRUJFZ3BmZi9MUU9HQUFBaW9HTWQ4QUFBUUNzQlFEWkJBQkFSSUNYbC80eTZnWWovaUFpTVNCQVJJQ1hpL3d3S2dmai80QWdBSGZBQUFJUXlBVUMwOFFCQWtESUJRTUR4QUVBMlFRQVFFU0RsNGYrc21qRmMvNHppcUFPQjkvL2dDQUNpb2dER0JnQUFBS0tpQUlIMC8rQUlBS2dEZ2ZQLzRBZ0FSZ1VBQUFBc0NveUNnZkQvNEFnQWhnRUFBSUhzLytBSUFCM3c4Q3NCUURaQklXS2hCOEJtRVJwbVdRWU1CV0xSRUswRlVtWWFFQkVnWmZuL0RCaEFpQkZIdUFKR1JBQ3RCb0cxLytBSUFJWXpBQUNTcEIxUWM4RGdtUkVhbVVCM1k0a0p6UWU5QVNDaUlJR3UvK0FJQUpLa0hlQ1pFUnFab0tCMGlBbU1pZ3dJZ21ZV2ZRaUdGUUNTcEIzZ21SRWFtWWtKRUJFZ3BlTC92UWV0QVJBUklDWG0veEFSSUtYaC84MEhFTEVnWUtZZ2daMy80QWdBa3FRZDRKa1JHcG1JQ1hBaWdIQlZnRGUxdEpLaEI4Q1pFUnFabUFtQWRjQ1h0d0pHM2YrRzUvOE1DSUpHYktLa0d4Q3FvSUhNLytBSUFGWUsvN0tpQzZJR2JCQzdzQkFSSUNXaUFQZnFFdlpIRDdLaURSQzdzSHE3b2tzQUczZUc4Zjk4NjdlYXdXWkhDSUltR2plNEFvZTFuQ0tpQ3hBaXNHQzJJSzBDZ1gzLzRBZ0FFQkVnSmRqL3JRSWNDeEFSSUtYYi94QVJJQ1hYL3d3YUVCRWdwZWYvSGZBQUFQMC9UMGhCU2Z3ci9qOXNnQUpBU0R3QlFEeURBa0FJQUFoZ0VJQUNRQXdBQUdBNFFFQS8vLzhBQUNpQlFEK01nQUFBRUVBQUFBQXMvajhRTFA0L2ZKQkFQLytQLy8rQWtFQS9oSkJBUDNpUVFEOVFBUDAvVkFEOVAxd3MvajhVQUFCZzhQLy9BUHdyL2o5WUFQMC9jSUQ5UDF6eUFFQ0kyQUJBMFBFQVFLVHhBRURVTWdGQVdESUJRS0RrQUVBRWNBRkFBSFVCUUlCSkFVRG9OUUZBN0RzQlFJQUFBVUNZSUFGQTdIQUJRR3h4QVVBTWNRRkFoQ2tCUUhoMkFVRGdkd0ZBbEhZQlFBQXdBRUJvQUFGQU5zRUFJY3ovREFvcG9ZSG0vK0FJQUJBUklHVzcveGJxQkRIei9rSHkvc0FnQUNnRFVmTCtLUVRBSUFBb0JXSHMvcUtnWkNrR1llNytZQ0lRWXFRQVlDSWd3Q0FBS1FXQjJQL2dDQUJJQkh6Q1FDSVFEQ1JBSWlEQUlBQXBBNFlCQUVrQ1N5TEdBUUFoc3Y4eHMvOE1CRGN5N1JBUklPWEIvd3hMb3NFb0VCRWdaY1gvSXFFQkVCRWdwY0QvUWZIOWtDSVJLaVRBSUFCSkFqR28veUhaL1RKaUFCQVJJQ1d5L3hZNkJpR2Qvc0dkL3FnQ0RDdUJuLzdnQ0FBTW5Ed0xEQXFCdXYvZ0NBQ3hudjhNREF5YWdiai80QWdBb3FJQWdUTC80QWdBc1puL3FBSlNvQUdCcy8vZ0NBQ29Bb0VwLytBSUFLZ0NnYkQvNEFnQU1aUC93Q0FBS0FOUUlpREFJQUFwQXdZS0FBQ3hqLy9OQ2d4YWdhYi80QWdBTVl6L1VxRUJ3Q0FBS0FNc0NsQWlJTUFnQUNrRGdSdi80QWdBZ2FILzRBZ0FJWVgvd0NBQUtBTE11aHpETUNJUUlzTDREQk1nbzRNTUM0R2EvK0FJQVBGKy93d2REQnl5b0FIaW9RQkEzUkVBekJHQXV3R2lvQUNCay8vZ0NBQWhlZjlSQ2Y0cVJHTFZLOFlXQUFBQUFNQWdBRElIQURBd2RCYnpCS0tpQU1BZ0FDSkhBSUg5L3VBSUFLS2ljY0NxRVlGKy8rQUlBSUdGLytBSUFIRm8vM3pvd0NBQU9BZWlyLytBTXhBUXFnSEFJQUE1QjRGKy8rQUlBSUYrLytBSUFLMENnWDMvNEFnQWNWRCt3Q0FBS0FRV3N2a01COEFnQURnRURCTEFJQUI1QkNKQkhDSURBUXdvZVlFaVFSMkNVUThjTjNjU0l4eEhkeElrWnBJbUlnTURjZ01DZ0NJUmNDSWdaa0lYS0NQQUlBQW9BaW1CeGdJQUFCd2loZ0FBQUF6Q0lsRVBFQkVnNWFUL3NxQUlvc0VjRUJFZ1phai9jZ01ESWdNQ2dIY1JJSGNnSVVEL0lDRDBkN0lhb3FEQUVCRWdKYVAvb3FEdUVCRWdwYUwvRUJFZ1phSC9CdGovSWdNQkhFZ25PRGYySWhzRzl3QWl3aThnSUhTMlFnSkdKZ0NCTXYrQUlxQW9BcUFDQUFBQUlzTCtJQ0IwSENnbnVBSkc3UUNCTFArQUlxQW9BcUFDQUlMQ01JQ0FkTFpZeElibkFDeEpEQWdpb01DWEZ3S0c1UUNKZ1F4eWZRaXRCeEFSSUtXYi82MEhFQkVnSlp2L0VCRWc1Wm4vRUJFZ1pabi9ESXVpd1J3TEloQVJJT1djLzFZeS9ZWXZBQXdTVmhjMXdzRVF2UWV0QjRFdS8rQUlBRllhTkxLZ0RLTEJFQkFSSUdXYS93YXVBQUFBREJKV3R6S0JKLy9nQ0FBR0t3QW1od1lNRW9iR0FBQUFlQ01vTXlDSElJQ0F0RmE0L2hBUklHVnQveXAzbkJxRzkvOEFvS3hCZ1J6LzRBZ0FWaHI5SXRMd0lLZkF6Q0lHbXdBQW9JRDBWaGoraGdRQW9LRDFpY0dCRlAvZ0NBQ0l3VmJLK29BaXdBd1lBSWdSSUtmQUp6amhoZ01Bb0t4QmdRdi80QWdBVnZyNEl0THdJS2ZBVnFMK1Jvb0FBQXdJSXFEQUpvY0NocWdBREFndENNYW1BQ2EzOVlaOEFBd1NKcmNDaHFBQXVET29JM0tnQUJBUklDV1IvNkFuZzhhYkFBd1pacmRkZUVNZ3FSRU1DQ0tnd25lNkFrYVpBTGhUcUNPU1lRNFFFU0FsWi8rWTRRd0NvSktEaGcwQURCbG10ekY0UXlDcEVRd0lJcURDZDdvQ1JvNEFLRE80VTZnaklIZUNtZUVRRVNBbFpQOGhWdjBNQ0pqaGlXSWkwaXQ1SXFDWWd5MEp4b0VBa1ZEOURBaWlDUUFpb01hSG1nSkdnQUNJSTNMSDhDS2d3SGVZQVNoWkRBaVNvTzlHQWdDS282SUtHQnVJb0prd2R5anljZ01GZ2dNRWdIY1JnSGNnZ2dNR0FJZ1JjSWdnY2dNSGdIY0JnSGNnY0puQWNxREJEQWlRSjVQR2JBQnhPUDBpb01hU0J3Q05DUlpaR3BnM0RBZ2lvTWlIR1FJR1pnQW9WNUpIQUVaaEFCeUpEQWdNRXBjWEFnWmhBUGh6NkdQWVU4aER1RE9vSXd3SGdiSCs0QWdBalFxZ0o0TUdXZ0FNRWlaSEFrWlZBSkdYL29HWC9zQWdBSGdKUUNJUmdIY1FJSGNncUNQQUlBQjVDWkdTL2d3THdDQUFlQW1BZHhBZ2R5REFJQUI1Q1pHTy9zQWdBSGdKZ0hjUUlIY2d3Q0FBZVFtUml2N0FJQUI0Q1lCM0VDQW5JTUFnQUNrSmdaWCs0QWdBQmg4QWNLQTBEQWdpb01DSEdnTEdQQUJ3dEVHTGszMEtmUHdHRGdBQXFEbVo0Ym5CeWRHQmhQN2dDQUNZNGJqQktDbUlHYWdKeU5HQWdoQW1BZzNBSUFEWUNpQXNNTkFpRUNDSUlNQWdBSWtLRzNlU3lSQzNOOFJHZ2Y5bVJ3TEdmLzhNQ0NLZ3dJWW1BQXdTSnJjQ3hpRUFJV2oraUZONEk0a0NJV2YrZVFJTUFnWWRBTEZqL2d3STJBc01HbkxIOEowSUxRalFLb053bXBNZ21SQWlvTWFIbVdEQlhmNk5DZWdNSXFESmR6NVRjUEFVSXFEQVZxOEVMUW1HQWdBQUtwT1lhVXNpbVFpZENpRCt3Q3FOZHpMdEZzblkrUXlKQzBaaC93QU1FbWFIRnlGTi9vZ0NqQmlDb01nTUIza0NJVW4rZVFJTUVvQW5nd3dJUmdFQUFBd0lJcUQvSUtCMGdtRU1FQkVnWldML2lNR0FvSFFRRVNDbFlmOFFFU0JsWVA5V0FyVWlBd0VjSnljM0h2WXlBb2JRL2lMQy9TQWdkQXozSjdjQ0JzMytjVGIrY0NLZ0tBS2dBZ0J5b05KM0VsOXlvTlIza2dJR0lRREd4ZjRBQUhnek9DTVFFU0FsVC8rTkNsWnFzS0tpY2NDcUVZbkJnVEQrNEFnQUlTaitrU24rd0NBQUtBS0l3U0MwTmNBaUVaQWlFQ0M3SUhDN2dxMElNTHZDZ1RiKzRBZ0FvcVBvZ1NUKzRBZ0FSckgrQUFEWVU4aER1RE9vSXhBUklHVnMvNGFzL3JJREF5SURBb0M3RVNDN0lMTEw4S0xER0JBUklPVTMvOGFsL2dBQUlnTURjZ01DZ0NJUmNDSWdnU1QrNEFnQWNaRDhJc0x3aURlQUltTVdVcWVJRjRxQ2dJeEJoZ0lBaWNFUUVTQWxJLytDSVF5U0p3U21HUVNZSjVlbzZSQVJJQ1ViL3hacS82Z1h6UUt5d3hpQkZQN2dDQUNNT2pLZ3hEbFhPQmNxTXprWE9EY2dJOEFwTjRFTy91QUlBSWFJL2dBQUlnTURnZ01DY3NNWWdDSVJPRFdBSWlBaXd2Qld3d24yVWdLR0pRQWlvTWxHS2dBeDdQMkJidnpvQXltUjRJakFpVUdJSnEwSmg3SUJERHFaNGFuUjZjRVFFU0JsR3YrbzBZSGovZWpCcVFHaDR2M2RDTDBId3NFazhzRVFpY0dCOWYzZ0NBQzRKczBLcUpHWTRhQzd3TGttb0NMQXVBT3FkNmhCaU1HcXV3d0t1UVBBcVlPQXU4Q2cwSFRNbXVMYmdLME40S21ERnVvQnJRaUp3Wm5oeWRFUUVTRGxKZitJd1pqaHlOR0pBMFlCQUFBQURCeWRESXl5T0RXTWM4QS9NY0F6d0phejlkYU1BQ0tneHlsVmhsUCtBRmFzbENnMUZsS1VJcURJeHZyL0tDTldvcE1RRVNBbFRQK2lvbkhBcWhHQnZQM2dDQUFRRVNBbE0vK0J6djNnQ0FCR1J2NEFLRE1XTXBFUUVTQ2xTZitpbytpQnMvM2dDQUFRRVNEbE1QL2dBZ0FHUHY0QUVCRWdKVEQvSGZBQUFEWkJBSjBDZ3FEQUtBT0htUS9NTWd3U2hnY0FEQUlwQTN6aWhnOEFKaElISmlJWWhnTUFBQUNDb051QUtTT0htU29NSWlrRGZQSkdDQUFBQUNLZzNDZVpDZ3dTS1FNdENBWUVBQUFBZ3FEZGZQS0htUVlNRWlrRElxRGJIZkFBQUE9PSIsdGV4dF9zdGFydDoxMDczOTA1NjY0LGRhdGE6IldBRDlQMHVMQWtEZGl3SkE4cEFDUUdhTUFrRCtpd0pBWm93Q1FNV01Ba0RlalFKQVVZNENRUG1OQWtEVmlnSkFkNDBDUU5DTkFrRG9qQUpBZEk0Q1FCQ05Ba0IwamdKQXk0c0NRQ3FNQWtCbWpBSkF4WXdDUU9PTEFrQVhpd0pBTjQ4Q1FLcVFBa0RxaVFKQTBaQUNRT3FKQWtEcWlRSkE2b2tDUU9xSkFrRHFpUUpBNm9rQ1FPcUpBa0RxaVFKQTFJNENRT3FKQWtESmp3SkFxcEFDUUE9PSIsZGF0YV9zdGFydDoxMDczNjIyMDEyLGJzc19zdGFydDoxMDczNTQ1MjE2fX0pO3ZhciBraT1tKChERSxxbik9Pntxbi5leHBvcnRzPXtlbnRyeToxMDc3MzgxNzYwLHRleHQ6IkZJQURZQUNBQTJCTUFNby9CSUFEWURaQkFJSDcvd3hKd0NBQW1RakdCQUFBZ2ZqL3dDQUFxQWlCOS8rZ29IU0lDT0FJQUNIMi84QWdBSWdDSitqaEhmQUFBQUFJQUFCZ0hBQUFZQkFBQUdBMlFRQWgvUC9BSUFBNEFrSDcvOEFnQUNnRUlDQ1VuT0pCNlA5R0JBQU1PRENJQWNBZ0FLZ0lpQVNnb0hUZ0NBQUxJbVlDNkliMC95SHgvOEFnQURrQ0hmQUFBUFFyeXo5c3E4by9oSUFBQUVCQUFBQ3M2OG8vK0N2TFB6WkJBTEg1L3lDZ2RCQVJJQ1U1QVpZYUJvSDIvNUtoQVpDWkVacVl3Q0FBdUFtUjgvK2dvSFNhaU1BZ0FKSVlBSkNROUJ2SndNRDB3Q0FBd2xnQW1wdkFJQUNpU1FEQUlBQ1NHQUNCNnYrUWtQU0FnUFNIbVVlQjVmK1NvUUdRbVJHYW1NQWdBTWdKb2VYL3NlUC9oNXdYeGdFQWZPaUhHdDdHQ0FEQUlBQ0pDc0FnQUxrSlJnSUF3Q0FBdVFyQUlBQ0pDWkhYLzVxSURBbkFJQUNTV0FBZDhBQUFWQ0FBWUZRd0FHQTJRUUNSL2YvQUlBQ0lDWUNBSkZaSS81SDYvOEFnQUlnSmdJQWtWa2ovSGZBQUFBQXNJQUJnQUNBQVlBQUFBQWcyUVFBUUVTQ2wvUDhoK3Y4TUNNQWdBSUppQUpINi80SDQvOEFnQUpKb0FNQWdBSmdJVm5uL3dDQUFpQUo4OG9BaU1DQWdCQjN3QUFBQUFFQTJRUUFRRVNEbCsvOFdhditCN1ArUisvL0FJQUNTYUFEQUlBQ1lDRlo1L3gzd0FBRG9DQUJBdUFnQVFEYUJBSUg5LytBSUFCd0dCZ3dBQUFCZ1ZFTU1DQXdhMEpVUkRJMDVNZTBDaVdHcFVabEJpU0dKRWRrQkxBOE16QXhMZ2ZMLzRBZ0FVRVRBV2pOYUl1WVV6UXdDSGZBQUFCUW9BRUEyUVFBZ29pQ0IvZi9nQ0FBZDhBQUFjT0w2UHdnZ0FHQzhDZ0JBeUFvQVFEWmhBQkFSSUdYdi96SDUvNzBCclFPQit2L2dDQUJOQ2d3UzdPcUlBWktpQUpDSUVJa0JFQkVnNWZQL2tmTC9vS0lCd0NBQWlBbWdpQ0RBSUFDSkNiZ0JyUU9CN3YvZ0NBQ2dKSU1kOEFBQVhJREtQLzhQQUFCb3E4by9Oa0VBZ2Z6L0RCbVNTQUF3bkVHWktKSDYvemtZS1Rnd01MU2FJaW96TUR4Qk9VZ3g5djhpb0FBeUF3QWlhQVVuRXdtQnYvL2dDQUJHQXdBQUVCRWdaZmIvTFFxTUdpS2d4UjN3QVAvLy93QUVJQUJnOUFnQVFBd0pBRUFBQ1FCQU5vRUFNZVQvS0VNV2doRVFFU0FsNXY4VytoQU0rQXdFSjZnTWlDTU1Fb0NBTklBa2t5QkFkQkFSSUNYby94QVJJT1hnL3lIYS95SUNBQll5Q3Fnamdldi9RQ29SRnZRRUp5ZzhnYUgvNEFnQWdlai80QWdBNkNNTUFnd2FxV0dwVVJ5UFFPNFJESTNDb05nTVd5bEJLVEVwSVNrUktRR0JsLy9nQ0FDQmxQL2dDQUNHQWdBQUFLQ2tJWUhiLytBSUFCd0tCaUFBQUFBbktEbUJqZi9nQ0FDQjFQL2dDQURvSXd3U0hJOUE3aEVNalN3TURGdXRBaWxoS1ZGSlFVa3hTU0ZKRVVrQmdZUC80QWdBZ1lILzRBZ0FSZ0VBZ2NuLzRBZ0FEQnFHRFFBQUtDTU1HVUFpRVpDSkFjd1VnSWtCa2IvL2tDSVFrYjcvd0NBQUlta0FJVnIvd0NBQWdtSUF3Q0FBaUFKV2VQOGNDZ3dTUUtLREtFT2dJc0FwUXlnanFpSXBJeDN3QUFBMmdRQ0JhZi9nQ0FBc0JvWVBBQUFBZ2EvLzRBZ0FZRlJEREFnTUd0Q1ZFZTBDcVdHcFVZbEJpVEdaSVRrUmlRRXNEd3lOd3FBU3NxQUVnVnovNEFnQWdWci80QWdBV2pOYUlsQkV3T1lVdngzd0FBQVVDZ0JBTm1FQVFZVC9XRFJRTTJNV1l3dFlGRnBUVUZ4QlJnRUFFQkVnWmViL2FFU21GZ1JvSkdlbDd4QVJJR1hNL3hacS8xRjYvMmdVVWdVQUZrVUdnVVgvNEFnQVlGQjBncUVBVUhqQWQ3TUl6UU85QXEwR2hnNEF6UWU5QXEwR1V0WC9FQkVnWmZUL09sVlFXRUVNQ1VZRkFBRENvUUNaQVJBUklPWHkvNWdCY3RjQkc1bVFrSFJncDRCd3NvQlhPZUZ3dzhBUUVTQWw4ZitCTHYvZ0NBQ0dCUUROQTcwQ3JRYUIxZi9nQ0FDZ29IU01TaUtneENKa0JTZ1VPaUlwRkNnME1DTEFLVFFkOEFCY0J3QkFOa0VBZ2Y3LzRBZ0FnZ29ZREFtQ3lQd01Fb0Fwa3gzd05rRUFnZmovNEFnQWdnb1lEQW1DeVAwTUVvQXBreDN3dlAvT1AwZ0F5ajlRQU1vL1FDWUFRRFFtQUVEUUpnQkFObUVBZk1pdEFvZVRMVEgzLzhZRkFBQ29Bd3djdlFHQjkvL2dDQUNCai82aUFRQ0lDT0FJQUtnRGdmUC80QWdBNWhyZHhnb0FBQUJtQXlZTUE4MEJEQ3N5WVFDQjd2L2dDQUNZQVlIby96ZVpEYWdJWmhvSU1lYi93Q0FBb2tNQW1RZ2Q4RVFBeWo4Q0FNby9LQ1lBUURaQkFDSDgvNEhjLzhnQ3FBaXgrditCKy8vZ0NBQU1DSWtDSGZDUUJnQkFOa0VBRUJFZ3BmUC9qTHFCOHYrSUNJeElFQkVncGZ6L0VCRWc1ZkQvRmlvQW9xQUVnZmIvNEFnQUhmQUFBTW8vU0FZQVFEWkJBQkFSSUdYdy8wMEt2RG94NVA4TUdZZ0REQW9iU0VrRE1lTC9pak9DeU1HQXFZTWlRd0NnUUhUTXFqS3ZRREF5Z0RDVWt4WnBCQkFSSU9YMi8wWVBBSzBDZ2U3LzRBZ0FFQkVnWmVyL3JNb3g2Zjg4NllJVEFCdUlnSUQwZ2xNQWh6a1BncTlBaWlJTUdpQ2trNkNnZEJhcUFBd0NFQkVnSmZYL0lsTUFIZkFBQURaQkFLS2d3QkFSSUNYMy94M3dBQUEyUVFDQ29NQ3RBb2VTRWFLZzJ4QVJJS1gxLzZLZzNFWUVBQUFBQUlLZzI0ZVNDQkFSSUdYMC82S2czUkFSSU9Yei94M3dOa0VBT2pMR0FnQUFvZ0lBR3lJUUVTQ2wrLzgza3ZFZDhBQUFBRndjQUVBZ0NnQkFhQndBUUhRY0FFQTJJU0dpMFJDQit2L2dDQUNHRHdBQVVkRCtEQlJBUkJHQ0JRQkFRMlBOQkwwQnJRS01tQkFSSUNXbS84WUJBQUFBZ2ZELzRBZ0FvS0IwL0RyTkJMMEJvdEVRZ2UzLzRBZ0FTaUpBTThCVzQvc2lvZ3NRSXJDdEFyTFJFSUhvLytBSUFLMENIQXNRRVNDbDl2OHRBNFlBQUNLZ1l4M3dBQUNJSmdCQWhCc0FRSlFtQUVDUUd3QkFOa0VBRUJFZ3Bkai9ySW9NRTBGbS8vQXpBWXl5cUFTQjl2L2dDQUN0QThZSkFLMERnZlQvNEFnQXFBU0I4Ly9nQ0FBR0NRQVFFU0RsMC84TUdQQ0lBU3dEb0lPRHJRZ1drZ0NCN1AvZ0NBQ0dBUUFBZ2VqLzRBZ0FIZkJnQmdCQU5rRWhZcVFkNEdZUkdtWlpCZ3dYVXFBQVl0RVFVS1VnUUhjUlVtWWFFQkVnNWZmL1I3Y0N4a0lBclFhQnQvL2dDQURHTHdDUmpQNVFjOENDQ1FCQWQyUE5CNzBCclFJV3FBQVFFU0JsbGYvR0FRQUFBSUd0LytBSUFLQ2dkSXlxREFpQ1poWjlDRVlTQUFBQUVCRWdwZVAvdlFldEFSQVJJQ1huL3hBUklLWGkvODBIRUxFZ1lLWWdnYUgvNEFnQWVpSjZWVGUxeUlLaEI4Q0lFWktrSFJxSTRKa1JpQWdhbVpnSmdIWEFsemVEeHVyL0RBaUNSbXlpcEJzUXFxQ0J6Ly9nQ0FCV0N2K3lvZ3VpQm13UXU3QVFFU0Nsc2dEMzZoTDJSdytTb2cwUW1iQjZtYUpKQUJ0M2h2SC9mT21YbXNGbVJ4S1NvUWVDSmhyQW1SRWFtWWtKTjdnQ2g3V0xJcUlMRUNLd3ZRYXRBb0dBLytBSUFCQVJJT1hZLzYwQ0hBc1FFU0JsM1A4UUVTRGwxLzhNR2hBUklPWG0veDN3QUFES1AwOUlRVW13Z0FCZ29UcllVSmlBQUdDNGdBQmdLakVkajdTQUFHRDhLOHMvcklBM1FKZ2dER0E4Z2pkQXJJVTNRQWdBQ0dDQUlReGdFSUEzUUJDQUEyQlFnRGRBREFBQVlEaEFBR0NjTE1zLy8vOEFBQ3lCQUdBUVFBQUFBQ3pMUHhBc3l6OThrQUJnLzQvLy80Q1FBR0NFa0FCZ2VKQUFZRlFBeWo5WUFNby9YQ3pMUHhRQUFHRHcvLzhBL0N2TFAxd0F5ajkwZ01vL2dBY0FRSGdiQUVDNEpnQkFaQ1lBUUhRZkFFRHNDZ0JBQkNBQVFGUUpBRUJRQ2dCQUFBWUFRQndwQUVBa0p3QkFDQ2dBUU9RR0FFQjBnUVJBbkFrQVFQd0pBRUFJQ2dCQXFBWUFRSVFKQUVCc0NRQkFrQWtBUUNnSUFFRFlCZ0JBTmdFQkljSC9EQW9pWVJDQjVmL2dDQUFRRVNEbHJQOFdpZ1F4dlA4aHZQOUJ2Zi9BSUFBcEF3d0N3Q0FBS1FUQUlBQXBBMUc1L3pHNS8yRzUvOEFnQURrRndDQUFPQVo4OUJCRUFVQXpJTUFnQURrR3dDQUFLUVdHQVFCSkFrc2lCZ0lBSWFqL01hLy9RcUFBTnpMc0VCRWdKY0QvREV1aXdVQVFFU0Nsdy84aW9RRVFFU0RsdnY4eFkvMlFJaEVxSThBZ0FEa0NRYVQvSVR2OVNRSVFFU0NscGY4dENoYjZCU0dhL3NHYi9xZ0NEQ3VCbmY3Z0NBQkJuUCt4bmY4Y0dnd013Q0FBcVFTQnQvL2dDQUFNR3ZDcUFZRWwvK0FJQUxHVy82Z0NEQldCc3YvZ0NBQ29Bb0VkLytBSUFLZ0NnYS8vNEFnQVFaRC93Q0FBS0FSUUlpREFJQUFwQklZV0FCQVJJR1dkLzZ5YVFZci9IQnF4aXYvQUlBQ2laQUFnd2lDQm9QL2dDQUFoaC84TVJBd2F3Q0FBU1FMd3FnSEdDQUFBQUxHRC84MEtERnFCbVAvZ0NBQkJnUDlTb1FIQUlBQW9CQ3dLVUNJZ3dDQUFLUVNCQXYvZ0NBQ0JrLy9nQ0FBaGVmL0FJQUFvQXN5NkhNUkFJaEFpd3ZnTUZDQ2tnd3dMZ1l6LzRBZ0FnWXYvNEFnQVhRcU1ta0dvL1F3U0lrUUFSaFFBSElZTUVtbEJZc0VncVdGcE1ha2hxUkdwQWYwSzdRb3BVUXlOd3FDZnNxQUVJS0lnZ1dyOTRBZ0FjZ0VpSEdoaXgrZGdZSFJudUFFdEJUeUdEQlYzTmdFTUJVR1UvVkFpSUNBZ2RDSkVBQmJpQUtGWi80RnkvK0FJQUlGYi9lQUlBUEZXL3d3ZERCd01HK0toQUVEZEVRRE1FV0M3QVF3S2dXci80QWdBTVlUOVl0TXJoaFlBd0NBQVVnY0FVRkIwRmhVRkRCcndxZ0hBSUFBaVJ3Q0J5ZjdnQ0FDaW9uSEFxaEdCWC8vZ0NBQ0JYdi9nQ0FCeFF2OTg2TUFnQUZnSGZQcUFWUkFRcWdIQUlBQlpCNEZZLytBSUFJRlgvK0FJQUNDaUlJRlcvK0FJQUhFbi9rSHAvTUFnQUNnRUZtTDVEQWZBSUFCWUJBd1N3Q0FBZVFRaVFUUWlCUUVNS0huaElrRTFnbEViSERkM0VpUWNSM2NTSVdhU0lTSUZBM0lGQW9BaUVYQWlJR1pDRWlnbHdDQUFLQUlwNFlZQkFBQUFIQ0lpVVJzUUVTQmxtZit5b0FpaXdUUVFFU0RsblAreUJRTWlCUUtBdXhFZ1N5QWhHZjhnSVBSSHNocWlvTUFRRVNDbGwvK2lvTzRRRVNBbGwvOFFFU0RsbGYrRzJQOGlCUUVjUnljM04vWWlHd1lKQVFBaXdpOGdJSFMyUWdJR0pRQnhDLzl3SXFBb0FxQUNBQUFpd3Y0Z0lIUWNKeWUzQWtiL0FIRUYvM0Fpb0NnQ29BSUFjc0l3Y0hCMHRsZkZodmtBTEVrTUJ5S2d3SmNVQW9iM0FIbmhESEt0QnhBUklHV1EvNjBIRUJFZzVZLy9FQkVnWlk3L0VCRWdKWTcvREl1aXdUUWl3djhRRVNCbGtmOVdJdjFHUUFBTUVsYWtPY0xCSUwwRXJRU0JDUC9nQ0FCV3FqZ2NTNkxCSUJBUklDV1AvNGJBQUF3U1ZuUTNnUUwvNEFnQW9DU0R4dG9BSm9RRURCTEcyQUFvSlhnMWNJSWdnSUMwVnRqK0VCRWdaVDcvZWlLc21nYjQvMEVOL2FDc1FZSUVBSXo0Z1NMOTRBZ0FSZ01BY3Rmd1JnTUFBQUNCOGY3Z0NBQVc2djRHN3Y5d29zRE1GOGFuQUtDQTlGYVkvRVlLQUVIKy9LQ2c5WUlFQUp3WWdSUDk0QWdBeGdNQWZQZ0FpQkdLZDhZQ0FJSGovdUFJQUJiSy9rYmYvd3dZQUlnUmNLTEFkempLaGdrQVFmRDhvS3hCZ2dRQWpPaUJCdjNnQ0FBR0F3QnkxL0FHQXdBQWdkWCs0QWdBRnZyK0J0TC9jS0xBVmlmOWhvc0FEQWNpb01BbWhBSUdxZ0FNQnkwSFJxZ0FKclQxQm40QURCSW10QUlHb2dDNE5hZ2xEQWNRRVNDbGdmK2dKNE9HblFBTUdXYTBYNGhGSUtrUkRBY2lvTUtIdWdJR213QzRWYWdsa21FV0VCRWdaVFQva2lFV29KZURSZzRBREJsbXREU0lSU0NwRVF3SElxRENoN29DUnBBQUtEVzRWYWdsSUhpQ2ttRVdFQkVnWlRIL0ljSDhEQWlTSVJhSllpTFNLM0ppQXFDWWd5MEpCb01Ba2J2OERBZWlDUUFpb01aM21nS0dnUUI0SmJMRThDS2d3TGVYQWlJcEJRd0hrcUR2UmdJQWVvV0NDQmdiZDRDWk1MY244b0lGQlhJRkJJQ0lFWENJSUhJRkJnQjNFWUIzSUlJRkI0Q0lBWENJSUlDWndJS2d3UXdIa0NpVHhtMEFnYVA4SXFER2tnZ0FmUWtXbVJxWU9Bd0hJcURJZHhrQ0JtY0FLRmlTU0FCR1lnQWNpUXdIREJLWEZBSUdZZ0Q0ZGVobDJGWElSYmcxcUNXQmV2N2dDQUFNQ0gwS29DaURCbHNBREJJbVJBSkdWZ0NSWC82QlgvN0FJQUI0Q1VBaUVZQjNFQ0IzSUtnbHdDQUFlUW1SV3Y0TUM4QWdBSGdKZ0hjUUlIY2d3Q0FBZVFtUlZ2N0FJQUI0Q1lCM0VDQjNJTUFnQUhrSmtWTCt3Q0FBZUFtQWR4QWdKeURBSUFBcENZRmIvdUFJQUFZZ0FBQkFrRFFNQnlLZ3dIY1pBb1k5QUVCRVFZdkZmUGhHRHdDb1BJSmhGWkpoRnNKaEZJRlUvdUFJQU1JaEZJSWhGU2dzZUJ5b0RKSWhGbkJ5RUNZQ0RjQWdBTmdLSUNndzBDSVFJSGNnd0NBQWVRb2JtY0xNRUVjNXZzWi8vMlpFQWtaKy93d0hJcURBaGlZQURCSW10QUxHSVFBaEwvNklWWGdsaVFJaEx2NTVBZ3dDQmgwQThTcitEQWZJRHd3WnNzVHdqUWN0QjdBcGs4Q0pneUNJRUNLZ3huZVlZS0VrL24wSTJBb2lvTW0zUFZPdzRCUWlvTUJXcmdRdENJWUNBQUFxaFlob1N5S0pCNDBKSU8zQUtueTNNdTBXYU5qcENua1B4bC8vREJKbWhCZ2hGUDZDSWdDTUdJS2d5QXdIZVFJaEVQNTVBZ3dTZ0NlRERBZEdBUUFBREFjaW9QOGdvSFFRRVNDbFV2OXdvSFFRRVNEbFVmOFFFU0NsVVA5VzhyQWlCUUVjSnljM0gvWXlBa2JBL2lMQy9TQWdkQXozSjdjQ3hyeitjZi85Y0NLZ0tBS2dBZ0FBY3FEU2R4SmZjcURVZDVJQ0JpRUFSclgrS0RWWUpSQVJJS1UwLzQwS1ZtcXNvcUp4d0tvUmdtRVZnUUQrNEFnQWNmSDlrZkg5d0NBQWVBZUNJUlZ3dERYQWR4R1FkeEJ3dXlBZ3U0S3RDRkM3d29ILy9lQUlBS0tqNklIMC9lQUlBTWFnL2dBQTJGWElSYmcxcUNVUUVTQWxYUDhHblA0QXNnVURJZ1VDZ0xzUklMc2dzc3Z3b3NVWUVCRWdKUi8vQnBYK0FDSUZBM0lGQW9BaUVYQWlJSUh0L2VBSUFISDcreUxDOElnM2dDSmpGaktqaUJlS2dvQ01RVVlEQUFBQWdtRVZFQkVncFFQL2dpRVZraWNFcGhrRmtpY0NsNmpuRUJFZ1plbitGbXIvcUJmTkFyTEZHSUhjL2VBSUFJdzZVcURFV1ZkWUZ5cFZXUmRZTnlBbHdDazNnZGI5NEFnQUJuZitBQUFpQlFPQ0JRSnl4UmlBSWhGWU00QWlJQ0xDOEZaRkN2WlNBb1luQUNLZ3lVWXNBRkd6L1lIWSs2Z0ZLZkdnaU1DSmdZZ21yUW1Ic2dFTU9wSmhGcUpoRkJBUklPWDYvcUloRklHcS9ha0I2QVdocWYzZENMMEh3c0U4OHNFZ2dtRVZnYno5NEFnQXVDYk5DcWp4a2lFV29MdkF1U2FnSXNDNEJhcDNxSUdDSVJXcXV3d0t1UVhBcVlPQXU4Q2cwSFRNaXVMYmdLME40S21EckNxdENJSmhGWkpoRnNKaEZCQVJJS1VNLzRJaEZaSWhGc0loRklrRkJnRUFBQXdjblF5TXNsZ3pqSFhBWHpIQVZjQ1dOZlhXZkFBaW9NY3BVd1pBL2xiY2p5Z3pGb0tQSXFESUJ2di9LQ1ZXMG80UUVTQmxJditpb25IQXFoR0JpZjNnQ0FDQmx2M2dDQUNHTlA0b05SYlNqQkFSSUdVZy82S2o2SUdDL2VBSUFPQUNBQVl1L2gzd0FBQUFOa0VBblFLQ29NQW9BNGVaRDh3eURCS0dCd0FNQWlrRGZPS0dEd0FtRWdjbUloaUdBd0FBQUlLZzI0QXBJNGVaS2d3aUtRTjg4a1lJQUFBQUlxRGNKNWtLREJJcEF5MElCZ1FBQUFDQ29OMTg4b2VaQmd3U0tRTWlvTnNkOEFBQSIsdGV4dF9zdGFydDoxMDc3Mzc5MDcyLGRhdGE6IlhBREtQMTZPTjBBemp6ZEFSNVEzUUwyUE4wQlRqemRBdlk4M1FCMlFOMEE2a1RkQXJKRTNRRldSTjBEcGpUZEEwSkEzUUN5Uk4wQkFrRGRBMEpFM1FHaVFOMERRa1RkQUlZODNRSDZQTjBDOWp6ZEFIWkEzUURtUE4wQXFqamRBa0pJM1FBMlVOMEFBalRkQUxaUTNRQUNOTjBBQWpUZEFBSTAzUUFDTk4wQUFqVGRBQUkwM1FBQ05OMEFBalRkQUtwSTNRQUNOTjBBbGt6ZEFEWlEzUUFRSW53QUFBQUFBQUFBWUFRUUlCUUFBQUFBQUFBQUlBUVFJQmdBQUFBQUFBQUFBQVFRSUlRQUFBQUFBSUFBQUVRUUkzQUFBQUFBQUlBQUFFUVFJREFBQUFBQUFJQUFBQVFRSUVnQUFBQUFBSUFBQUVTQW9EQUFRQVFBQSIsZGF0YV9zdGFydDoxMDcwMjc5Njc2LGJzc19zdGFydDoxMDcwMjAyODgwfX0pO3ZhciBPaT1tKChSRSwkbik9Pnskbi5leHBvcnRzPXtlbnRyeToxMDc0ODQzNjUyLHRleHQ6InFCQUFRQUgvLzBaekFBQUFrSUgvUHdnQi96K0FnQUFBaElBQUFFQkFBQUJJUWY4L2xJSC9Qekg1L3hMQjhDQWdkQUpoQTRYd0FUS3YvcFp5QTFIMC8wSDIvekgwL3lBZ2REQTFnRXBWd0NBQWFBTkNGUUJBTVBRYlEwQkE5TUFnQUVKVkFEbzJ3Q0FBSWtNQUloVUFNZXYvSUNEME41SS9JZWIvTWViL1Flbi9PakxBSUFCb0ExSG0veWVXRW9ZQUFBQUFBTUFnQUNrRXdDQUFXUU5HQWdEQUlBQlpCTUFnQUNrRE1kdi9PaUlNQThBZ0FESlNBQWd4RXNFUURmQUFvQTBBQUppQi96OEFnZjQvVDBoQlNhaXMveitrclA4L0tOQVFRRnpxRUVBTUFBQmcvLzhBQUFBUUFBQUFBQUVBQUFBQUFZeUFBQUFRUUFBQUFBRC8vd0JBQUFBQWdmNC9CSUgrUHhBbkFBQVVBQUJnLy84UEFLaXMvejhJZ2Y0L3VLei9Qd0NBQUFBNEtRQUFrSS8vUHdpRC96OFFnLzgvckt6L1A1eXYvejh3bmY4L2lLLy9QNWdiQUFBQUNBQUFZQWtBQUZBT0FBQlFFZ0FBUENrQUFMQ3MveiswclA4LzFLci9QenNwQUFEd2dmOC9ESy8vUDVDdS96K0FDd0FBRUs3L1A1Q3QvejhCQUFBQUFBQUFBTEFWQUFEeC93QUFtS3ovUDd3UEFFQ0lEd0JBcUE4QVFGZy9BRUJFUmdCQUxFd0FRSGhJQUVBQVNnQkF0RWtBUU13dUFFRFlPUUJBU044QVFKRGhBRUJNSmdCQWhFa0FRQ0c5LzVLaEVKQVJ3Q0poSXlLZ0FBSmhROEpoUXRKaFFlSmhRUEpoUHdIcC84QUFBQ0d6L3pHMC93d0VCZ0VBQUVrQ1N5STNNdmpGdGdFaW9Jd01ReW9oQmFrQnhiVUJJWDMvd1h2L01hei9LaXpBSUFESkFpR3Avd3dFT1FJeHFmOE1VZ0haLzhBQUFER24veUtoQWNBZ0FFZ0RJQ1Fnd0NBQUtRTWlvQ0FCMC8vQUFBQUIwdi9BQUFBQjB2L0FBQUJ4bnY5Um4vOUJuLzh4bi85aW9RQU1BZ0hOLzhBQUFDR2QvekZqL3lvandDQUFPQUlXYy8vQUlBRFlBZ3dEd0NBQU9RSU1FaUpCaENJTkFRd2tJa0dGUWxGRE1tRWlKcElKSERNM0VpQ0dDQUFBQUNJTkF6SU5Bb0FpRVRBaUlHWkNFU2d0d0NBQUtBSWlZU0lHQVFBY0lpSlJROFdwQVNLZ2hBeURHaUpGbkFFaURRTXlEUUtBSWhFd01pQWhnUDgzc2hNaW9NQUZsd0Vpb082RmxnRUZwd0ZHM1A4QUFDSU5BUXkwUjVJQ0Jwa0FKelJEWm1JQ3hzc0E5bklnWmpJQ2huRUE5a0lJWmlJQ3hsWUFSc29BWmtJQ0JvY0FabElDeHFzQWhzWUFKb0o1OW9JQ2hxc0FESlJIa2dLR2p3Qm1rZ0lHb3dBR3dBQWNKRWVTQWtaOEFDYzBKd3owUjVJQ2hqNEFKelFMRE5SSGtnS0dnd0RHdHdBQVpySUNSa3NBSEJSSGtnSkdXQUJHc3dCQ29ORkhFbWduTkJFY05FZVNBa1k0QUVLZzBFY1NUOGFzQUFCQ29OSkhrZ0tHTHdBeW9OTTNrZ0pHbkFWR3B3QXNRZ3dPSjVNQ0JuRUZSaXNBSXFBQWhZa0JJcUFBUllrQnhaa0JoWmtCSXFDRU1xQUlHaUlMek1XTEFWYmMvUXdPelE1R213QUF6Qk9HWmdWR2xRQW1nd0xHa3dBR1p3VUJhZi9BQUFENnpKd2l4bzhBQUFBZ0xFRUJadi9BQUFCV0VpUHkzL0R3TE1ETUw0WndCUUFnTVBSV0UvN2hMUCtHQXdBZ0lQVUJYdi9BQUFCVzBpRGcvOER3TE1EM1B1cUdBd0FnTEVFQlYvL0FBQUJXVWgveTMvRHdMTUJXci81R1lRVW1nNERHQVFBQUFHYXpBa2JkL3d3T3dxREFobmdBQUFCbXN3SkdTd1VHY2dBQXdxQUJKck1DQm5BQUlpMEVNUmovNHFBQXdxRENKN01DeG00QU9GMG9MWVYzQVVaREJRRENvQUVtc3dLR1pnQXlMUVFoRC8vaW9BRENvTUkzc2dKR1pRQW9QUXdjSU9PQ09GMG9MY1YwQVRINC9nd0VTV015MHl2cEl5REVnd1phQUFBaDlQNE1Ea0lDQU1LZ3h1ZVVBc1pZQU1oU0tDMHl3L0F3SXNCQ29NQWd4Sk1pelJoTkFtS2c3OFlCQUZJRUFCdEVVR1l3SUZUQU55WHhNZzBGVWcwRUlnMEdnRE1SQUNJUlVFTWdRRElnSWcwSERBNkFJZ0V3SWlBZ0pzQXlvTUVndzVPR1F3QUFBQ0hhL2d3T01nSUF3cURHNTVNQ3hqNEFPRExDb01qbkV3SUdQQURpUWdESVVnWTZBQnlDREE0TUhDY1RBZ1kzQUFZUUJXWkRBb1lXQlVZd0FEQWdOQXdPd3FEQTV4SUNoakFBTVBSQmkrM05Bbnp6eGd3QUtENHlZVEVCQXYvQUFBQklMaWdlWWk0QUlDUVFNaUV4SmdRT3dDQUFVaVlBUUVNd1VFUVFRQ0lnd0NBQUtRWWJ6T0xPRVBjOHlNYUIvMlpEQWthQS93YWkvMmF6QWdZQUJjWVdBQUFBWWNIK0RBNUlCZ3dWTXNQd0xRNUFKWU13WG9OUUloRENvTWJua2t0eHV2N3RBb2dId3FESk56ZytNRkFVd3FEQW9zMFlqTlVHREFCYUtpZ0NTMVVwQkV0RURCSlFtTUEzTmUwV1l0cEpCcGtIeG1mL1pvTUNodXdFREJ3TURzWUJBQUFBNHFBQXdxRC93Q0IwQldBQjRDQjB4VjhCUlhBQlZrekFJZzBCRFBNM0VqRW5NeFZtUWdJR3RnUm1ZZ0xHdWdRbU1nTEcrZjRHR1FBQUhDTTNrZ0lHc0FReW9OSTNFa1VjRXpjU0FrYnovc1lZQUNHVi91ZzkwaTBDQWNEK3dBQUFJWlArd0NBQU9BSWhrdjRnSXhEZ0lvTFFQU0FGakFFOUFpME1BYm4rd0FBQUlxUG9BYmIrd0FBQXh1UCtXRjFJVFRnOUlpMEN4V3NCQnVEK0FESU5BeUlOQW9BekVTQXpJRExEOENMTkdFVktBY2JaL2dBaURRTXlEUUtBSWhFd0lpQXhaLzRpd3ZBaVlTa29Nd3dVSU1TRHdNQjBqRXhTSVNuMlZRdlN6UmpTWVNRTUg4WjNCQUFpb01rcFU4YksvaUZ4L25HUS9ySWlBR0VzL29LZ0F5SW5BcEloS1lKaEo3REd3Q2M1QkF3YW9tRW5zbUUyQlRrQnNpRTJjV2YrVWlFa1lpRXBjRXZBeWtScVZRdUVVbUVsZ21Fcmh3UUN4azRFZDdzQ1JrMEVrVWorUEZPbzZWSXBFR0lwRlNocG9tRW9VbUVtWW1FcXlIbmlLUlQ0K1NlekFzYnVBekZWL2pBaW9DZ0NvQUlBTVR6K0RBNE1FdW1UNllNcDB5bWo0bUVtL1E3aVlTak5Eb1lHQUhJaEp3d1RjR0VFZk1SZ1E1TnRCRGxpWFF0eUlTU0c0QU1BQUlJaEpKSWhKU0VzL3BlNDJESUlBQnQ0T1lLR0JnQ2lJU2NNSXpCcUVIekZEQlJnUllOdEJEbGlYUXVHMUFOeUlTUlNJU1VoSWY1WHQ5dFNCd0Q0Z2xtU2dDOFJIUE5hSWtKaE1WSmhOTEpoTmh2WFJYZ0JEQk5DSVRGU0lUU3lJVFpXRWdFaW9DQWdWUkJXaFFEd0lEUWl3dmdnTllQdzlFR0wvd3dTWVNmK0FCOUFBRktoVnpZUEFBOUFRUENSREFid1lvTXdaaUNjSmd3ZmhnQUEwaUVrSVFiK0xFTTVZbDBMaHB3QVhRdTJQQ0FHRHdCeUlTZDh3M0JoQkF3U1lDT0RiUUlNTXdZV0FBQUFYUXZTSVNSR0FBRDlCb0loSlllOTJSdmRDeTBpQWdBQUhFQUFJcUdMekNEdUlMWTg1RzBQY2ZIOTRDQWtLYmNnSVVFcHgrRGpRY0xNL1ZZaUlNQWdKQ2M4S0VZUkFKSWhKM3pEa0dFRURCSmdJNE50QWd4VEllWDlPV0o5RFFhVkF3QUFBRjBMMGlFa1JnQUEvUWFpSVNXbnZkRWIzUXN0SWdJQUFCeEFBQ0toaTh3ZzdpREFJQ1FuUE9IQUlDUUFBa0RnNEpFaXIvZ2d6QkR5b0FBV25BYUdEQUFBQUhJaEozekRjR0VFREJKZ0k0TnRBZ3hqQnVmLzBpRWtYUXVDSVNXSHZlQWIzUXN0SWdJQUFCeEFBQ0toSU80Z2k4eTJqT1FoeGYzQ3pQajZNaUhjL1NvajRrSUE0T2hCaGd3QUFBQ1NJU2NNRTVCaEJIekVZRFNEYlFNTWM4YlUvOUloSkYwTG9pRWxJYmo5cDczZFFjLzlNZzBBK2lKS0lqSkNBQnZkRy8vMlR3S0czUDhoc1AxODlpTFNLZklTSENJU0hTQm1NR0JnOUdlZkJ3WWVBTkloSkYwTExITUdRQUMyakNGR0R3QUFjaUVuZk1Od1lRUU1FbUFqZzIwQ1BETUd1LzhBQUYwTDBpRWtSZ0FBL1FhQ0lTV0h2ZGtiM1FzdElnSUFBQnhBQUNLaGk4d2c3aUMyak9SdEQrQ1FkSkpoS09Eb1FjTE0rUDBHUmdJQVBFT0cwd0xTSVNSZEN5RmovU2UxNzZJaEtBdHZva1VBRzFVV2hnZFdyUGlHSEFBTWs4YktBbDBMMGlFa1JnQUEvUVloV2YwbnRlcEdCZ0J5SVNkOHczQmhCQXdTWUNPRGJRSXNZOGFZLzlJaEpMQmJJSUloSlllOTM1Rk8vZEJvd0ZBcHdHZXlBaUJpSUdlL0FXMFBUUWJRUFNCUUpTQlNZVFJpWVRXeVlUWUJzLzNBQUFCaUlUVlNJVFN5SVRacTNXcFZZRy9BVm1iNVJzOEMvUVltTWdqR0JBQUEwaUVrWFFzTW95Rm4vVGxpZlExR0ZnTUFBQXdQSmhJQ1JpQUFJcUVnSW1jUkxBUWhldjFDWnhJeW9BVlNZVFJpWVRWeVlUT3lZVFlCbmYzQUFBQnlJVE95SVRaaUlUVlNJVFE5QnlLZ2tFS2dDRUpEV0FzaUd6TldVdjhpb0hBTWt6Skg2QXNpRzNkV1V2OGNsSEtoV0pGTi9ReDRSZ0lBQUhvaW1pS0NRZ0F0QXhzeVI1UHhJV0w5TVdMOURJUUdBUUJDUWdBYklqZVM5MFpnQVNGZi9mb2lJZ0lBSnp3ZFJnOEFBQUNpSVNkOHc2QmhCQXdTWUNPRGJRSU1zd1pULzlJaEpGMExJVlQ5K2lKaUlTVm52ZHNiM1FzOU1nTUFBQnhBQURPaE1PNGdNZ0lBaTh3M1BPRWhUUDFCVFAzNklqSUNBQXdTQUJOQUFDS2hRRStnQ3lMZ0loQXd6TUFBQTBEZzRKRklCREVsL1Nva01EK2dJbU1SRy8vMlB3S0czdjhoUC8xQ29TQU1BMUpoTkxKaE5nRmYvY0FBQUgwTkRBOVNJVFN5SVRaR0ZRQUFBSUloSjN6RGdHRUVEQkpnSTROdEFnempCck1DY2lFa1hRdVNJU1dYdCtBYmR3c25JZ0lBQUJ4QUFDS2hJTzRnaTh5MlBPUWhLLzFCQ3YzNklpSUNBT0F3SkNwRUlTajl3c3o5S2lReVFnRGc0MEViL3lFRC9USWlFemMvMHh3ek1tSVQzUWR0RHdZY0FVd0VEQU1pd1VSU1lUUmlZVFd5WVRaeVlUTUJPLzNBQUFCeUlUT0I5Zndpb1dDQWg0SkJGdjBxS1BvaU1xQUFJc0lZZ21FeUFUTDl3QUFBZ2lFeUlSSDlRcVNBS2lqNklnd0RJc0lZQVN6OXdBQUFxTStDSVRMd0txQWlJaEdLLzZKaExTSmhMazBQVWlFMFlpRTFjaUV6c2lFMkJnUUFBQ0lQV0J2L0VDS2dNaUlSR3pNeVloRXlJUzVBTDhBM011WU1BaWtSS1FHdEFnd1Q0RU1Sa3NGRVN2bVlEMHBCS2lud0loRWJNeWtVbXFwbXMrVXgzdnc2SW93Uzlpb3JJYzc4UXFiUVFFZUNnc2hZS29naW9Md3FKSUpoTEF3SmZQTkNZVGtpWVRER1F3QUFYUXZTSVNSR0FBRDlCaXd6eHBnQUFLSWhMSUlLQUlKaE54YUlEaEFvb0hnQ0cvZjVBdjBJREFMd0loRWlZVGhDSVRod0lBUWlZUzhMLzBBaUlIQnhRVlpmL2d5bmh6YzdjSGdSa0hjZ0FIY1JjSEF4UWlFd2NtRXZEQnB4cnZ3QUdFQUFxcUVxaEhDSWtQRDZFWEtqLzRZQ0FBQkNJUytxSWtKWUFQcUlKN2Z5QmlBQWNpRTVJSUNVaW9laW9MQkJvZnlxaUVDSWtIS1lETXhuTWxnTWZRTXl3LzRnS1VHaG0venlwTERHQ2dBZ2dBU0FoOEJDSVRsODk0Q0hNSXFFOElpQW9JaVFjcGdNekhjeVdBd3djeUF5dy82Q0lUY0xpSUpoTjBJaE53eTRJQ0ZCaDVUSUlDQUVJSGZBZlBvaUlUbHdlakI2Y2lLa3NDcDNJWWI4SUhlUWtsY01RaUVzRzVrYlJFSmhMSEloTHBjWEFzYTkvNEloTFNZb0FzYVlBRWFCQUF6aXg3SUN4aThBa2lFbDBDbkFwaUlDQmlVQUladjg0RENVUVhYOEtpTkFJcEFpRWd3QU1oRXdJREdXOGdBd0tURVdFZ1VuUEFKR0l3QUdFZ0FBREtQSHMwS1JrUHg4K0FBRFFPQmdrV0JnQkNBb01Db21taUpBSXBBaWtnd2JjOVpDQml0alBRZG52TjBHQmdDaUlTZDh3NkJoQkF3U1lDT0RiUUljQThaMS90SWhKRjBMWWlFbFo3M2dJZzBBR3owQUhFQUFJcUVnN2lDTHpBemkzUVBITWdKRzIvK0dCd0FpRFFHTFBBQVRRQUF5b1NJTkFDdmRBQnhBQUNLaElDTWdJTzRnd3N3UUlXNzg0RENVWVVqOEtpTmdJcEF5RWd3QU14RXdJREdXb2dBd09URWdJSVJHQ1FBQUFJRmwvQXlrZlBjYk5BQUVRT0JBa1VCQUJDQW5NQ29raWlKZ0lwQWlrZ3hOQTVZaS9nQURRT0Rna1RETXdDSmhLQXp6SnlNVklUUDhjaUVvK2pJaFYvd2IveW9qY2tJQUJqUUFBSUloS0dhNEd0eC9IQW1TWVNnR0FRRFNJU1JkQ3h3VElTajhmUFk1WWdaQi9qRk0vQ29qSXNMd0lnSUFJbUVtSnp3ZEJnNEFvaUVuZk1PZ1lRUU1FbUFqZzIwQ0hDUEdOZjRBQU5JaEpGMExZaUVsWjczZUc5MExMU0lDQUhJaEpnQWNRQUFpb1l2TUlPNGdkenpoZ2lFbU1UbjhraUVvREJZQUdFQUFacUdhTXd0bU1zUHc0Q1lRWWdNQUFBaEE0T0NSS21ZaE12eUF6TUFxTHd3RFpya01NUVg4K2tNeEx2dzZORElEQUUwR1VtRTBZbUUxc21FMkFVSDh3QUFBWWlFMVVpRTBhdit5SVRhR0FBQUFEQTl4K3Z0Q0p4RmlKeEpxWkdlL0FvWjUvL2VXQjRZQ0FOSWhKRjBMSEZOR3lmOEE4UnI4SVJ2OFBROVNZVFJpWVRXeVlUWnlZVE1CTGZ6QUFBQnlJVE1oQlB3eUp4RkNKeEk2UHdFby9NQUFBTEloTm1JaE5WSWhOREhqK3lqREN5SXB3L0hoKzNqUDFtZTRoajRCWWlFbERPTFFOc0NtUXc5QnIvdFFOTUNtSXdKR1RRREdNUUlBeDdJQ1JpNEFwaU1DQmlVQVFkWDc0Q0NVUUNLUUloSzhBRElSTUNBeGxnSUJNQ2t4RmtJRkp6d0NoaVFBeGhJQUFBQU1vOGV6Ukh6NGtxU3dBQU5BNEdDUllHQUVJQ2d3S2lhYUlrQWlrQ0tTREJ0ejFvSUdLMk05QjJlODNZWUdBSEloSjN6RGNHRUVEQkpnSTROdEFoeHp4dFQ5QUFEU0lTUmRDNEloSlllOTNpSU5BQnM5QUJ4QUFDS2hJTzRnaTh3TTR0MER4eklDeHR2L0JnZ0FBQUFpRFFHTFBBQVRRQUF5b1NJTkFDdmRBQnhBQUNLaElDTWdJTzRnd3N3UVFhajc0Q0NVUUNLUUloSzhBQ0lSSVBBeGxvOEFJQ2t4OFBDRXhnZ0FES044OTJLa3NCc2pBQU5BNERDUk1EQUU4UGN3K3ZOcS8wRC9rUEtmREQwQ2xpLytBQUpBNE9DUklNekFJcUQvOTZJQ3hrQUFoZ0lBQUJ5REJ0TUEwaUVrWFFzaFl2c250ZS95UlFCdER4dFZSdXNBRE9MSE1oa3lEUUVpRFFDQU14RWdJeUFBSEVBQUlxRWc3aUFyM2NMTUVER0QrK0FnbEtvaU1DS1FJaElNQUNJUklEQXhJQ2t4MWhNQ0RLUWJKQUFFUU9CQWtVQkFCREE1TURvMFFYajdpak5BTTVBeWt3eE5BcGJ6L2YwREFBSkE0T0NSSU16QWQ0TjhZcUFPeHpZYVFnMEJJZzBBZ0VRUklDUWdBQnhBQUNLaElPNGcwczBDd3N3UVFXbjc0Q0NVcWlKQUlwQkNFZ3dBUkJGQUlERkFTVEhXRWdJTXBodEdBQVpBNEdDUllHQUVJQ2t3S2laaFh2dUtJbUFpa0NLU0RHMEVsdkw5TWtVQUFBUkE0T0NSUU16QWR3SUlHMVg5QWtZQ0FBQUFJa1VCSzFVR2MvL3dZSVJtOWdLR3N3QWlydjhxWmlGNisrQm1FV29pS0FJaVlTWWhlUHR5SVNacVl2Z0dGcGNGZHp3ZEJnNEFBQUNDSVNkOHc0QmhCQXdTWUNPRGJRSWNrd1piL2RJaEpGMExraUVsbDczZ0c5MExMU0lDQUtJaEpnQWNRQUFpb1l2TUlPNGdwenpoWWlFbURCSUFGa0FBSXFFTEl1QWlFR0RNd0FBR1FPRGdrU3IvRE9MSHNnSkdNQUJ5SVNYUUo4Q21JZ0tHSlFCQkxQdmdJSlJBSXBBaTBnOGlFZ3dBTWhFd0lER1c4Z0F3S1RFV01nVW5QQUpHSkFDR0VnQUFES1BIczBTUlQvdDgrQUFEUU9CZ2tXQmdCQ0FvTUNvbW1pSkFJcEFpa2d3YmM5YUNCaXRqUFFkbnZOMkdCZ0NDSVNkOHc0QmhCQXdTWUNPRGJRSWNvOFlyL1FBQTBpRWtYUXVTSVNXWHZkNGlEUUFiUFFBY1FBQWlvU0R1SUl2TURPTGRBOGN5QWtiYi93WUlBQUFBSWcwQml6d0FFMEFBTXFFaURRQXIzUUFjUUFBaW9TQWpJQ0R1SU1MTUVHSC8rdUFnbEdBaWtDTFNEeklTREFBekVUQWdNWmFDQURBNU1TQWdoTVlJQUlFayt3eWtmUGNiTkFBRVFPQkFrVUJBQkNBbk1Db2tpaUpnSXBBaWtneE5BNVlpL2dBRFFPRGdrVERNd0RFYSsrQWlFU296T0FNeVlTWXhHUHVpSVNZcUl5Z0NJbUVvRmdvR3B6d2VSZzRBY2lFbmZNTndZUVFNRW1BamcyMENITFBHOS93QUFBRFNJU1JkQzRJaEpZZTkzUnZkQ3kwaUFnQ1NJU1lBSEVBQUlxR0x6Q0R1SUpjODRhSWhKZ3dTQUJwQUFDS2hZaUVvQ3lMZ0loQXFaZ0FLUU9EZ2thRE13R0poS0hIaStvSWhLSEIxd0pJaEt6SGYrb0Fud0pBaUVEb2ljbUVxUFFVbnRRRTlBa0dXK3ZvemJRODN0RzBHRWdBaHdQb3NVemxpQm00QVBGTWh2ZnA5RFRsaURDWkdiQUJkQzlJaEpFWUFBUDBHSVl2Nko3WGhvaUVxWWlFb2NpRXJZQ3JBTWNuNmNDSVFLaU1pQWdBYnFpSkZBS0poS2h0VkMyOVdILzBHREFBQU1nSUFZc2I5TWtVQU1nSUJNa1VCTWdJQ095SXlSUUk3VmZZMjR4WUdBVElDQURKRkFHWW1CU0lDQVNKRkFXcFYvUWFpb0xCOCtZS2tzSEtoQUFhOS9pR2MraWl5QitJQ2hwYjh3Q0FrSnp3Z1JnOEFnaUVuZk1PQVlRUU1FbUFqZzIwQ0xBTUdyUHdBQUYwTDBpRWtSZ0FBL1FhU0lTV1h2ZGtiM1FzdElnSUFBQnhBQUNLaGk4d2c3aURBSUNRblBPSEFJQ1FBQWtEZzRKRjhnaURNRUgwTlJnRUFBQXQzd3N6NG9pRWtkN29DOW96eEliRDZNYkQ2VFF4U1lUUnlZVE95WVRaRmxBQUxJckloTm5JaE0xSWhOQ0R1RUF3UEZrd0doZ3dBQUFDQ0lTZDh3NEJoQkF3U1lDT0RiUUlza3dZUEFISWhKRjBMa2lFbGw3ZmdHM2NMSnlJQ0FBQWNRQUFpb1NEdUlJdk10b3prNERCMHdzejQ0T2hCaGdvQW9pRW5mTU9nWVFRTUVtQWpnMjBDTEtNaFgvbzVZb1lQQUFBQWNpRWtYUXRpSVNWbnQ5a3lCd0FiZDBGWitodi9LS1NBSWhFd0lpQXBwUFpQQjhiZC8zSWhKRjBMSVZMNkxDTTVZZ3dHaGdFQWNpRWtYUXQ4OWlZV0ZFc216R0pHQXdBTGQ4TE0rSUloSkhlNEF2YU04WUZJK2lGNCtqRjQrc2w0VFF4U1lUUmlZVFZ5WVRPQ1lUS3lZVGJGaFFDQ0lUS1NJU2lpSVNZTElwbm9raUVxNE9JUW9tZ1FjaUV6b2lFa1VpRTBzaUUyWWlFMStmamlhQlNTYUJXZzE4Q3d4Y0Q5QnBaV0RqRmwrdmpZTFF3RmZnRHc0UFJOQXZEdzlYME1ESGhpSVRXeUlUWkdKUUFBQUpJQ0FLSUNBdXJwa2dJQjZwbWE3dnIrNGdJRG1wcWEvNXFlNGdJRW12K2FudUlDQlpyL21wN2lBZ2FhLzVxZTRnSUhtdithN3VyL2l5STZra2M1d0VBalFiQWlzTENRWUVZQ0FBQXlBZ0FiSWpydTZ2OHFPYjBDUnpQdk1VZjZMUTVDWVRGaVlUVnlZVE9DWVRLeVlUWkZkUUF4UWZydEFpMFB4WFFBUWlFeGNpRXpzaUUyUUhmQWdpRXlRVHI2WWlFMS9RS01oeTBMc0RqQXh1Yi9BQUFBL3hFaEFmcnE3K25TL1FiY1Z2aWk4TzdBZk8vZzk0TkdBZ0FBQUFBTUROME04cS85TVMzNlVpRXBLQ05pSVNUUUlzRFFWY0RhWnRFSitpa2pPQTF4Q1BwU1lTbktVMWtOY0RYQURBSU1GZkFsZzJKaEpDQWdkRmFDQUVMVGdFQWxneGFTQU1IKytTME1CU2tBeVEyQ0lTbWNLSkhsK1NnNUZySUE4Qzh4OENMQTFpSUF4b1A3TXFESElkLzVsaThCakI5R1Mvb2gzUGt5SWdQTUU0WkkraktneURsU2hrYjZLQzJNRXNaRStpSG8rUUVVK3NBQUFBRVcrc0FBQUVaQStzZzl6QnlHUHZvaW8rZ0JEdnJBQUFEQURBREdPdnJpWVNJTWZFYU4rZ0VPK3NBQUFBd2NEQU1HQ0FBQXlDMzRQZkFzSUNBZ3RNd1N4cFQ2UmlmN01pMERJaTBDeFRJQU1xQUFEQndndzRQR0l2dDRmV2h0V0YxSVRUZzlLQzBNREFIMCtjQUFBTzBDREJMZ3dwT0dIdnNBQUFIdStjQUFBQXdNQmhqN0FDSEMrVWhkT0MxSkFpSEErVGtDQnZyL1FiNzVEQUk0Qk1LZ3lERENneWtFUWJyNVBRd01IQ2tFTU1LREJnejd4eklDeHZUOXh2djlBaUZEa3FFUXdpRkMwaUZCNGlGQThpRS9taEVOOEFBQUNBQUFZQndBQUdBQUFBQmdFQUFBWUNIOC94TEI4T2tCd0NBQTZBSUpNY2toMlJFaCtQL0FJQURJQXNEQWRKenMwWmI1UmdRQUFBQXg5UC9BSUFBb0F6Z05JQ0Iwd0FNQUM4eG1ET3FHOVA4aDcvOElNY0FnQU9rQ3lDSFlFZWdCRXNFUURmQUFBQUQ0QWdCZ0VBSUFZQUFDQUdBQUFBQUlJZnovd0NBQU9BSXdNQ1JXUS84aCtmOUIrdi9BSUFBNUFqSDMvOEFnQUVrRHdDQUFTQU5XZFAvQUlBQW9BZ3dUSUNBRU1DSXdEZkFBQUlBQUFBQUFRUC8vL3dBRUFnQmdFc0h3eVNIQmJQa0pNU2hNMlJFV2dnaEYrdjhXSWdnb1RBenpEQTBub3d3b0xEQWlFQXdUSU5PRDBOQjBFQkVnUmZqL0ZtTC9JZDcvTWU3L3dDQUFPUUxBSUFBeUlnQldZLzh4MS8vQUlBQW9BeUFnSkZaQy95Z3NNZVgvUUVJUklXSDUwREtESWVUL0lDUVFRZVQvd0NBQUtRUWh6Ly9BSUFBNUFzQWdBRGdDVm5QL0RCSWNBOUFqazkwQ0tFelFJc0FwVENnczJ0TFpMQWd4eUNIWUVSTEJFQTN3QUFBQVRFb0FRQkxCNE1saHdVSDUrVEg0UE9sQkNYSFpVZTBDOTdNQi9RTVdId1RZSE5yZjBOeEJCZ0VBQUFDRjh2OG9US1lTQkNnc0o2M3lSZTMvRnBML0tCeE5EejBPQWU3L3dBQUFJQ0IwakRJaW9NUXBYQ2djU0R6Nkl2QkV3Q2tjU1R3SWNjaGgyRkhvUWZneEVzRWdEZkFBQUFEL0R3QUFVU2I1RXNId0NURU1GRUpGQURCTVFVa2xRZnIvT1JVcE5UQXd0RW9pS2lNZ0xFRXBSUXdDSW1VRkFWZjV3QUFBQ0RFeW9NVWdJNU1Td1JBTjhBQUFBREE3QUVBU3dmQUpNVEtnd0RlU0VTS2cyd0g3LzhBQUFDS2czRVlFQUFBQUFES2cyemVTQ0FIMi84QUFBQ0tnM1FIMC84QUFBQWd4RXNFUURmQUFBQUFTd2ZESklka1JDVEhOQWpyU1JnSUFBQ0lNQU1MTUFjWDYvOWVjOHdJaEE4SWhBdGdSRXNFUURmQUFBRmdRQUFCd0VBQUFHSmdBUUJ4TEFFQTBtQUJBQUprQVFKSDcveExCNE1saDZVSDVNUWx4MlZHUUVjRHRBaUxSRU0wREFmWC93QUFBOGZiNGhnb0EzUXpIdndIZEQwME5QUUV0RGdIdy84QUFBQ0FnZFB4Q1RRMDlBU0xSRUFIcy84QUFBTkR1Z05ETXdGWWMvU0hsL3pMUkVCQWlnQUhuLzhBQUFDSGgveHdER2lJRjlmOHREQVlCQUFBQUlxQmprZDMvbWhFSWNjaGgyRkhvUWZneEVzRWdEZkFBRXNId0lxREFDVEVCdXYvQUFBQUlNUkxCRUEzd0FBQUFiQkFBQUdnUUFBQjBFQUFBZUJBQUFId1FBQUNBRUFBQWtCQUFBSmdQQUVDTU93QkFFc0hna2Z6LytUSDlBaUhHLzhsaDJWRUpjZWxCa0JIQUdpSTVBakh5L3l3Q0dqTkpBMEh3LzlMUkVCcEV3cUFBVW1RQXdtMGFBZkQvd0FBQVllci9JYno0R21ab0JtZXlBc1pKQUMwTkFiYi93QUFBSWJQL01lWC9La0VhTTBrRFJqNEFBQUJoci84eDMvOGFabWdHR2pQb0E4QW13T2V5QWlEaUlHSGQvejBCR21aWkJrME84QzhnQWFqL3dBQUFNZGovSUNCMEdqTllBNHl5REFSQ2JSYnRCTVlTQUFBQUFFSFIvK3IvR2tSWkJBWHgvejBPTFFHRjQvOUY4UDlORGowQjBDMGdBWnIvd0FBQVljbi82c3dhWmxnR0laUC9HaUlvQWllOHZESEMvMUFzd0Jvek9BTTNzZ0pHM2Y5RzZ2OUNvQUJDVFd3aHVmOFFJb0FCdi8vQUFBQldBdjlodWY4aURXd1Fab0E0QmtVSEFQZmlFZlpPRGtHeC94cEU2alFpUXdBYjdzYngvekt2L2plU3dTWk9LU0Y3LzlBOUlCQWlnQUYrLzhBQUFBWG8veUYyL3h3REdpSkYydjlGNS84c0FnR20rTUFBQUlZRkFHRngvMUl0R2hwbWFBWm50Y2hYUEFJRzJmL0c3LzhBa2FEL21oRUljY2hoMkZIb1FmZ3hFc0VnRGZCZEFrS2d3Q2dEUjVVT3pESU1Fb1lHQUF3Q0tRTjg0ZzN3SmhJRkppSVJ4Z3NBUXFEYkxRVkhsU2tNSWlrREJnZ0FJcURjSjVVSURCSXBBeTBFRGZBQVFxRGRmUEpIbFFzTUVpa0RJcURiRGZBQWZQSU44QUFBdGlNd2JRSlE5a0JBODBCSHRTbFFSTUFBRkVBQU02RU1BamMyQkRCbXdCc2k4Q0lSTURGQkMwUld4UDQzTmdFYklnM3dBSXlURGZBM05nd01FZzN3QUFBQUFBQkVTVll3REFJTjhMWWpLRkR5UUVEelFFZTFGMUJFd0FBVVFBQXpvVGN5QWpBaXdEQXhRVUxFLzFZRS96Y3lBakFpd0Ezd3pGTUFBQUJFU1ZZd0RBSU44QUFBQUFBVVFPYkVDU0F6Z1FBaW9RM3dBQUFBTXFFTUFnM3dBQT09Iix0ZXh0X3N0YXJ0OjEwNzQ4NDM2NDgsZGF0YToiQ0lIK1B3VUZCQUFDQXdjQUF3TUxBTlRYRUVBTDJCQkFPZGdRUU5iWUVFQ0Y1eEJBT3RrUVFKRFpFRURjMlJCQWhlY1FRS0xhRUVBZjJ4QkE0TnNRUUlYbkVFQ0Y1eEJBZU53UVFJWG5FRUJWM3hCQUhPQVFRRmZnRUVDRjV4QkFoZWNRUVBQZ0VFQ0Y1eEJBMitFUVFJSGlFRURBNHhCQWYrUVFRRkRsRUVDRjV4QkFoZWNRUUlYbkVFQ0Y1eEJBZnVZUVFJWG5FRUIwNXhCQXNOMFFRS25ZRUVEQzVSQkF5ZG9RUUJ2YUVFQ0Y1eEJBQ09jUVFFL25FRUNGNXhCQWhlY1FRSVhuRUVDRjV4QkFoZWNRUUlYbkVFQ0Y1eEJBaGVjUVFFTGFFRUIvMmhCQTJ1VVFRQUVBQUFBQ0FBQUFBd0FBQUFRQUFBQUZBQUFBQndBQUFBa0FBQUFOQUFBQUVRQUFBQmtBQUFBaEFBQUFNUUFBQUVFQUFBQmhBQUFBZ1FBQUFNRUFBQUFCQVFBQWdRRUFBQUVDQUFBQkF3QUFBUVFBQUFFR0FBQUJDQUFBQVF3QUFBRVFBQUFCR0FBQUFTQUFBQUV3QUFBQlFBQUFBV0FBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQkFBQUFBZ0FBQUFJQUFBQURBQUFBQXdBQUFBUUFBQUFFQUFBQUJRQUFBQVVBQUFBR0FBQUFCZ0FBQUFjQUFBQUhBQUFBQ0FBQUFBZ0FBQUFKQUFBQUNRQUFBQW9BQUFBS0FBQUFDd0FBQUFzQUFBQU1BQUFBREFBQUFBMEFBQUFOQUFBQUFBQUFBQUFBQUFBREFBQUFCQUFBQUFVQUFBQUdBQUFBQndBQUFBZ0FBQUFKQUFBQUNnQUFBQXNBQUFBTkFBQUFEd0FBQUJFQUFBQVRBQUFBRndBQUFCc0FBQUFmQUFBQUl3QUFBQ3NBQUFBekFBQUFPd0FBQUVNQUFBQlRBQUFBWXdBQUFITUFBQUNEQUFBQW93QUFBTU1BQUFEakFBQUFBZ0VBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUJBQUFBQVFBQUFBRUFBQUFCQUFBQUFnQUFBQUlBQUFBQ0FBQUFBZ0FBQUFNQUFBQURBQUFBQXdBQUFBTUFBQUFFQUFBQUJBQUFBQVFBQUFBRUFBQUFCUUFBQUFVQUFBQUZBQUFBQlFBQUFBQUFBQUFBQUFBQUFBQUFBQkFSRWdBSUJ3a0dDZ1VMQkF3RERRSU9BUThBQVFFQUFBRUFBQUFFQUFBQSIsZGF0YV9zdGFydDoxMDczNzIwNDg4LGJzc19zdGFydDoxMDczNjQzNzc2fX0pO3ZhciBPLEFBPUcoKCk9PntPPWNsYXNze2dldEVyYXNlU2l6ZShlLEEpe3JldHVybiBBfX19KTt2YXIgWWk9e307SihZaSx7RVNQMzJST006KCk9PnpBfSk7dmFyIHpBLE50PUcoKCk9PntBQSgpO3pBPWNsYXNzIGV4dGVuZHMgT3tjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5DSElQX05BTUU9IkVTUDMyIix0aGlzLklNQUdFX0NISVBfSUQ9MCx0aGlzLkVGVVNFX1JEX1JFR19CQVNFPTEwNzMwNjE4ODgsdGhpcy5EUl9SRUdfU1lTQ09OX0JBU0U9MTA3MzExMTA0MCx0aGlzLlVBUlRfQ0xLRElWX1JFRz0xMDcyOTU1NDEyLHRoaXMuVUFSVF9DTEtESVZfTUFTSz0xMDQ4NTc1LHRoaXMuVUFSVF9EQVRFX1JFR19BRERSPTE2MTA2MTI4NTYsdGhpcy5YVEFMX0NMS19ESVZJREVSPTEsdGhpcy5GTEFTSF9TSVpFUz17IjFNQiI6MCwiMk1CIjoxNiwiNE1CIjozMiwiOE1CIjo0OCwiMTZNQiI6NjR9LHRoaXMuRkxBU0hfV1JJVEVfU0laRT0xMDI0LHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQ9NDA5Nix0aGlzLlNQSV9SRUdfQkFTRT0xMDcyOTYzNTg0LHRoaXMuU1BJX1VTUl9PRkZTPTI4LHRoaXMuU1BJX1VTUjFfT0ZGUz0zMix0aGlzLlNQSV9VU1IyX09GRlM9MzYsdGhpcy5TUElfVzBfT0ZGUz0xMjgsdGhpcy5TUElfTU9TSV9ETEVOX09GRlM9NDAsdGhpcy5TUElfTUlTT19ETEVOX09GRlM9NDR9YXN5bmMgcmVhZEVmdXNlKGUsQSl7bGV0IGk9dGhpcy5FRlVTRV9SRF9SRUdfQkFTRSs0KkE7cmV0dXJuIGUuZGVidWcoIlJlYWQgZWZ1c2UgIitpKSxhd2FpdCBlLnJlYWRSZWcoaSl9YXN5bmMgZ2V0UGtnVmVyc2lvbihlKXtsZXQgQT1hd2FpdCB0aGlzLnJlYWRFZnVzZShlLDMpLGk9QT4+OSY3O3JldHVybiBpKz0oQT4+MiYxKTw8MyxpfWFzeW5jIGdldENoaXBSZXZpc2lvbihlKXtsZXQgQT1hd2FpdCB0aGlzLnJlYWRFZnVzZShlLDMpLGk9YXdhaXQgdGhpcy5yZWFkRWZ1c2UoZSw1KSxzPWF3YWl0IGUucmVhZFJlZyh0aGlzLkRSX1JFR19TWVNDT05fQkFTRSsxMjQpLGE9QT4+MTUmMSxuPWk+PjIwJjEsRT1zPj4zMSYxO3JldHVybiBhIT0wP24hPTA/RSE9MD8zOjI6MTowfWFzeW5jIGdldENoaXBEZXNjcmlwdGlvbihlKXtsZXQgQT1bIkVTUDMyLUQwV0RRNiIsIkVTUDMyLUQwV0QiLCJFU1AzMi1EMldEIiwiIiwiRVNQMzItVTRXREgiLCJFU1AzMi1QSUNPLUQ0IiwiRVNQMzItUElDTy1WMy0wMiJdLGk9IiIscz1hd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24oZSksYT1hd2FpdCB0aGlzLmdldENoaXBSZXZpc2lvbihlKSxuPWE9PTM7cmV0dXJuKGF3YWl0IHRoaXMucmVhZEVmdXNlKGUsMykmMSkhPTAmJihBWzBdPSJFU1AzMi1TMFdEUTYiLEFbMV09IkVTUDMyLVMwV0QiKSxuJiYoQVs1XT0iRVNQMzItUElDTy1WMyIpLHM+PTAmJnM8PTY/aT1BW3NdOmk9IlVua25vd24gRVNQMzIiLG4mJihzPT09MHx8cz09PTEpJiYoaSs9Ii1WMyIpLGkrIiAocmV2aXNpb24gIithKyIpIn1hc3luYyBnZXRDaGlwRmVhdHVyZXMoZSl7bGV0IEE9WyJXaS1GaSJdLGk9YXdhaXQgdGhpcy5yZWFkRWZ1c2UoZSwzKTsoaSYyKT09PTAmJkEucHVzaCgiIEJUIiksKGkmMSkhPT0wP0EucHVzaCgiIFNpbmdsZSBDb3JlIik6QS5wdXNoKCIgRHVhbCBDb3JlIiksKGkmODE5MikhPT0wJiYoKGkmNDA5NikhPT0wP0EucHVzaCgiIDE2ME1IeiIpOkEucHVzaCgiIDI0ME1IeiIpKTtsZXQgRT1hd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24oZSk7WzIsNCw1LDZdLmluZGV4T2YoRSkhPT0tMSYmQS5wdXNoKCIgRW1iZWRkZWQgRmxhc2giKSxFPT09NiYmQS5wdXNoKCIgRW1iZWRkZWQgUFNSQU0iKSwoYXdhaXQgdGhpcy5yZWFkRWZ1c2UoZSw0KT4+OCYzMSkhPT0wJiZBLnB1c2goIiBWUmVmIGNhbGlicmF0aW9uIGluIGVmdXNlIiksKGk+PjE0JjEpIT09MCYmQS5wdXNoKCIgQkxLMyBwYXJ0aWFsbHkgcmVzZXJ2ZWQiKTtsZXQgYz1hd2FpdCB0aGlzLnJlYWRFZnVzZShlLDYpJjMsZz1bIk5vbmUiLCIzLzQiLCJSZXBlYXQgKFVOU1VQUE9SVEVEKSIsIkludmFsaWQiXTtyZXR1cm4gQS5wdXNoKCIgQ29kaW5nIFNjaGVtZSAiK2dbY10pLEF9YXN5bmMgZ2V0Q3J5c3RhbEZyZXEoZSl7bGV0IEE9YXdhaXQgZS5yZWFkUmVnKHRoaXMuVUFSVF9DTEtESVZfUkVHKSZ0aGlzLlVBUlRfQ0xLRElWX01BU0ssaT1lLnRyYW5zcG9ydC5iYXVkcmF0ZSpBLzFlNi90aGlzLlhUQUxfQ0xLX0RJVklERVIscztyZXR1cm4gaT4zMz9zPTQwOnM9MjYsTWF0aC5hYnMocy1pKT4xJiZlLmluZm8oIldBUk5JTkc6IFVuc3VwcG9ydGVkIGNyeXN0YWwgaW4gdXNlIiksc31fZDJoKGUpe2xldCBBPSgrZSkudG9TdHJpbmcoMTYpO3JldHVybiBBLmxlbmd0aD09PTE/IjAiK0E6QX1hc3luYyByZWFkTWFjKGUpe2xldCBBPWF3YWl0IHRoaXMucmVhZEVmdXNlKGUsMSk7QT1BPj4+MDtsZXQgaT1hd2FpdCB0aGlzLnJlYWRFZnVzZShlLDIpO2k9aT4+PjA7bGV0IHM9bmV3IFVpbnQ4QXJyYXkoNik7cmV0dXJuIHNbMF09aT4+OCYyNTUsc1sxXT1pJjI1NSxzWzJdPUE+PjI0JjI1NSxzWzNdPUE+PjE2JjI1NSxzWzRdPUE+PjgmMjU1LHNbNV09QSYyNTUsdGhpcy5fZDJoKHNbMF0pKyI6Iit0aGlzLl9kMmgoc1sxXSkrIjoiK3RoaXMuX2QyaChzWzJdKSsiOiIrdGhpcy5fZDJoKHNbM10pKyI6Iit0aGlzLl9kMmgoc1s0XSkrIjoiK3RoaXMuX2QyaChzWzVdKX19fSk7dmFyIGJpPXt9O0ooYmkse0VTUDMyQzNST006KCk9PmpBfSk7dmFyIGpBLEp0PUcoKCk9PntBQSgpO2pBPWNsYXNzIGV4dGVuZHMgT3tjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5DSElQX05BTUU9IkVTUDMyLUMzIix0aGlzLklNQUdFX0NISVBfSUQ9NSx0aGlzLkVGVVNFX0JBU0U9MTYxMDY0NzU1Mix0aGlzLk1BQ19FRlVTRV9SRUc9dGhpcy5FRlVTRV9CQVNFKzY4LHRoaXMuVUFSVF9DTEtESVZfUkVHPTEwNzI5NTU0MTIsdGhpcy5VQVJUX0NMS0RJVl9NQVNLPTEwNDg1NzUsdGhpcy5VQVJUX0RBVEVfUkVHX0FERFI9MTYxMDYxMjg2MCx0aGlzLkZMQVNIX1dSSVRFX1NJWkU9MTAyNCx0aGlzLkJPT1RMT0FERVJfRkxBU0hfT0ZGU0VUPTAsdGhpcy5GTEFTSF9TSVpFUz17IjFNQiI6MCwiMk1CIjoxNiwiNE1CIjozMiwiOE1CIjo0OCwiMTZNQiI6NjR9LHRoaXMuU1BJX1JFR19CQVNFPTE2MTA2MjA5MjgsdGhpcy5TUElfVVNSX09GRlM9MjQsdGhpcy5TUElfVVNSMV9PRkZTPTI4LHRoaXMuU1BJX1VTUjJfT0ZGUz0zMix0aGlzLlNQSV9NT1NJX0RMRU5fT0ZGUz0zNix0aGlzLlNQSV9NSVNPX0RMRU5fT0ZGUz00MCx0aGlzLlNQSV9XMF9PRkZTPTg4fWFzeW5jIGdldFBrZ1ZlcnNpb24oZSl7bGV0IHM9dGhpcy5FRlVTRV9CQVNFKzY4KzEyO3JldHVybiBhd2FpdCBlLnJlYWRSZWcocyk+PjIxJjd9YXN5bmMgZ2V0Q2hpcFJldmlzaW9uKGUpe2xldCBBPXRoaXMuRUZVU0VfQkFTRSs2OCxpPTMscz0xOCxhPUErNCppO3JldHVybihhd2FpdCBlLnJlYWRSZWcoYSkmNzw8cyk+PnN9YXN5bmMgZ2V0TWlub3JDaGlwVmVyc2lvbihlKXtsZXQgaT10aGlzLkVGVVNFX0JBU0UrNjgrMjAscz1hd2FpdCBlLnJlYWRSZWcoaSk+PjIzJjEsbj10aGlzLkVGVVNFX0JBU0UrNjgrNCozLEU9YXdhaXQgZS5yZWFkUmVnKG4pPj4xOCY3O3JldHVybihzPDwzKStFfWFzeW5jIGdldE1ham9yQ2hpcFZlcnNpb24oZSl7bGV0IGk9dGhpcy5FRlVTRV9CQVNFKzY4KzIwO3JldHVybiBhd2FpdCBlLnJlYWRSZWcoaSk+PjI0JjN9YXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGUpe2xldCBBPXswOiJFU1AzMi1DMyAoUUZOMzIpIiwxOiJFU1A4Njg1IChRRk4yOCkiLDI6IkVTUDMyLUMzIEFaIChRRk4zMikiLDM6IkVTUDg2ODYgKFFGTjI0KSJ9LGk9YXdhaXQgdGhpcy5nZXRQa2dWZXJzaW9uKGUpLHM9YXdhaXQgdGhpcy5nZXRNYWpvckNoaXBWZXJzaW9uKGUpLGE9YXdhaXQgdGhpcy5nZXRNaW5vckNoaXBWZXJzaW9uKGUpO3JldHVybmAke0FbaV18fCJVbmtub3duIEVTUDMyLUMzIn0gKHJldmlzaW9uIHYke3N9LiR7YX0pYH1hc3luYyBnZXRGbGFzaENhcChlKXtsZXQgcz10aGlzLkVGVVNFX0JBU0UrNjgrMTI7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyhzKT4+MjcmN31hc3luYyBnZXRGbGFzaFZlbmRvcihlKXtsZXQgcz10aGlzLkVGVVNFX0JBU0UrNjgrMTYsbj1hd2FpdCBlLnJlYWRSZWcocyk+PjAmNztyZXR1cm57MToiWE1DIiwyOiJHRCIsMzoiRk0iLDQ6IlRUIiw1OiJaQklUIn1bbl18fCIifWFzeW5jIGdldENoaXBGZWF0dXJlcyhlKXtsZXQgQT1bIldpLUZpIiwiQkxFIl0saT17MDpudWxsLDE6IkVtYmVkZGVkIEZsYXNoIDRNQiIsMjoiRW1iZWRkZWQgRmxhc2ggMk1CIiwzOiJFbWJlZGRlZCBGbGFzaCAxTUIiLDQ6IkVtYmVkZGVkIEZsYXNoIDhNQiJ9LHM9YXdhaXQgdGhpcy5nZXRGbGFzaENhcChlKSxhPWF3YWl0IHRoaXMuZ2V0Rmxhc2hWZW5kb3IoZSksbj1pW3NdLEU9biE9PXZvaWQgMD9uOiJVbmtub3duIEVtYmVkZGVkIEZsYXNoIjtyZXR1cm4gbiE9PW51bGwmJkEucHVzaChgJHtFfSAoJHthfSlgKSxBfWFzeW5jIGdldENyeXN0YWxGcmVxKGUpe3JldHVybiA0MH1fZDJoKGUpe2xldCBBPSgrZSkudG9TdHJpbmcoMTYpO3JldHVybiBBLmxlbmd0aD09PTE/IjAiK0E6QX1hc3luYyByZWFkTWFjKGUpe2xldCBBPWF3YWl0IGUucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcpO0E9QT4+PjA7bGV0IGk9YXdhaXQgZS5yZWFkUmVnKHRoaXMuTUFDX0VGVVNFX1JFRys0KTtpPWk+Pj4wJjY1NTM1O2xldCBzPW5ldyBVaW50OEFycmF5KDYpO3JldHVybiBzWzBdPWk+PjgmMjU1LHNbMV09aSYyNTUsc1syXT1BPj4yNCYyNTUsc1szXT1BPj4xNiYyNTUsc1s0XT1BPj44JjI1NSxzWzVdPUEmMjU1LHRoaXMuX2QyaChzWzBdKSsiOiIrdGhpcy5fZDJoKHNbMV0pKyI6Iit0aGlzLl9kMmgoc1syXSkrIjoiK3RoaXMuX2QyaChzWzNdKSsiOiIrdGhpcy5fZDJoKHNbNF0pKyI6Iit0aGlzLl9kMmgoc1s1XSl9Z2V0RXJhc2VTaXplKGUsQSl7cmV0dXJuIEF9fX0pO3ZhciBHaT17fTtKKEdpLHtFU1AzMkMyUk9NOigpPT52dH0pO3ZhciB2dCxtaT1HKCgpPT57SnQoKTt2dD1jbGFzcyBleHRlbmRzIGpBe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLkNISVBfTkFNRT0iRVNQMzItQzIiLHRoaXMuSU1BR0VfQ0hJUF9JRD0xMix0aGlzLkVGVVNFX0JBU0U9MTYxMDY0NzU1Mix0aGlzLk1BQ19FRlVTRV9SRUc9dGhpcy5FRlVTRV9CQVNFKzY0LHRoaXMuVUFSVF9DTEtESVZfUkVHPTE2MTA2MTI3NTYsdGhpcy5VQVJUX0NMS0RJVl9NQVNLPTEwNDg1NzUsdGhpcy5VQVJUX0RBVEVfUkVHX0FERFI9MTYxMDYxMjg2MCx0aGlzLlhUQUxfQ0xLX0RJVklERVI9MSx0aGlzLkZMQVNIX1dSSVRFX1NJWkU9MTAyNCx0aGlzLkJPT1RMT0FERVJfRkxBU0hfT0ZGU0VUPTAsdGhpcy5GTEFTSF9TSVpFUz17IjFNQiI6MCwiMk1CIjoxNiwiNE1CIjozMiwiOE1CIjo0OCwiMTZNQiI6NjR9LHRoaXMuU1BJX1JFR19CQVNFPTE2MTA2MjA5MjgsdGhpcy5TUElfVVNSX09GRlM9MjQsdGhpcy5TUElfVVNSMV9PRkZTPTI4LHRoaXMuU1BJX1VTUjJfT0ZGUz0zMix0aGlzLlNQSV9NT1NJX0RMRU5fT0ZGUz0zNix0aGlzLlNQSV9NSVNPX0RMRU5fT0ZGUz00MCx0aGlzLlNQSV9XMF9PRkZTPTg4fWFzeW5jIGdldFBrZ1ZlcnNpb24oZSl7bGV0IHM9dGhpcy5FRlVTRV9CQVNFKzY0KzQ7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyhzKT4+MjImN31hc3luYyBnZXRDaGlwUmV2aXNpb24oZSl7bGV0IEE9dGhpcy5FRlVTRV9CQVNFKzY0LGk9MSxzPTIwLGE9QSs0Kmk7cmV0dXJuKGF3YWl0IGUucmVhZFJlZyhhKSYzPDxzKT4+c31hc3luYyBnZXRDaGlwRGVzY3JpcHRpb24oZSl7bGV0IEEsaT1hd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24oZSk7aT09PTB8fGk9PT0xP0E9IkVTUDMyLUMyIjpBPSJ1bmtub3duIEVTUDMyLUMyIjtsZXQgcz1hd2FpdCB0aGlzLmdldENoaXBSZXZpc2lvbihlKTtyZXR1cm4gQSs9IiAocmV2aXNpb24gIitzKyIpIixBfWFzeW5jIGdldENoaXBGZWF0dXJlcyhlKXtyZXR1cm5bIldpLUZpIiwiQkxFIl19YXN5bmMgZ2V0Q3J5c3RhbEZyZXEoZSl7bGV0IEE9YXdhaXQgZS5yZWFkUmVnKHRoaXMuVUFSVF9DTEtESVZfUkVHKSZ0aGlzLlVBUlRfQ0xLRElWX01BU0ssaT1lLnRyYW5zcG9ydC5iYXVkcmF0ZSpBLzFlNi90aGlzLlhUQUxfQ0xLX0RJVklERVIscztyZXR1cm4gaT4zMz9zPTQwOnM9MjYsTWF0aC5hYnMocy1pKT4xJiZlLmluZm8oIldBUk5JTkc6IFVuc3VwcG9ydGVkIGNyeXN0YWwgaW4gdXNlIiksc31hc3luYyBjaGFuZ2VCYXVkUmF0ZShlKXthd2FpdCB0aGlzLmdldENyeXN0YWxGcmVxKGUpPT09MjYmJmUuY2hhbmdlQmF1ZCgpfV9kMmgoZSl7bGV0IEE9KCtlKS50b1N0cmluZygxNik7cmV0dXJuIEEubGVuZ3RoPT09MT8iMCIrQTpBfWFzeW5jIHJlYWRNYWMoZSl7bGV0IEE9YXdhaXQgZS5yZWFkUmVnKHRoaXMuTUFDX0VGVVNFX1JFRyk7QT1BPj4+MDtsZXQgaT1hd2FpdCBlLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKzQpO2k9aT4+PjAmNjU1MzU7bGV0IHM9bmV3IFVpbnQ4QXJyYXkoNik7cmV0dXJuIHNbMF09aT4+OCYyNTUsc1sxXT1pJjI1NSxzWzJdPUE+PjI0JjI1NSxzWzNdPUE+PjE2JjI1NSxzWzRdPUE+PjgmMjU1LHNbNV09QSYyNTUsdGhpcy5fZDJoKHNbMF0pKyI6Iit0aGlzLl9kMmgoc1sxXSkrIjoiK3RoaXMuX2QyaChzWzJdKSsiOiIrdGhpcy5fZDJoKHNbM10pKyI6Iit0aGlzLl9kMmgoc1s0XSkrIjoiK3RoaXMuX2QyaChzWzVdKX1nZXRFcmFzZVNpemUoZSxBKXtyZXR1cm4gQX19fSk7dmFyIEtpPXt9O0ooS2kse0VTUDMyQzZST006KCk9PkJBfSk7dmFyIEJBLGh0PUcoKCk9PntBQSgpO0JBPWNsYXNzIGV4dGVuZHMgT3tjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5DSElQX05BTUU9IkVTUDMyLUM2Iix0aGlzLklNQUdFX0NISVBfSUQ9MTMsdGhpcy5FRlVTRV9CQVNFPTE2MTEzMzU2ODAsdGhpcy5FRlVTRV9CTE9DSzFfQUREUj10aGlzLkVGVVNFX0JBU0UrNjgsdGhpcy5NQUNfRUZVU0VfUkVHPXRoaXMuRUZVU0VfQkFTRSs2OCx0aGlzLlVBUlRfQ0xLRElWX1JFRz0xMDcyOTU1NDEyLHRoaXMuVUFSVF9DTEtESVZfTUFTSz0xMDQ4NTc1LHRoaXMuVUFSVF9EQVRFX1JFR19BRERSPTE2MTA2MTI4NjAsdGhpcy5GTEFTSF9XUklURV9TSVpFPTEwMjQsdGhpcy5CT09UTE9BREVSX0ZMQVNIX09GRlNFVD0wLHRoaXMuRkxBU0hfU0laRVM9eyIxTUIiOjAsIjJNQiI6MTYsIjRNQiI6MzIsIjhNQiI6NDgsIjE2TUIiOjY0fSx0aGlzLlNQSV9SRUdfQkFTRT0xNjEwNjIwOTI4LHRoaXMuU1BJX1VTUl9PRkZTPTI0LHRoaXMuU1BJX1VTUjFfT0ZGUz0yOCx0aGlzLlNQSV9VU1IyX09GRlM9MzIsdGhpcy5TUElfTU9TSV9ETEVOX09GRlM9MzYsdGhpcy5TUElfTUlTT19ETEVOX09GRlM9NDAsdGhpcy5TUElfVzBfT0ZGUz04OH1hc3luYyBnZXRQa2dWZXJzaW9uKGUpe2xldCBzPXRoaXMuRUZVU0VfQkFTRSs2OCsxMjtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKHMpPj4yMSY3fWFzeW5jIGdldENoaXBSZXZpc2lvbihlKXtsZXQgQT10aGlzLkVGVVNFX0JBU0UrNjgsaT0zLHM9MTgsYT1BKzQqaTtyZXR1cm4oYXdhaXQgZS5yZWFkUmVnKGEpJjc8PHMpPj5zfWFzeW5jIGdldENoaXBEZXNjcmlwdGlvbihlKXtsZXQgQTthd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24oZSk9PT0wP0E9IkVTUDMyLUM2IjpBPSJ1bmtub3duIEVTUDMyLUM2IjtsZXQgcz1hd2FpdCB0aGlzLmdldENoaXBSZXZpc2lvbihlKTtyZXR1cm4gQSs9IiAocmV2aXNpb24gIitzKyIpIixBfWFzeW5jIGdldENoaXBGZWF0dXJlcyhlKXtyZXR1cm5bIldpLUZpIDYiLCJCVCA1IiwiSUVFRTgwMi4xNS40Il19YXN5bmMgZ2V0Q3J5c3RhbEZyZXEoZSl7cmV0dXJuIDQwfV9kMmgoZSl7bGV0IEE9KCtlKS50b1N0cmluZygxNik7cmV0dXJuIEEubGVuZ3RoPT09MT8iMCIrQTpBfWFzeW5jIHJlYWRNYWMoZSl7bGV0IEE9YXdhaXQgZS5yZWFkUmVnKHRoaXMuTUFDX0VGVVNFX1JFRyk7QT1BPj4+MDtsZXQgaT1hd2FpdCBlLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKzQpO2k9aT4+PjAmNjU1MzU7bGV0IHM9bmV3IFVpbnQ4QXJyYXkoNik7cmV0dXJuIHNbMF09aT4+OCYyNTUsc1sxXT1pJjI1NSxzWzJdPUE+PjI0JjI1NSxzWzNdPUE+PjE2JjI1NSxzWzRdPUE+PjgmMjU1LHNbNV09QSYyNTUsdGhpcy5fZDJoKHNbMF0pKyI6Iit0aGlzLl9kMmgoc1sxXSkrIjoiK3RoaXMuX2QyaChzWzJdKSsiOiIrdGhpcy5fZDJoKHNbM10pKyI6Iit0aGlzLl9kMmgoc1s0XSkrIjoiK3RoaXMuX2QyaChzWzVdKX1nZXRFcmFzZVNpemUoZSxBKXtyZXR1cm4gQX19fSk7dmFyIExpPXt9O0ooTGkse0VTUDMyQzYxUk9NOigpPT5XdH0pO3ZhciBXdCxOaT1HKCgpPT57aHQoKTtXdD1jbGFzcyBleHRlbmRzIEJBe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLkNISVBfTkFNRT0iRVNQMzItQzYxIix0aGlzLklNQUdFX0NISVBfSUQ9MjAsdGhpcy5DSElQX0RFVEVDVF9NQUdJQ19WQUxVRT1bODcxMzc0OTU5LDYwNjE2NzE1MV0sdGhpcy5VQVJUX0RBVEVfUkVHX0FERFI9MTYxMDYxMjg2MCx0aGlzLkVGVVNFX0JBU0U9MTYxMTM1MjA2NCx0aGlzLkVGVVNFX0JMT0NLMV9BRERSPXRoaXMuRUZVU0VfQkFTRSs2OCx0aGlzLk1BQ19FRlVTRV9SRUc9dGhpcy5FRlVTRV9CQVNFKzY4LHRoaXMuRUZVU0VfUkRfUkVHX0JBU0U9dGhpcy5FRlVTRV9CQVNFKzQ4LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkwX1JFRz10aGlzLkVGVVNFX0JBU0UrNTIsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTBfU0hJRlQ9MCx0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9SRUc9dGhpcy5FRlVTRV9CQVNFKzUyLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkxX1NISUZUPTQsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTJfUkVHPXRoaXMuRUZVU0VfQkFTRSs1Mix0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9TSElGVD04LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1JFRz10aGlzLkVGVVNFX0JBU0UrNTIsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTNfU0hJRlQ9MTIsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfUkVHPXRoaXMuRUZVU0VfQkFTRSs1Mix0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNF9TSElGVD0xNix0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9SRUc9dGhpcy5FRlVTRV9CQVNFKzUyLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk1X1NISUZUPTIwLHRoaXMuRUZVU0VfRElTX0RPV05MT0FEX01BTlVBTF9FTkNSWVBUX1JFRz10aGlzLkVGVVNFX1JEX1JFR19CQVNFLHRoaXMuRUZVU0VfRElTX0RPV05MT0FEX01BTlVBTF9FTkNSWVBUPTE8PDIwLHRoaXMuRUZVU0VfU1BJX0JPT1RfQ1JZUFRfQ05UX1JFRz10aGlzLkVGVVNFX0JBU0UrNDgsdGhpcy5FRlVTRV9TUElfQk9PVF9DUllQVF9DTlRfTUFTSz03PDwyMyx0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX1JFRz10aGlzLkVGVVNFX0JBU0UrNTIsdGhpcy5FRlVTRV9TRUNVUkVfQk9PVF9FTl9NQVNLPTE8PDI2LHRoaXMuRkxBU0hfRlJFUVVFTkNZPXsiODBtIjoxNSwiNDBtIjowLCIyMG0iOjJ9LHRoaXMuTUVNT1JZX01BUD1bWzAsNjU1MzYsIlBBRERJTkciXSxbMTA5ODkwNzY0OCwxMTA3Mjk2MjU2LCJEUk9NIl0sWzEwODIxMzA0MzIsMTA4MjUyMzY0OCwiRFJBTSJdLFsxMDgyMTMwNDMyLDEwODI1MjM2NDgsIkJZVEVfQUNDRVNTSUJMRSJdLFsxMDc0MDQ4ZTMsMTA3NDA2OTUwNCwiRFJPTV9NQVNLIl0sWzEwNzM3NDE4MjQsMTA3NDA0OGUzLCJJUk9NX01BU0siXSxbMTA5MDUxOTA0MCwxMDk4OTA3NjQ4LCJJUk9NIl0sWzEwODIxMzA0MzIsMTA4MjUyMzY0OCwiSVJBTSJdLFsxMzQyMTc3MjgwLDEzNDIxOTM2NjQsIlJUQ19JUkFNIl0sWzEzNDIxNzcyODAsMTM0MjE5MzY2NCwiUlRDX0RSQU0iXSxbMTYxMTY1MzEyMCwxNjExNjYxMzEyLCJNRU1fSU5URVJOQUwyIl1dLHRoaXMuVUYyX0ZBTUlMWV9JRD0yMDEwNjY1MTU2LHRoaXMuRUZVU0VfTUFYX0tFWT01LHRoaXMuS0VZX1BVUlBPU0VTPXswOiJVU0VSL0VNUFRZIiwxOiJFQ0RTQV9LRVkiLDI6IlhUU19BRVNfMjU2X0tFWV8xIiwzOiJYVFNfQUVTXzI1Nl9LRVlfMiIsNDoiWFRTX0FFU18xMjhfS0VZIiw1OiJITUFDX0RPV05fQUxMIiw2OiJITUFDX0RPV05fSlRBRyIsNzoiSE1BQ19ET1dOX0RJR0lUQUxfU0lHTkFUVVJFIiw4OiJITUFDX1VQIiw5OiJTRUNVUkVfQk9PVF9ESUdFU1QwIiwxMDoiU0VDVVJFX0JPT1RfRElHRVNUMSIsMTE6IlNFQ1VSRV9CT09UX0RJR0VTVDIiLDEyOiJLTV9JTklUX0tFWSIsMTM6IlhUU19BRVNfMjU2X0tFWV8xX1BTUkFNIiwxNDoiWFRTX0FFU18yNTZfS0VZXzJfUFNSQU0iLDE1OiJYVFNfQUVTXzEyOF9LRVlfUFNSQU0ifX1hc3luYyBnZXRQa2dWZXJzaW9uKGUpe3JldHVybiBhd2FpdCBlLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUis4KT4+MjYmN31hc3luYyBnZXRNaW5vckNoaXBWZXJzaW9uKGUpe3JldHVybiBhd2FpdCBlLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUis4KT4+MCYxNX1hc3luYyBnZXRNYWpvckNoaXBWZXJzaW9uKGUpe3JldHVybiBhd2FpdCBlLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUis4KT4+NCYzfWFzeW5jIGdldENoaXBEZXNjcmlwdGlvbihlKXtsZXQgQT1hd2FpdCB0aGlzLmdldFBrZ1ZlcnNpb24oZSksaTtBPT09MD9pPSJFU1AzMi1DNjEiOmk9InVua25vd24gRVNQMzItQzYxIjtsZXQgcz1hd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24oZSksYT1hd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24oZSk7cmV0dXJuYCR7aX0gKHJldmlzaW9uIHYke3N9LiR7YX0pYH1hc3luYyBnZXRDaGlwRmVhdHVyZXMoZSl7cmV0dXJuWyJXaUZpIDYiLCJCVCA1Il19YXN5bmMgcmVhZE1hYyhlKXtsZXQgQT1hd2FpdCBlLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKTtBPUE+Pj4wO2xldCBpPWF3YWl0IGUucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcrNCk7aT1pPj4+MCY2NTUzNTtsZXQgcz1uZXcgVWludDhBcnJheSg2KTtyZXR1cm4gc1swXT1pPj44JjI1NSxzWzFdPWkmMjU1LHNbMl09QT4+MjQmMjU1LHNbM109QT4+MTYmMjU1LHNbNF09QT4+OCYyNTUsc1s1XT1BJjI1NSx0aGlzLl9kMmgoc1swXSkrIjoiK3RoaXMuX2QyaChzWzFdKSsiOiIrdGhpcy5fZDJoKHNbMl0pKyI6Iit0aGlzLl9kMmgoc1szXSkrIjoiK3RoaXMuX2QyaChzWzRdKSsiOiIrdGhpcy5fZDJoKHNbNV0pfX19KTt2YXIgSmk9e307SihKaSx7RVNQMzJDNVJPTTooKT0+enR9KTt2YXIgenQsdmk9RygoKT0+e2h0KCk7enQ9Y2xhc3MgZXh0ZW5kcyBCQXtjb25zdHJ1Y3Rvcigpe3N1cGVyKC4uLmFyZ3VtZW50cyksdGhpcy5DSElQX05BTUU9IkVTUDMyLUM1Iix0aGlzLklNQUdFX0NISVBfSUQ9MjMsdGhpcy5CT09UTE9BREVSX0ZMQVNIX09GRlNFVD04MTkyLHRoaXMuRUZVU0VfQkFTRT0xNjExMzUyMDY0LHRoaXMuRUZVU0VfQkxPQ0sxX0FERFI9dGhpcy5FRlVTRV9CQVNFKzY4LHRoaXMuTUFDX0VGVVNFX1JFRz10aGlzLkVGVVNFX0JBU0UrNjgsdGhpcy5VQVJUX0NMS0RJVl9SRUc9MTYxMDYxMjc1Nix0aGlzLkVGVVNFX1JEX1JFR19CQVNFPXRoaXMuRUZVU0VfQkFTRSs0OCx0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMF9SRUc9dGhpcy5FRlVTRV9CQVNFKzUyLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkwX1NISUZUPTI0LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkxX1JFRz10aGlzLkVGVVNFX0JBU0UrNTIsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTFfU0hJRlQ9MjgsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTJfUkVHPXRoaXMuRUZVU0VfQkFTRSs1Nix0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9TSElGVD0wLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1JFRz10aGlzLkVGVVNFX0JBU0UrNTYsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTNfU0hJRlQ9NCx0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNF9SRUc9dGhpcy5FRlVTRV9CQVNFKzU2LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk0X1NISUZUPTgsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTVfUkVHPXRoaXMuRUZVU0VfQkFTRSs1Nix0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9TSElGVD0xMix0aGlzLkVGVVNFX0RJU19ET1dOTE9BRF9NQU5VQUxfRU5DUllQVF9SRUc9dGhpcy5FRlVTRV9SRF9SRUdfQkFTRSx0aGlzLkVGVVNFX0RJU19ET1dOTE9BRF9NQU5VQUxfRU5DUllQVD0xPDwyMCx0aGlzLkVGVVNFX1NQSV9CT09UX0NSWVBUX0NOVF9SRUc9dGhpcy5FRlVTRV9CQVNFKzUyLHRoaXMuRUZVU0VfU1BJX0JPT1RfQ1JZUFRfQ05UX01BU0s9Nzw8MTgsdGhpcy5FRlVTRV9TRUNVUkVfQk9PVF9FTl9SRUc9dGhpcy5FRlVTRV9CQVNFKzU2LHRoaXMuRUZVU0VfU0VDVVJFX0JPT1RfRU5fTUFTSz0xPDwyMCx0aGlzLklST01fTUFQX1NUQVJUPTExMDcyOTYyNTYsdGhpcy5JUk9NX01BUF9FTkQ9MTExNTY4NDg2NCx0aGlzLkRST01fTUFQX1NUQVJUPTExMTU2ODQ4NjQsdGhpcy5EUk9NX01BUF9FTkQ9MTEyNDA3MzQ3Mix0aGlzLlBDUl9TWVNDTEtfQ09ORl9SRUc9MTYxMTIyNzQwOCx0aGlzLlBDUl9TWVNDTEtfWFRBTF9GUkVRX1Y9MTI3PDwyNCx0aGlzLlBDUl9TWVNDTEtfWFRBTF9GUkVRX1M9MjQsdGhpcy5YVEFMX0NMS19ESVZJREVSPTEsdGhpcy5VQVJUREVWX0JVRl9OTz0xMDgyNTIwODYwLHRoaXMuQ0hJUF9ERVRFQ1RfTUFHSUNfVkFMVUU9WzI4NTI5NDcwMywxNjc1NzA2NDc5LDE2MDc1NDkwMzldLHRoaXMuRkxBU0hfRlJFUVVFTkNZPXsiODBtIjoxNSwiNDBtIjowLCIyMG0iOjJ9LHRoaXMuTUVNT1JZX01BUD1bWzAsNjU1MzYsIlBBRERJTkciXSxbMTExNTY4NDg2NCwxMTI0MDczNDcyLCJEUk9NIl0sWzEwODIxMzA0MzIsMTA4MjUyMzY0OCwiRFJBTSJdLFsxMDgyMTMwNDMyLDEwODI1MjM2NDgsIkJZVEVfQUNDRVNTSUJMRSJdLFsxMDczOTc5MzkyLDEwNzQwMDM5NjgsIkRST01fTUFTSyJdLFsxMDczNzQxODI0LDEwNzM5NzkzOTIsIklST01fTUFTSyJdLFsxMTA3Mjk2MjU2LDExMTU2ODQ4NjQsIklST00iXSxbMTA4MjEzMDQzMiwxMDgyNTIzNjQ4LCJJUkFNIl0sWzEzNDIxNzcyODAsMTM0MjE5MzY2NCwiUlRDX0lSQU0iXSxbMTM0MjE3NzI4MCwxMzQyMTkzNjY0LCJSVENfRFJBTSJdLFsxNjExNjUzMTIwLDE2MTE2NjEzMTIsIk1FTV9JTlRFUk5BTDIiXV0sdGhpcy5VRjJfRkFNSUxZX0lEPTQxNDU4MDgxOTUsdGhpcy5FRlVTRV9NQVhfS0VZPTUsdGhpcy5LRVlfUFVSUE9TRVM9ezA6IlVTRVIvRU1QVFkiLDE6IkVDRFNBX0tFWSIsMjoiWFRTX0FFU18yNTZfS0VZXzEiLDM6IlhUU19BRVNfMjU2X0tFWV8yIiw0OiJYVFNfQUVTXzEyOF9LRVkiLDU6IkhNQUNfRE9XTl9BTEwiLDY6IkhNQUNfRE9XTl9KVEFHIiw3OiJITUFDX0RPV05fRElHSVRBTF9TSUdOQVRVUkUiLDg6IkhNQUNfVVAiLDk6IlNFQ1VSRV9CT09UX0RJR0VTVDAiLDEwOiJTRUNVUkVfQk9PVF9ESUdFU1QxIiwxMToiU0VDVVJFX0JPT1RfRElHRVNUMiIsMTI6IktNX0lOSVRfS0VZIn19YXN5bmMgZ2V0UGtnVmVyc2lvbihlKXtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIrOCk+PjI2Jjd9YXN5bmMgZ2V0TWlub3JDaGlwVmVyc2lvbihlKXtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIrOCk+PjAmMTV9YXN5bmMgZ2V0TWFqb3JDaGlwVmVyc2lvbihlKXtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIrOCk+PjQmM31hc3luYyBnZXRDaGlwRGVzY3JpcHRpb24oZSl7bGV0IEE9YXdhaXQgdGhpcy5nZXRQa2dWZXJzaW9uKGUpLGk7QT09PTA/aT0iRVNQMzItQzUiOmk9InVua25vd24gRVNQMzItQzUiO2xldCBzPWF3YWl0IHRoaXMuZ2V0TWFqb3JDaGlwVmVyc2lvbihlKSxhPWF3YWl0IHRoaXMuZ2V0TWlub3JDaGlwVmVyc2lvbihlKTtyZXR1cm5gJHtpfSAocmV2aXNpb24gdiR7c30uJHthfSlgfWFzeW5jIGdldENoaXBGZWF0dXJlcyhlKXtyZXR1cm5bIldpLUZpIDYgKGR1YWwtYmFuZCkiLCJCVCA1IChMRSkiXX1hc3luYyBnZXRDcnlzdGFsRnJlcShlKXtsZXQgQT1hd2FpdCBlLnJlYWRSZWcodGhpcy5VQVJUX0NMS0RJVl9SRUcpJnRoaXMuVUFSVF9DTEtESVZfTUFTSyxpPWUudHJhbnNwb3J0LmJhdWRyYXRlKkEvMWU2L3RoaXMuWFRBTF9DTEtfRElWSURFUixzO3JldHVybiBpPjQ1P3M9NDg6aT4zMz9zPTQwOnM9MjYsTWF0aC5hYnMocy1pKT4xJiZlLmluZm8oIldBUk5JTkc6IFVuc3VwcG9ydGVkIGNyeXN0YWwgaW4gdXNlIiksc31hc3luYyBnZXRDcnlzdGFsRnJlcVJvbUV4cGVjdChlKXtyZXR1cm4oYXdhaXQgZS5yZWFkUmVnKHRoaXMuUENSX1NZU0NMS19DT05GX1JFRykmdGhpcy5QQ1JfU1lTQ0xLX1hUQUxfRlJFUV9WKT4+dGhpcy5QQ1JfU1lTQ0xLX1hUQUxfRlJFUV9TfX19KTt2YXIgV2k9e307SihXaSx7RVNQMzJIMlJPTTooKT0+anR9KTt2YXIganQsemk9RygoKT0+e0FBKCk7anQ9Y2xhc3MgZXh0ZW5kcyBPe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLkNISVBfTkFNRT0iRVNQMzItSDIiLHRoaXMuSU1BR0VfQ0hJUF9JRD0xNix0aGlzLkVGVVNFX0JBU0U9MTYxMTMzNTY4MCx0aGlzLkVGVVNFX0JMT0NLMV9BRERSPXRoaXMuRUZVU0VfQkFTRSs2OCx0aGlzLk1BQ19FRlVTRV9SRUc9dGhpcy5FRlVTRV9CQVNFKzY4LHRoaXMuVUFSVF9DTEtESVZfUkVHPTEwNzI5NTU0MTIsdGhpcy5VQVJUX0NMS0RJVl9NQVNLPTEwNDg1NzUsdGhpcy5VQVJUX0RBVEVfUkVHX0FERFI9MTYxMDYxMjg2MCx0aGlzLkZMQVNIX1dSSVRFX1NJWkU9MTAyNCx0aGlzLkJPT1RMT0FERVJfRkxBU0hfT0ZGU0VUPTAsdGhpcy5GTEFTSF9TSVpFUz17IjFNQiI6MCwiMk1CIjoxNiwiNE1CIjozMiwiOE1CIjo0OCwiMTZNQiI6NjR9LHRoaXMuU1BJX1JFR19CQVNFPTE2MTA2MjA5MjgsdGhpcy5TUElfVVNSX09GRlM9MjQsdGhpcy5TUElfVVNSMV9PRkZTPTI4LHRoaXMuU1BJX1VTUjJfT0ZGUz0zMix0aGlzLlNQSV9NT1NJX0RMRU5fT0ZGUz0zNix0aGlzLlNQSV9NSVNPX0RMRU5fT0ZGUz00MCx0aGlzLlNQSV9XMF9PRkZTPTg4LHRoaXMuVVNCX1JBTV9CTE9DSz0yMDQ4LHRoaXMuVUFSVERFVl9CVUZfTk9fVVNCPTMsdGhpcy5VQVJUREVWX0JVRl9OTz0xMDcwNTI2Nzk2fWFzeW5jIGdldFBrZ1ZlcnNpb24oZSl7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSKzE2KT4+MCY3fWFzeW5jIGdldE1pbm9yQ2hpcFZlcnNpb24oZSl7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSKzEyKT4+MTgmN31hc3luYyBnZXRNYWpvckNoaXBWZXJzaW9uKGUpe3JldHVybiBhd2FpdCBlLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUisxMik+PjIxJjN9YXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGUpe2xldCBBPWF3YWl0IHRoaXMuZ2V0UGtnVmVyc2lvbihlKSxpO0E9PT0wP2k9IkVTUDMyLUgyIjppPSJ1bmtub3duIEVTUDMyLUgyIjtsZXQgcz1hd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24oZSksYT1hd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24oZSk7cmV0dXJuYCR7aX0gKHJldmlzaW9uIHYke3N9LiR7YX0pYH1hc3luYyBnZXRDaGlwRmVhdHVyZXMoZSl7cmV0dXJuWyJCVCA1IChMRSkiLCJJRUVFODAyLjE1LjQiLCJTaW5nbGUgQ29yZSIsIjk2TUh6Il19YXN5bmMgZ2V0Q3J5c3RhbEZyZXEoZSl7cmV0dXJuIDMyfV9kMmgoZSl7bGV0IEE9KCtlKS50b1N0cmluZygxNik7cmV0dXJuIEEubGVuZ3RoPT09MT8iMCIrQTpBfWFzeW5jIHBvc3RDb25uZWN0KGUpe2xldCBBPWF3YWl0IGUucmVhZFJlZyh0aGlzLlVBUlRERVZfQlVGX05PKSYyNTU7ZS5kZWJ1ZygiSW4gX3Bvc3RfY29ubmVjdCAiK0EpLEE9PXRoaXMuVUFSVERFVl9CVUZfTk9fVVNCJiYoZS5FU1BfUkFNX0JMT0NLPXRoaXMuVVNCX1JBTV9CTE9DSyl9YXN5bmMgcmVhZE1hYyhlKXtsZXQgQT1hd2FpdCBlLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKTtBPUE+Pj4wO2xldCBpPWF3YWl0IGUucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcrNCk7aT1pPj4+MCY2NTUzNTtsZXQgcz1uZXcgVWludDhBcnJheSg2KTtyZXR1cm4gc1swXT1pPj44JjI1NSxzWzFdPWkmMjU1LHNbMl09QT4+MjQmMjU1LHNbM109QT4+MTYmMjU1LHNbNF09QT4+OCYyNTUsc1s1XT1BJjI1NSx0aGlzLl9kMmgoc1swXSkrIjoiK3RoaXMuX2QyaChzWzFdKSsiOiIrdGhpcy5fZDJoKHNbMl0pKyI6Iit0aGlzLl9kMmgoc1szXSkrIjoiK3RoaXMuX2QyaChzWzRdKSsiOiIrdGhpcy5fZDJoKHNbNV0pfWdldEVyYXNlU2l6ZShlLEEpe3JldHVybiBBfX19KTt2YXIgamk9e307SihqaSx7RVNQMzJTM1JPTTooKT0+WnR9KTt2YXIgWnQsWmk9RygoKT0+e0FBKCk7WnQ9Y2xhc3MgZXh0ZW5kcyBPe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLkNISVBfTkFNRT0iRVNQMzItUzMiLHRoaXMuSU1BR0VfQ0hJUF9JRD05LHRoaXMuRUZVU0VfQkFTRT0xNjEwNjQxNDA4LHRoaXMuTUFDX0VGVVNFX1JFRz10aGlzLkVGVVNFX0JBU0UrNjgsdGhpcy5FRlVTRV9CTE9DSzFfQUREUj10aGlzLkVGVVNFX0JBU0UrNjgsdGhpcy5FRlVTRV9CTE9DSzJfQUREUj10aGlzLkVGVVNFX0JBU0UrOTIsdGhpcy5VQVJUX0NMS0RJVl9SRUc9MTYxMDYxMjc1Nix0aGlzLlVBUlRfQ0xLRElWX01BU0s9MTA0ODU3NSx0aGlzLlVBUlRfREFURV9SRUdfQUREUj0xNjEwNjEyODY0LHRoaXMuRkxBU0hfV1JJVEVfU0laRT0xMDI0LHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQ9MCx0aGlzLkZMQVNIX1NJWkVTPXsiMU1CIjowLCIyTUIiOjE2LCI0TUIiOjMyLCI4TUIiOjQ4LCIxNk1CIjo2NH0sdGhpcy5TUElfUkVHX0JBU0U9MTYxMDYyMDkyOCx0aGlzLlNQSV9VU1JfT0ZGUz0yNCx0aGlzLlNQSV9VU1IxX09GRlM9MjgsdGhpcy5TUElfVVNSMl9PRkZTPTMyLHRoaXMuU1BJX01PU0lfRExFTl9PRkZTPTM2LHRoaXMuU1BJX01JU09fRExFTl9PRkZTPTQwLHRoaXMuU1BJX1cwX09GRlM9ODgsdGhpcy5VU0JfUkFNX0JMT0NLPTIwNDgsdGhpcy5VQVJUREVWX0JVRl9OT19VU0I9Myx0aGlzLlVBUlRERVZfQlVGX05PPTEwNzA1MjY3OTZ9YXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGUpe2xldCBBPWF3YWl0IHRoaXMuZ2V0TWFqb3JDaGlwVmVyc2lvbihlKSxpPWF3YWl0IHRoaXMuZ2V0TWlub3JDaGlwVmVyc2lvbihlKSxzPWF3YWl0IHRoaXMuZ2V0UGtnVmVyc2lvbihlKTtyZXR1cm5gJHt7MDoiRVNQMzItUzMgKFFGTjU2KSIsMToiRVNQMzItUzMtUElDTy0xIChMR0E1NikifVtzXXx8InVua25vd24gRVNQMzItUzMifSAocmV2aXNpb24gdiR7QX0uJHtpfSlgfWFzeW5jIGdldFBrZ1ZlcnNpb24oZSl7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSKzEyKT4+MjEmN31hc3luYyBnZXRSYXdNaW5vckNoaXBWZXJzaW9uKGUpe2xldCBpPWF3YWl0IGUucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSKzIwKT4+MjMmMSxhPWF3YWl0IGUucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSKzQqMyk+PjE4Jjc7cmV0dXJuKGk8PDMpK2F9YXN5bmMgZ2V0TWlub3JDaGlwVmVyc2lvbihlKXtsZXQgQT1hd2FpdCB0aGlzLmdldFJhd01pbm9yQ2hpcFZlcnNpb24oZSk7cmV0dXJuIGF3YWl0IHRoaXMuaXNFY28wKGUsQSk/MDp0aGlzLmdldFJhd01pbm9yQ2hpcFZlcnNpb24oZSl9YXN5bmMgZ2V0UmF3TWFqb3JDaGlwVmVyc2lvbihlKXtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIrMjApPj4yNCYzfWFzeW5jIGdldE1ham9yQ2hpcFZlcnNpb24oZSl7bGV0IEE9YXdhaXQgdGhpcy5nZXRSYXdNaW5vckNoaXBWZXJzaW9uKGUpO3JldHVybiBhd2FpdCB0aGlzLmlzRWNvMChlLEEpPzA6dGhpcy5nZXRSYXdNYWpvckNoaXBWZXJzaW9uKGUpfWFzeW5jIGdldEJsa1ZlcnNpb25NYWpvcihlKXtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0syX0FERFIrMTYpPj4wJjN9YXN5bmMgZ2V0QmxrVmVyc2lvbk1pbm9yKGUpe3JldHVybiBhd2FpdCBlLnJlYWRSZWcodGhpcy5FRlVTRV9CTE9DSzFfQUREUisxMik+PjI0Jjd9YXN5bmMgaXNFY28wKGUsQSl7cmV0dXJuKEEmNyk9PT0wJiZhd2FpdCB0aGlzLmdldEJsa1ZlcnNpb25NYWpvcihlKT09PTEmJmF3YWl0IHRoaXMuZ2V0QmxrVmVyc2lvbk1pbm9yKGUpPT09MX1hc3luYyBnZXRGbGFzaENhcChlKXtsZXQgcz10aGlzLkVGVVNFX0JBU0UrNjgrMTI7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyhzKT4+MjcmN31hc3luYyBnZXRGbGFzaFZlbmRvcihlKXtsZXQgcz10aGlzLkVGVVNFX0JBU0UrNjgrMTYsbj1hd2FpdCBlLnJlYWRSZWcocyk+PjAmNztyZXR1cm57MToiWE1DIiwyOiJHRCIsMzoiRk0iLDQ6IlRUIiw1OiJCWSJ9W25dfHwiIn1hc3luYyBnZXRQc3JhbUNhcChlKXtsZXQgcz10aGlzLkVGVVNFX0JBU0UrNjgrMTY7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyhzKT4+MyYzfWFzeW5jIGdldFBzcmFtVmVuZG9yKGUpe2xldCBzPXRoaXMuRUZVU0VfQkFTRSs2OCsxNixuPWF3YWl0IGUucmVhZFJlZyhzKT4+NyYzO3JldHVybnsxOiJBUF8zdjMiLDI6IkFQXzF2OCJ9W25dfHwiIn1hc3luYyBnZXRDaGlwRmVhdHVyZXMoZSl7bGV0IEE9WyJXaS1GaSIsIkJMRSJdLGk9ezA6bnVsbCwxOiJFbWJlZGRlZCBGbGFzaCA4TUIiLDI6IkVtYmVkZGVkIEZsYXNoIDRNQiJ9LHM9YXdhaXQgdGhpcy5nZXRGbGFzaENhcChlKSxhPWF3YWl0IHRoaXMuZ2V0Rmxhc2hWZW5kb3IoZSksbj1pW3NdLEU9biE9PXZvaWQgMD9uOiJVbmtub3duIEVtYmVkZGVkIEZsYXNoIjtuIT09bnVsbCYmQS5wdXNoKGAke0V9ICgke2F9KWApO2xldCBvPXswOm51bGwsMToiRW1iZWRkZWQgUFNSQU0gOE1CIiwyOiJFbWJlZGRlZCBQU1JBTSAyTUIifSxyPWF3YWl0IHRoaXMuZ2V0UHNyYW1DYXAoZSksaD1hd2FpdCB0aGlzLmdldFBzcmFtVmVuZG9yKGUpLHc9b1tyXSxjPXchPT12b2lkIDA/dzoiVW5rbm93biBFbWJlZGRlZCBQU1JBTSI7cmV0dXJuIHchPT1udWxsJiZBLnB1c2goYCR7Y30gKCR7aH0pYCksQX1hc3luYyBnZXRDcnlzdGFsRnJlcShlKXtyZXR1cm4gNDB9X2QyaChlKXtsZXQgQT0oK2UpLnRvU3RyaW5nKDE2KTtyZXR1cm4gQS5sZW5ndGg9PT0xPyIwIitBOkF9YXN5bmMgcG9zdENvbm5lY3QoZSl7bGV0IEE9YXdhaXQgZS5yZWFkUmVnKHRoaXMuVUFSVERFVl9CVUZfTk8pJjI1NTtlLmRlYnVnKCJJbiBfcG9zdF9jb25uZWN0ICIrQSksQT09dGhpcy5VQVJUREVWX0JVRl9OT19VU0ImJihlLkVTUF9SQU1fQkxPQ0s9dGhpcy5VU0JfUkFNX0JMT0NLKX1hc3luYyByZWFkTWFjKGUpe2xldCBBPWF3YWl0IGUucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcpO0E9QT4+PjA7bGV0IGk9YXdhaXQgZS5yZWFkUmVnKHRoaXMuTUFDX0VGVVNFX1JFRys0KTtpPWk+Pj4wJjY1NTM1O2xldCBzPW5ldyBVaW50OEFycmF5KDYpO3JldHVybiBzWzBdPWk+PjgmMjU1LHNbMV09aSYyNTUsc1syXT1BPj4yNCYyNTUsc1szXT1BPj4xNiYyNTUsc1s0XT1BPj44JjI1NSxzWzVdPUEmMjU1LHRoaXMuX2QyaChzWzBdKSsiOiIrdGhpcy5fZDJoKHNbMV0pKyI6Iit0aGlzLl9kMmgoc1syXSkrIjoiK3RoaXMuX2QyaChzWzNdKSsiOiIrdGhpcy5fZDJoKHNbNF0pKyI6Iit0aGlzLl9kMmgoc1s1XSl9Z2V0RXJhc2VTaXplKGUsQSl7cmV0dXJuIEF9fX0pO3ZhciBYaT17fTtKKFhpLHtFU1AzMlMyUk9NOigpPT5YdH0pO3ZhciBYdCxWaT1HKCgpPT57QUEoKTtYdD1jbGFzcyBleHRlbmRzIE97Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuQ0hJUF9OQU1FPSJFU1AzMi1TMiIsdGhpcy5JTUFHRV9DSElQX0lEPTIsdGhpcy5JUk9NX01BUF9TVEFSVD0xMDc0MjY2MTEyLHRoaXMuSVJPTV9NQVBfRU5EPTEwODU4MDA0NDgsdGhpcy5EUk9NX01BUF9TVEFSVD0xMDU2OTY0NjA4LHRoaXMuRFJPTV9NQVBfRU5EPTEwNjEwOTMzNzYsdGhpcy5DSElQX0RFVEVDVF9NQUdJQ19WQUxVRT1bMTk5MF0sdGhpcy5TUElfUkVHX0JBU0U9MTA2MTE2NzEwNCx0aGlzLlNQSV9VU1JfT0ZGUz0yNCx0aGlzLlNQSV9VU1IxX09GRlM9MjgsdGhpcy5TUElfVVNSMl9PRkZTPTMyLHRoaXMuU1BJX01PU0lfRExFTl9PRkZTPTM2LHRoaXMuU1BJX01JU09fRExFTl9PRkZTPTQwLHRoaXMuU1BJX1cwX09GRlM9ODgsdGhpcy5TUElfQUREUl9SRUdfTVNCPSExLHRoaXMuTUFDX0VGVVNFX1JFRz0xMDYxMjY1NDc2LHRoaXMuVUFSVF9DTEtESVZfUkVHPTEwNjExNTg5MzIsdGhpcy5TVVBQT1JUU19FTkNSWVBURURfRkxBU0g9ITAsdGhpcy5GTEFTSF9FTkNSWVBURURfV1JJVEVfQUxJR049MTYsdGhpcy5FRlVTRV9CQVNFPTEwNjEyNjU0MDgsdGhpcy5FRlVTRV9SRF9SRUdfQkFTRT10aGlzLkVGVVNFX0JBU0UrNDgsdGhpcy5FRlVTRV9CTE9DSzFfQUREUj10aGlzLkVGVVNFX0JBU0UrNjgsdGhpcy5FRlVTRV9CTE9DSzJfQUREUj10aGlzLkVGVVNFX0JBU0UrOTIsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTBfUkVHPXRoaXMuRUZVU0VfQkFTRSs1Mix0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMF9TSElGVD0yNCx0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9SRUc9dGhpcy5FRlVTRV9CQVNFKzUyLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkxX1NISUZUPTI4LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkyX1JFRz10aGlzLkVGVVNFX0JBU0UrNTYsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTJfU0hJRlQ9MCx0aGlzLkVGVVNFX1BVUlBPU0VfS0VZM19SRUc9dGhpcy5FRlVTRV9CQVNFKzU2LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1NISUZUPTQsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfUkVHPXRoaXMuRUZVU0VfQkFTRSs1Nix0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNF9TSElGVD04LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk1X1JFRz10aGlzLkVGVVNFX0JBU0UrNTYsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTVfU0hJRlQ9MTIsdGhpcy5FRlVTRV9ESVNfRE9XTkxPQURfTUFOVUFMX0VOQ1JZUFRfUkVHPXRoaXMuRUZVU0VfUkRfUkVHX0JBU0UsdGhpcy5FRlVTRV9ESVNfRE9XTkxPQURfTUFOVUFMX0VOQ1JZUFQ9MTw8MTksdGhpcy5FRlVTRV9TUElfQk9PVF9DUllQVF9DTlRfUkVHPXRoaXMuRUZVU0VfQkFTRSs1Mix0aGlzLkVGVVNFX1NQSV9CT09UX0NSWVBUX0NOVF9NQVNLPTc8PDE4LHRoaXMuRUZVU0VfU0VDVVJFX0JPT1RfRU5fUkVHPXRoaXMuRUZVU0VfQkFTRSs1Nix0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX01BU0s9MTw8MjAsdGhpcy5FRlVTRV9SRF9SRVBFQVRfREFUQTNfUkVHPXRoaXMuRUZVU0VfQkFTRSs2MCx0aGlzLkVGVVNFX1JEX1JFUEVBVF9EQVRBM19SRUdfRkxBU0hfVFlQRV9NQVNLPTUxMix0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzE9Mix0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzI9Myx0aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMxMjhfS0VZPTQsdGhpcy5VQVJUREVWX0JVRl9OTz0xMDczNzQxMDc2LHRoaXMuVUFSVERFVl9CVUZfTk9fVVNCX09URz0yLHRoaXMuVVNCX1JBTV9CTE9DSz0yMDQ4LHRoaXMuR1BJT19TVFJBUF9SRUc9MTA2MTE3NTM1Mix0aGlzLkdQSU9fU1RSQVBfU1BJX0JPT1RfTUFTSz04LHRoaXMuR1BJT19TVFJBUF9WRERTUElfTUFTSz0xNix0aGlzLlJUQ19DTlRMX09QVElPTjFfUkVHPTEwNjExOTE5NzYsdGhpcy5SVENfQ05UTF9GT1JDRV9ET1dOTE9BRF9CT09UX01BU0s9MSx0aGlzLlJUQ0NOVExfQkFTRV9SRUc9MTA2MTE5MTY4MCx0aGlzLlJUQ19DTlRMX1dEVENPTkZJRzBfUkVHPXRoaXMuUlRDQ05UTF9CQVNFX1JFRysxNDgsdGhpcy5SVENfQ05UTF9XRFRDT05GSUcxX1JFRz10aGlzLlJUQ0NOVExfQkFTRV9SRUcrMTUyLHRoaXMuUlRDX0NOVExfV0RUV1BST1RFQ1RfUkVHPXRoaXMuUlRDQ05UTF9CQVNFX1JFRysxNzIsdGhpcy5SVENfQ05UTF9XRFRfV0tFWT0xMzU2MzQ4MDY1LHRoaXMuTUVNT1JZX01BUD1bWzAsNjU1MzYsIlBBRERJTkciXSxbMTA1Njk2NDYwOCwxMDczMjE3NTM2LCJEUk9NIl0sWzEwNjIyMDc0ODgsMTA3MzIxNzUzNiwiRVhUUkFNX0RBVEEiXSxbMTA3MzM0MDQxNiwxMDczMzQ4NjA4LCJSVENfRFJBTSJdLFsxMDczMzQwNDE2LDEwNzM3NDE4MjQsIkJZVEVfQUNDRVNTSUJMRSJdLFsxMDczMzQwNDE2LDEwNzQyMDg3NjgsIk1FTV9JTlRFUk5BTCJdLFsxMDczNDE0MTQ0LDEwNzM3NDE4MjQsIkRSQU0iXSxbMTA3Mzc0MTgyNCwxMDczODQ4NTc2LCJJUk9NX01BU0siXSxbMTA3Mzg3Mjg5NiwxMDc0MjAwNTc2LCJJUkFNIl0sWzEwNzQyMDA1NzYsMTA3NDIwODc2OCwiUlRDX0lSQU0iXSxbMTA3NDI2NjExMiwxMDgyMTMwNDMyLCJJUk9NIl0sWzEzNDIxNzcyODAsMTM0MjE4NTQ3MiwiUlRDX0RBVEEiXV0sdGhpcy5FRlVTRV9WRERfU1BJX1JFRz10aGlzLkVGVVNFX0JBU0UrNTIsdGhpcy5WRERfU1BJX1hQRD0xNix0aGlzLlZERF9TUElfVElFSD0zMix0aGlzLlZERF9TUElfRk9SQ0U9NjQsdGhpcy5VRjJfRkFNSUxZX0lEPTMyMTg5NTE5MTgsdGhpcy5FRlVTRV9NQVhfS0VZPTUsdGhpcy5LRVlfUFVSUE9TRVM9ezA6IlVTRVIvRU1QVFkiLDE6IlJFU0VSVkVEIiwyOiJYVFNfQUVTXzI1Nl9LRVlfMSIsMzoiWFRTX0FFU18yNTZfS0VZXzIiLDQ6IlhUU19BRVNfMTI4X0tFWSIsNToiSE1BQ19ET1dOX0FMTCIsNjoiSE1BQ19ET1dOX0pUQUciLDc6IkhNQUNfRE9XTl9ESUdJVEFMX1NJR05BVFVSRSIsODoiSE1BQ19VUCIsOToiU0VDVVJFX0JPT1RfRElHRVNUMCIsMTA6IlNFQ1VSRV9CT09UX0RJR0VTVDEiLDExOiJTRUNVUkVfQk9PVF9ESUdFU1QyIn0sdGhpcy5VQVJUX0NMS0RJVl9NQVNLPTEwNDg1NzUsdGhpcy5VQVJUX0RBVEVfUkVHX0FERFI9MTYxMDYxMjg1Nix0aGlzLkZMQVNIX1dSSVRFX1NJWkU9MTAyNCx0aGlzLkJPT1RMT0FERVJfRkxBU0hfT0ZGU0VUPTQwOTYsdGhpcy5GTEFTSF9TSVpFUz17IjFNQiI6MCwiMk1CIjoxNiwiNE1CIjozMiwiOE1CIjo0OCwiMTZNQiI6NjR9fWFzeW5jIGdldFBrZ1ZlcnNpb24oZSl7bGV0IGk9dGhpcy5FRlVTRV9CTE9DSzFfQUREUisxNjtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKGkpPj4wJjE1fWFzeW5jIGdldE1pbm9yQ2hpcFZlcnNpb24oZSl7bGV0IGk9YXdhaXQgZS5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIrMTIpPj4yMCYxLGE9YXdhaXQgZS5yZWFkUmVnKHRoaXMuRUZVU0VfQkxPQ0sxX0FERFIrNCo0KT4+NCY3O3JldHVybihpPDwzKSthfWFzeW5jIGdldE1ham9yQ2hpcFZlcnNpb24oZSl7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSKzEyKT4+MTgmM31hc3luYyBnZXRGbGFzaFZlcnNpb24oZSl7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyh0aGlzLkVGVVNFX0JMT0NLMV9BRERSKzEyKT4+MjEmMTV9YXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGUpe2xldCBBPXswOiJFU1AzMi1TMiIsMToiRVNQMzItUzJGSDIiLDI6IkVTUDMyLVMyRkg0IiwxMDI6IkVTUDMyLVMyRk5SMiIsMTAwOiJFU1AzMi1TMlIyIn0saT1hd2FpdCB0aGlzLmdldEZsYXNoQ2FwKGUpK2F3YWl0IHRoaXMuZ2V0UHNyYW1DYXAoZSkqMTAwLHM9YXdhaXQgdGhpcy5nZXRNYWpvckNoaXBWZXJzaW9uKGUpLGE9YXdhaXQgdGhpcy5nZXRNaW5vckNoaXBWZXJzaW9uKGUpO3JldHVybmAke0FbaV18fCJ1bmtub3duIEVTUDMyLVMyIn0gKHJldmlzaW9uIHYke3N9LiR7YX0pYH1hc3luYyBnZXRGbGFzaENhcChlKXtyZXR1cm4gYXdhaXQgdGhpcy5nZXRGbGFzaFZlcnNpb24oZSl9YXN5bmMgZ2V0UHNyYW1WZXJzaW9uKGUpe2xldCBpPXRoaXMuRUZVU0VfQkxPQ0sxX0FERFIrMTI7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyhpKT4+MjgmMTV9YXN5bmMgZ2V0UHNyYW1DYXAoZSl7cmV0dXJuIGF3YWl0IHRoaXMuZ2V0UHNyYW1WZXJzaW9uKGUpfWFzeW5jIGdldEJsb2NrMlZlcnNpb24oZSl7bGV0IGk9dGhpcy5FRlVTRV9CTE9DSzJfQUREUisxNjtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKGkpPj40Jjd9YXN5bmMgZ2V0Q2hpcEZlYXR1cmVzKGUpe2xldCBBPVsiV2ktRmkiXSxpPXswOiJObyBFbWJlZGRlZCBGbGFzaCIsMToiRW1iZWRkZWQgRmxhc2ggMk1CIiwyOiJFbWJlZGRlZCBGbGFzaCA0TUIifSxzPWF3YWl0IHRoaXMuZ2V0Rmxhc2hDYXAoZSksYT1pW3NdfHwiVW5rbm93biBFbWJlZGRlZCBGbGFzaCI7QS5wdXNoKGEpO2xldCBuPXswOiJObyBFbWJlZGRlZCBGbGFzaCIsMToiRW1iZWRkZWQgUFNSQU0gMk1CIiwyOiJFbWJlZGRlZCBQU1JBTSA0TUIifSxFPWF3YWl0IHRoaXMuZ2V0UHNyYW1DYXAoZSksbz1uW0VdfHwiVW5rbm93biBFbWJlZGRlZCBQU1JBTSI7QS5wdXNoKG8pO2xldCByPXswOiJObyBjYWxpYnJhdGlvbiBpbiBCTEsyIG9mIGVmdXNlIiwxOiJBREMgYW5kIHRlbXBlcmF0dXJlIHNlbnNvciBjYWxpYnJhdGlvbiBpbiBCTEsyIG9mIGVmdXNlIFYxIiwyOiJBREMgYW5kIHRlbXBlcmF0dXJlIHNlbnNvciBjYWxpYnJhdGlvbiBpbiBCTEsyIG9mIGVmdXNlIFYyIn0saD1hd2FpdCB0aGlzLmdldEJsb2NrMlZlcnNpb24oZSksdz1yW2hdfHwiVW5rbm93biBDYWxpYnJhdGlvbiBpbiBCTEsyIjtyZXR1cm4gQS5wdXNoKHcpLEF9YXN5bmMgZ2V0Q3J5c3RhbEZyZXEoZSl7cmV0dXJuIDQwfV9kMmgoZSl7bGV0IEE9KCtlKS50b1N0cmluZygxNik7cmV0dXJuIEEubGVuZ3RoPT09MT8iMCIrQTpBfWFzeW5jIHJlYWRNYWMoZSl7bGV0IEE9YXdhaXQgZS5yZWFkUmVnKHRoaXMuTUFDX0VGVVNFX1JFRyk7QT1BPj4+MDtsZXQgaT1hd2FpdCBlLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKzQpO2k9aT4+PjAmNjU1MzU7bGV0IHM9bmV3IFVpbnQ4QXJyYXkoNik7cmV0dXJuIHNbMF09aT4+OCYyNTUsc1sxXT1pJjI1NSxzWzJdPUE+PjI0JjI1NSxzWzNdPUE+PjE2JjI1NSxzWzRdPUE+PjgmMjU1LHNbNV09QSYyNTUsdGhpcy5fZDJoKHNbMF0pKyI6Iit0aGlzLl9kMmgoc1sxXSkrIjoiK3RoaXMuX2QyaChzWzJdKSsiOiIrdGhpcy5fZDJoKHNbM10pKyI6Iit0aGlzLl9kMmgoc1s0XSkrIjoiK3RoaXMuX2QyaChzWzVdKX1nZXRFcmFzZVNpemUoZSxBKXtyZXR1cm4gQX1hc3luYyB1c2luZ1VzYk90ZyhlKXtyZXR1cm4oYXdhaXQgZS5yZWFkUmVnKHRoaXMuVUFSVERFVl9CVUZfTk8pJjI1NSk9PT10aGlzLlVBUlRERVZfQlVGX05PX1VTQl9PVEd9YXN5bmMgcG9zdENvbm5lY3QoZSl7bGV0IEE9YXdhaXQgdGhpcy51c2luZ1VzYk90ZyhlKTtlLmRlYnVnKCJJbiBfcG9zdF9jb25uZWN0IHVzaW5nIFVTQiBPVEcgPyIrQSksQSYmKGUuRVNQX1JBTV9CTE9DSz10aGlzLlVTQl9SQU1fQkxPQ0spfX19KTt2YXIgcWk9e307SihxaSx7RVNQODI2NlJPTTooKT0+VnR9KTt2YXIgVnQsJGk9RygoKT0+e0FBKCk7VnQ9Y2xhc3MgZXh0ZW5kcyBPe2NvbnN0cnVjdG9yKCl7c3VwZXIoLi4uYXJndW1lbnRzKSx0aGlzLkNISVBfTkFNRT0iRVNQODI2NiIsdGhpcy5DSElQX0RFVEVDVF9NQUdJQ19WQUxVRT1bNDI5Mzk2ODEyOV0sdGhpcy5FRlVTRV9SRF9SRUdfQkFTRT0xMDcyNjkzMzI4LHRoaXMuVUFSVF9DTEtESVZfUkVHPTE2MTA2MTI3NTYsdGhpcy5VQVJUX0NMS0RJVl9NQVNLPTEwNDg1NzUsdGhpcy5YVEFMX0NMS19ESVZJREVSPTIsdGhpcy5GTEFTSF9XUklURV9TSVpFPTE2Mzg0LHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQ9MCx0aGlzLlVBUlRfREFURV9SRUdfQUREUj0wLHRoaXMuRkxBU0hfU0laRVM9eyI1MTJLQiI6MCwiMjU2S0IiOjE2LCIxTUIiOjMyLCIyTUIiOjQ4LCI0TUIiOjY0LCIyTUItYzEiOjgwLCI0TUItYzEiOjk2LCI4TUIiOjEyOCwiMTZNQiI6MTQ0fSx0aGlzLlNQSV9SRUdfQkFTRT0xNjEwNjEzMjQ4LHRoaXMuU1BJX1VTUl9PRkZTPTI4LHRoaXMuU1BJX1VTUjFfT0ZGUz0zMix0aGlzLlNQSV9VU1IyX09GRlM9MzYsdGhpcy5TUElfTU9TSV9ETEVOX09GRlM9MCx0aGlzLlNQSV9NSVNPX0RMRU5fT0ZGUz0wLHRoaXMuU1BJX1cwX09GRlM9NjQsdGhpcy5nZXRDaGlwRmVhdHVyZXM9YXN5bmMgZT0+e2xldCBBPVsiV2lGaSJdO3JldHVybiBhd2FpdCB0aGlzLmdldENoaXBEZXNjcmlwdGlvbihlKT09IkVTUDgyODUiJiZBLnB1c2goIkVtYmVkZGVkIEZsYXNoIiksQX19YXN5bmMgcmVhZEVmdXNlKGUsQSl7bGV0IGk9dGhpcy5FRlVTRV9SRF9SRUdfQkFTRSs0KkE7cmV0dXJuIGUuZGVidWcoIlJlYWQgZWZ1c2UgIitpKSxhd2FpdCBlLnJlYWRSZWcoaSl9YXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGUpe2xldCBBPWF3YWl0IHRoaXMucmVhZEVmdXNlKGUsMik7cmV0dXJuKGF3YWl0IHRoaXMucmVhZEVmdXNlKGUsMCkmMTZ8QSY2NTUzNikhPTA/IkVTUDgyODUiOiJFU1A4MjY2RVgifWFzeW5jIGdldENyeXN0YWxGcmVxKGUpe2xldCBBPWF3YWl0IGUucmVhZFJlZyh0aGlzLlVBUlRfQ0xLRElWX1JFRykmdGhpcy5VQVJUX0NMS0RJVl9NQVNLLGk9ZS50cmFuc3BvcnQuYmF1ZHJhdGUqQS8xZTYvdGhpcy5YVEFMX0NMS19ESVZJREVSLHM7cmV0dXJuIGk+MzM/cz00MDpzPTI2LE1hdGguYWJzKHMtaSk+MSYmZS5pbmZvKCJXQVJOSU5HOiBEZXRlY3RlZCBjcnlzdGFsIGZyZXEgIitpKyJNSHogaXMgcXVpdGUgZGlmZmVyZW50IHRvIG5vcm1hbGl6ZWQgZnJlcSAiK3MrIk1Iei4gVW5zdXBwb3J0ZWQgY3J5c3RhbCBpbiB1c2U/Iiksc31fZDJoKGUpe2xldCBBPSgrZSkudG9TdHJpbmcoMTYpO3JldHVybiBBLmxlbmd0aD09PTE/IjAiK0E6QX1hc3luYyByZWFkTWFjKGUpe2xldCBBPWF3YWl0IHRoaXMucmVhZEVmdXNlKGUsMCk7QT1BPj4+MDtsZXQgaT1hd2FpdCB0aGlzLnJlYWRFZnVzZShlLDEpO2k9aT4+PjA7bGV0IHM9YXdhaXQgdGhpcy5yZWFkRWZ1c2UoZSwzKTtzPXM+Pj4wO2xldCBhPW5ldyBVaW50OEFycmF5KDYpO3JldHVybiBzIT0wPyhhWzBdPXM+PjE2JjI1NSxhWzFdPXM+PjgmMjU1LGFbMl09cyYyNTUpOihpPj4xNiYyNTUpPT0wPyhhWzBdPTI0LGFbMV09MjU0LGFbMl09NTIpOihpPj4xNiYyNTUpPT0xPyhhWzBdPTE3MixhWzFdPTIwOCxhWzJdPTExNik6ZS5lcnJvcigiVW5rbm93biBPVUkiKSxhWzNdPWk+PjgmMjU1LGFbNF09aSYyNTUsYVs1XT1BPj4yNCYyNTUsdGhpcy5fZDJoKGFbMF0pKyI6Iit0aGlzLl9kMmgoYVsxXSkrIjoiK3RoaXMuX2QyaChhWzJdKSsiOiIrdGhpcy5fZDJoKGFbM10pKyI6Iit0aGlzLl9kMmgoYVs0XSkrIjoiK3RoaXMuX2QyaChhWzVdKX1nZXRFcmFzZVNpemUoZSxBKXtyZXR1cm4gQX19fSk7dmFyIEFzPXt9O0ooQXMse0VTUDMyUDRST006KCk9PnF0fSk7dmFyIHF0LHRzPUcoKCk9PntOdCgpO3F0PWNsYXNzIGV4dGVuZHMgekF7Y29uc3RydWN0b3IoKXtzdXBlciguLi5hcmd1bWVudHMpLHRoaXMuQ0hJUF9OQU1FPSJFU1AzMi1QNCIsdGhpcy5JTUFHRV9DSElQX0lEPTE4LHRoaXMuSVJPTV9NQVBfU1RBUlQ9MTA3Mzc0MTgyNCx0aGlzLklST01fTUFQX0VORD0xMjc1MDY4NDE2LHRoaXMuRFJPTV9NQVBfU1RBUlQ9MTA3Mzc0MTgyNCx0aGlzLkRST01fTUFQX0VORD0xMjc1MDY4NDE2LHRoaXMuQk9PVExPQURFUl9GTEFTSF9PRkZTRVQ9ODE5Mix0aGlzLkNISVBfREVURUNUX01BR0lDX1ZBTFVFPVswLDE4MjMwMzQ0MF0sdGhpcy5VQVJUX0RBVEVfUkVHX0FERFI9MTM0MzAwNDgxMix0aGlzLkVGVVNFX0JBU0U9MTM0MzQxMDE3Nix0aGlzLkVGVVNFX0JMT0NLMV9BRERSPXRoaXMuRUZVU0VfQkFTRSs2OCx0aGlzLk1BQ19FRlVTRV9SRUc9dGhpcy5FRlVTRV9CQVNFKzY4LHRoaXMuU1BJX1JFR19CQVNFPTEzNDI3NTQ4MTYsdGhpcy5TUElfVVNSX09GRlM9MjQsdGhpcy5TUElfVVNSMV9PRkZTPTI4LHRoaXMuU1BJX1VTUjJfT0ZGUz0zMix0aGlzLlNQSV9NT1NJX0RMRU5fT0ZGUz0zNix0aGlzLlNQSV9NSVNPX0RMRU5fT0ZGUz00MCx0aGlzLlNQSV9XMF9PRkZTPTg4LHRoaXMuRUZVU0VfUkRfUkVHX0JBU0U9dGhpcy5FRlVTRV9CQVNFKzQ4LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkwX1JFRz10aGlzLkVGVVNFX0JBU0UrNTIsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTBfU0hJRlQ9MjQsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTFfUkVHPXRoaXMuRUZVU0VfQkFTRSs1Mix0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMV9TSElGVD0yOCx0aGlzLkVGVVNFX1BVUlBPU0VfS0VZMl9SRUc9dGhpcy5FRlVTRV9CQVNFKzU2LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkyX1NISUZUPTAsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTNfUkVHPXRoaXMuRUZVU0VfQkFTRSs1Nix0aGlzLkVGVVNFX1BVUlBPU0VfS0VZM19TSElGVD00LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk0X1JFRz10aGlzLkVGVVNFX0JBU0UrNTYsdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfU0hJRlQ9OCx0aGlzLkVGVVNFX1BVUlBPU0VfS0VZNV9SRUc9dGhpcy5FRlVTRV9CQVNFKzU2LHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk1X1NISUZUPTEyLHRoaXMuRUZVU0VfRElTX0RPV05MT0FEX01BTlVBTF9FTkNSWVBUX1JFRz10aGlzLkVGVVNFX1JEX1JFR19CQVNFLHRoaXMuRUZVU0VfRElTX0RPV05MT0FEX01BTlVBTF9FTkNSWVBUPTE8PDIwLHRoaXMuRUZVU0VfU1BJX0JPT1RfQ1JZUFRfQ05UX1JFRz10aGlzLkVGVVNFX0JBU0UrNTIsdGhpcy5FRlVTRV9TUElfQk9PVF9DUllQVF9DTlRfTUFTSz03PDwxOCx0aGlzLkVGVVNFX1NFQ1VSRV9CT09UX0VOX1JFRz10aGlzLkVGVVNFX0JBU0UrNTYsdGhpcy5FRlVTRV9TRUNVUkVfQk9PVF9FTl9NQVNLPTE8PDIwLHRoaXMuUFVSUE9TRV9WQUxfWFRTX0FFUzI1Nl9LRVlfMT0yLHRoaXMuUFVSUE9TRV9WQUxfWFRTX0FFUzI1Nl9LRVlfMj0zLHRoaXMuUFVSUE9TRV9WQUxfWFRTX0FFUzEyOF9LRVk9NCx0aGlzLlNVUFBPUlRTX0VOQ1JZUFRFRF9GTEFTSD0hMCx0aGlzLkZMQVNIX0VOQ1JZUFRFRF9XUklURV9BTElHTj0xNix0aGlzLk1FTU9SWV9NQVA9W1swLDY1NTM2LCJQQURESU5HIl0sWzEwNzM3NDE4MjQsMTI3NTA2ODQxNiwiRFJPTSJdLFsxMzQxMTI4NzA0LDEzNDE3ODQwNjQsIkRSQU0iXSxbMTM0MTEyODcwNCwxMzQxNzg0MDY0LCJCWVRFX0FDQ0VTU0lCTEUiXSxbMTMzNzk4Mjk3NiwxMzM4MTE0MDQ4LCJEUk9NX01BU0siXSxbMTMzNzk4Mjk3NiwxMzM4MTE0MDQ4LCJJUk9NX01BU0siXSxbMTA3Mzc0MTgyNCwxMjc1MDY4NDE2LCJJUk9NIl0sWzEzNDExMjg3MDQsMTM0MTc4NDA2NCwiSVJBTSJdLFsxMzQzMjU4NjI0LDEzNDMyOTEzOTIsIlJUQ19JUkFNIl0sWzEzNDMyNTg2MjQsMTM0MzI5MTM5MiwiUlRDX0RSQU0iXSxbMTYxMTY1MzEyMCwxNjExNjYxMzEyLCJNRU1fSU5URVJOQUwyIl1dLHRoaXMuVUYyX0ZBTUlMWV9JRD0xMDI2NTkyNDA0LHRoaXMuRUZVU0VfTUFYX0tFWT01LHRoaXMuS0VZX1BVUlBPU0VTPXswOiJVU0VSL0VNUFRZIiwxOiJFQ0RTQV9LRVkiLDI6IlhUU19BRVNfMjU2X0tFWV8xIiwzOiJYVFNfQUVTXzI1Nl9LRVlfMiIsNDoiWFRTX0FFU18xMjhfS0VZIiw1OiJITUFDX0RPV05fQUxMIiw2OiJITUFDX0RPV05fSlRBRyIsNzoiSE1BQ19ET1dOX0RJR0lUQUxfU0lHTkFUVVJFIiw4OiJITUFDX1VQIiw5OiJTRUNVUkVfQk9PVF9ESUdFU1QwIiwxMDoiU0VDVVJFX0JPT1RfRElHRVNUMSIsMTE6IlNFQ1VSRV9CT09UX0RJR0VTVDIiLDEyOiJLTV9JTklUX0tFWSJ9fWFzeW5jIGdldFBrZ1ZlcnNpb24oZSl7bGV0IGk9dGhpcy5FRlVTRV9CTE9DSzFfQUREUis4O3JldHVybiBhd2FpdCBlLnJlYWRSZWcoaSk+PjI3Jjd9YXN5bmMgZ2V0TWlub3JDaGlwVmVyc2lvbihlKXtsZXQgaT10aGlzLkVGVVNFX0JMT0NLMV9BRERSKzg7cmV0dXJuIGF3YWl0IGUucmVhZFJlZyhpKT4+MCYxNX1hc3luYyBnZXRNYWpvckNoaXBWZXJzaW9uKGUpe2xldCBpPXRoaXMuRUZVU0VfQkxPQ0sxX0FERFIrODtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKGkpPj40JjN9YXN5bmMgZ2V0Q2hpcERlc2NyaXB0aW9uKGUpe2xldCBpPWF3YWl0IHRoaXMuZ2V0UGtnVmVyc2lvbihlKT09PTA/IkVTUDMyLVA0IjoidW5rbm93biBFU1AzMi1QNCIscz1hd2FpdCB0aGlzLmdldE1ham9yQ2hpcFZlcnNpb24oZSksYT1hd2FpdCB0aGlzLmdldE1pbm9yQ2hpcFZlcnNpb24oZSk7cmV0dXJuYCR7aX0gKHJldmlzaW9uIHYke3N9LiR7YX0pYH1hc3luYyBnZXRDaGlwRmVhdHVyZXMoZSl7cmV0dXJuWyJIaWdoLVBlcmZvcm1hbmNlIE1DVSJdfWFzeW5jIGdldENyeXN0YWxGcmVxKGUpe3JldHVybiA0MH1hc3luYyBnZXRGbGFzaFZvbHRhZ2UoZSl7fWFzeW5jIG92ZXJyaWRlVmRkc2RpbyhlKXtlLmRlYnVnKCJWRERfU0RJTyBvdmVycmlkZXMgYXJlIG5vdCBzdXBwb3J0ZWQgZm9yIEVTUDMyLVA0Iil9YXN5bmMgcmVhZE1hYyhlKXtsZXQgQT1hd2FpdCBlLnJlYWRSZWcodGhpcy5NQUNfRUZVU0VfUkVHKTtBPUE+Pj4wO2xldCBpPWF3YWl0IGUucmVhZFJlZyh0aGlzLk1BQ19FRlVTRV9SRUcrNCk7aT1pPj4+MCY2NTUzNTtsZXQgcz1uZXcgVWludDhBcnJheSg2KTtyZXR1cm4gc1swXT1pPj44JjI1NSxzWzFdPWkmMjU1LHNbMl09QT4+MjQmMjU1LHNbM109QT4+MTYmMjU1LHNbNF09QT4+OCYyNTUsc1s1XT1BJjI1NSx0aGlzLl9kMmgoc1swXSkrIjoiK3RoaXMuX2QyaChzWzFdKSsiOiIrdGhpcy5fZDJoKHNbMl0pKyI6Iit0aGlzLl9kMmgoc1szXSkrIjoiK3RoaXMuX2QyaChzWzRdKSsiOiIrdGhpcy5fZDJoKHNbNV0pfWFzeW5jIGdldEZsYXNoQ3J5cHRDb25maWcoZSl7fWFzeW5jIGdldFNlY3VyZUJvb3RFbmFibGVkKGUpe3JldHVybiBhd2FpdCBlLnJlYWRSZWcodGhpcy5FRlVTRV9TRUNVUkVfQk9PVF9FTl9SRUcpJnRoaXMuRUZVU0VfU0VDVVJFX0JPT1RfRU5fTUFTS31hc3luYyBnZXRLZXlCbG9ja1B1cnBvc2UoZSxBKXtpZihBPDB8fEE+dGhpcy5FRlVTRV9NQVhfS0VZKXtlLmRlYnVnKGBWYWxpZCBrZXkgYmxvY2sgbnVtYmVycyBtdXN0IGJlIGluIHJhbmdlIDAtJHt0aGlzLkVGVVNFX01BWF9LRVl9YCk7cmV0dXJufWxldCBpPVtbdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTBfUkVHLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkwX1NISUZUXSxbdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTFfUkVHLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkxX1NISUZUXSxbdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTJfUkVHLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkyX1NISUZUXSxbdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTNfUkVHLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVkzX1NISUZUXSxbdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTRfUkVHLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk0X1NISUZUXSxbdGhpcy5FRlVTRV9QVVJQT1NFX0tFWTVfUkVHLHRoaXMuRUZVU0VfUFVSUE9TRV9LRVk1X1NISUZUXV0sW3MsYV09aVtBXTtyZXR1cm4gYXdhaXQgZS5yZWFkUmVnKHMpPj5hJjE1fWFzeW5jIGlzRmxhc2hFbmNyeXB0aW9uS2V5VmFsaWQoZSl7bGV0IEE9W107Zm9yKGxldCBuPTA7bjw9dGhpcy5FRlVTRV9NQVhfS0VZO24rKyl7bGV0IEU9YXdhaXQgdGhpcy5nZXRLZXlCbG9ja1B1cnBvc2UoZSxuKTtBLnB1c2goRSl9aWYodHlwZW9mIEEuZmluZChuPT5uPT09dGhpcy5QVVJQT1NFX1ZBTF9YVFNfQUVTMTI4X0tFWSkhPT12b2lkIDApcmV0dXJuITA7bGV0IHM9QS5maW5kKG49Pm49PT10aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzEpLGE9QS5maW5kKG49Pm49PT10aGlzLlBVUlBPU0VfVkFMX1hUU19BRVMyNTZfS0VZXzIpO3JldHVybiB0eXBlb2YgcyE9PXZvaWQgMCYmdHlwZW9mIGEhPT12b2lkIDB9fX0pO3ZhciBVPWNsYXNzIGV4dGVuZHMgRXJyb3J7fTtmdW5jdGlvbiBkQSh0KXtsZXQgZT10Lmxlbmd0aDtmb3IoOy0tZT49MDspdFtlXT0wfXZhciBycz0wLGJlPTEsaHM9Mixvcz0zLGdzPTI1OCxIdD0yOSxiQT0yNTYscEE9YkErMStIdCxDQT0zMCx5dD0xOSxHZT0yKnBBKzEsbkE9MTUsY3Q9MTYsY3M9NyxZdD0yNTYsbWU9MTYsS2U9MTcsTGU9MTgsUXQ9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF0pLHR0PW5ldyBVaW50OEFycmF5KFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXSksQnM9bmV3IFVpbnQ4QXJyYXkoWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddKSxOZT1uZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pLHdzPTUxMixWPW5ldyBBcnJheSgocEErMikqMik7ZEEoVik7dmFyIHVBPW5ldyBBcnJheShDQSoyKTtkQSh1QSk7dmFyIFVBPW5ldyBBcnJheSh3cyk7ZEEoVUEpO3ZhciBQQT1uZXcgQXJyYXkoZ3Mtb3MrMSk7ZEEoUEEpO3ZhciBidD1uZXcgQXJyYXkoSHQpO2RBKGJ0KTt2YXIgZXQ9bmV3IEFycmF5KENBKTtkQShldCk7ZnVuY3Rpb24gQnQodCxlLEEsaSxzKXt0aGlzLnN0YXRpY190cmVlPXQsdGhpcy5leHRyYV9iaXRzPWUsdGhpcy5leHRyYV9iYXNlPUEsdGhpcy5lbGVtcz1pLHRoaXMubWF4X2xlbmd0aD1zLHRoaXMuaGFzX3N0cmVlPXQmJnQubGVuZ3RofXZhciBKZSx2ZSxXZTtmdW5jdGlvbiB3dCh0LGUpe3RoaXMuZHluX3RyZWU9dCx0aGlzLm1heF9jb2RlPTAsdGhpcy5zdGF0X2Rlc2M9ZX12YXIgemU9dD0+dDwyNTY/VUFbdF06VUFbMjU2Kyh0Pj4+NyldLGtBPSh0LGUpPT57dC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZSYyNTUsdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZT4+PjgmMjU1fSx5PSh0LGUsQSk9Pnt0LmJpX3ZhbGlkPmN0LUE/KHQuYmlfYnVmfD1lPDx0LmJpX3ZhbGlkJjY1NTM1LGtBKHQsdC5iaV9idWYpLHQuYmlfYnVmPWU+PmN0LXQuYmlfdmFsaWQsdC5iaV92YWxpZCs9QS1jdCk6KHQuYmlfYnVmfD1lPDx0LmJpX3ZhbGlkJjY1NTM1LHQuYmlfdmFsaWQrPUEpfSxXPSh0LGUsQSk9Pnt5KHQsQVtlKjJdLEFbZSoyKzFdKX0samU9KHQsZSk9PntsZXQgQT0wO2RvIEF8PXQmMSx0Pj4+PTEsQTw8PTE7d2hpbGUoLS1lPjApO3JldHVybiBBPj4+MX0sX3M9dD0+e3QuYmlfdmFsaWQ9PT0xNj8oa0EodCx0LmJpX2J1ZiksdC5iaV9idWY9MCx0LmJpX3ZhbGlkPTApOnQuYmlfdmFsaWQ+PTgmJih0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT10LmJpX2J1ZiYyNTUsdC5iaV9idWY+Pj04LHQuYmlfdmFsaWQtPTgpfSxmcz0odCxlKT0+e2xldCBBPWUuZHluX3RyZWUsaT1lLm1heF9jb2RlLHM9ZS5zdGF0X2Rlc2Muc3RhdGljX3RyZWUsYT1lLnN0YXRfZGVzYy5oYXNfc3RyZWUsbj1lLnN0YXRfZGVzYy5leHRyYV9iaXRzLEU9ZS5zdGF0X2Rlc2MuZXh0cmFfYmFzZSxvPWUuc3RhdF9kZXNjLm1heF9sZW5ndGgscixoLHcsYyxnLGYsRj0wO2ZvcihjPTA7Yzw9bkE7YysrKXQuYmxfY291bnRbY109MDtmb3IoQVt0LmhlYXBbdC5oZWFwX21heF0qMisxXT0wLHI9dC5oZWFwX21heCsxO3I8R2U7cisrKWg9dC5oZWFwW3JdLGM9QVtBW2gqMisxXSoyKzFdKzEsYz5vJiYoYz1vLEYrKyksQVtoKjIrMV09YywhKGg+aSkmJih0LmJsX2NvdW50W2NdKyssZz0wLGg+PUUmJihnPW5baC1FXSksZj1BW2gqMl0sdC5vcHRfbGVuKz1mKihjK2cpLGEmJih0LnN0YXRpY19sZW4rPWYqKHNbaCoyKzFdK2cpKSk7aWYoRiE9PTApe2Rve2ZvcihjPW8tMTt0LmJsX2NvdW50W2NdPT09MDspYy0tO3QuYmxfY291bnRbY10tLSx0LmJsX2NvdW50W2MrMV0rPTIsdC5ibF9jb3VudFtvXS0tLEYtPTJ9d2hpbGUoRj4wKTtmb3IoYz1vO2MhPT0wO2MtLSlmb3IoaD10LmJsX2NvdW50W2NdO2ghPT0wOyl3PXQuaGVhcFstLXJdLCEodz5pKSYmKEFbdyoyKzFdIT09YyYmKHQub3B0X2xlbis9KGMtQVt3KjIrMV0pKkFbdyoyXSxBW3cqMisxXT1jKSxoLS0pfX0sWmU9KHQsZSxBKT0+e2xldCBpPW5ldyBBcnJheShuQSsxKSxzPTAsYSxuO2ZvcihhPTE7YTw9bkE7YSsrKXM9cytBW2EtMV08PDEsaVthXT1zO2ZvcihuPTA7bjw9ZTtuKyspe2xldCBFPXRbbioyKzFdO0UhPT0wJiYodFtuKjJdPWplKGlbRV0rKyxFKSl9fSxDcz0oKT0+e2xldCB0LGUsQSxpLHMsYT1uZXcgQXJyYXkobkErMSk7Zm9yKEE9MCxpPTA7aTxIdC0xO2krKylmb3IoYnRbaV09QSx0PTA7dDwxPDxRdFtpXTt0KyspUEFbQSsrXT1pO2ZvcihQQVtBLTFdPWkscz0wLGk9MDtpPDE2O2krKylmb3IoZXRbaV09cyx0PTA7dDwxPDx0dFtpXTt0KyspVUFbcysrXT1pO2ZvcihzPj49NztpPENBO2krKylmb3IoZXRbaV09czw8Nyx0PTA7dDwxPDx0dFtpXS03O3QrKylVQVsyNTYrcysrXT1pO2ZvcihlPTA7ZTw9bkE7ZSsrKWFbZV09MDtmb3IodD0wO3Q8PTE0MzspVlt0KjIrMV09OCx0KyssYVs4XSsrO2Zvcig7dDw9MjU1OylWW3QqMisxXT05LHQrKyxhWzldKys7Zm9yKDt0PD0yNzk7KVZbdCoyKzFdPTcsdCsrLGFbN10rKztmb3IoO3Q8PTI4NzspVlt0KjIrMV09OCx0KyssYVs4XSsrO2ZvcihaZShWLHBBKzEsYSksdD0wO3Q8Q0E7dCsrKXVBW3QqMisxXT01LHVBW3QqMl09amUodCw1KTtKZT1uZXcgQnQoVixRdCxiQSsxLHBBLG5BKSx2ZT1uZXcgQnQodUEsdHQsMCxDQSxuQSksV2U9bmV3IEJ0KG5ldyBBcnJheSgwKSxCcywwLHl0LGNzKX0sWGU9dD0+e2xldCBlO2ZvcihlPTA7ZTxwQTtlKyspdC5keW5fbHRyZWVbZSoyXT0wO2ZvcihlPTA7ZTxDQTtlKyspdC5keW5fZHRyZWVbZSoyXT0wO2ZvcihlPTA7ZTx5dDtlKyspdC5ibF90cmVlW2UqMl09MDt0LmR5bl9sdHJlZVtZdCoyXT0xLHQub3B0X2xlbj10LnN0YXRpY19sZW49MCx0LnN5bV9uZXh0PXQubWF0Y2hlcz0wfSxWZT10PT57dC5iaV92YWxpZD44P2tBKHQsdC5iaV9idWYpOnQuYmlfdmFsaWQ+MCYmKHQucGVuZGluZ19idWZbdC5wZW5kaW5nKytdPXQuYmlfYnVmKSx0LmJpX2J1Zj0wLHQuYmlfdmFsaWQ9MH0sQWU9KHQsZSxBLGkpPT57bGV0IHM9ZSoyLGE9QSoyO3JldHVybiB0W3NdPHRbYV18fHRbc109PT10W2FdJiZpW2VdPD1pW0FdfSxfdD0odCxlLEEpPT57bGV0IGk9dC5oZWFwW0FdLHM9QTw8MTtmb3IoO3M8PXQuaGVhcF9sZW4mJihzPHQuaGVhcF9sZW4mJkFlKGUsdC5oZWFwW3MrMV0sdC5oZWFwW3NdLHQuZGVwdGgpJiZzKyssIUFlKGUsaSx0LmhlYXBbc10sdC5kZXB0aCkpOyl0LmhlYXBbQV09dC5oZWFwW3NdLEE9cyxzPDw9MTt0LmhlYXBbQV09aX0sdGU9KHQsZSxBKT0+e2xldCBpLHMsYT0wLG4sRTtpZih0LnN5bV9uZXh0IT09MClkbyBpPXQucGVuZGluZ19idWZbdC5zeW1fYnVmK2ErK10mMjU1LGkrPSh0LnBlbmRpbmdfYnVmW3Quc3ltX2J1ZithKytdJjI1NSk8PDgscz10LnBlbmRpbmdfYnVmW3Quc3ltX2J1ZithKytdLGk9PT0wP1codCxzLGUpOihuPVBBW3NdLFcodCxuK2JBKzEsZSksRT1RdFtuXSxFIT09MCYmKHMtPWJ0W25dLHkodCxzLEUpKSxpLS0sbj16ZShpKSxXKHQsbixBKSxFPXR0W25dLEUhPT0wJiYoaS09ZXRbbl0seSh0LGksRSkpKTt3aGlsZShhPHQuc3ltX25leHQpO1codCxZdCxlKX0sdXQ9KHQsZSk9PntsZXQgQT1lLmR5bl90cmVlLGk9ZS5zdGF0X2Rlc2Muc3RhdGljX3RyZWUscz1lLnN0YXRfZGVzYy5oYXNfc3RyZWUsYT1lLnN0YXRfZGVzYy5lbGVtcyxuLEUsbz0tMSxyO2Zvcih0LmhlYXBfbGVuPTAsdC5oZWFwX21heD1HZSxuPTA7bjxhO24rKylBW24qMl0hPT0wPyh0LmhlYXBbKyt0LmhlYXBfbGVuXT1vPW4sdC5kZXB0aFtuXT0wKTpBW24qMisxXT0wO2Zvcig7dC5oZWFwX2xlbjwyOylyPXQuaGVhcFsrK3QuaGVhcF9sZW5dPW88Mj8rK286MCxBW3IqMl09MSx0LmRlcHRoW3JdPTAsdC5vcHRfbGVuLS0scyYmKHQuc3RhdGljX2xlbi09aVtyKjIrMV0pO2ZvcihlLm1heF9jb2RlPW8sbj10LmhlYXBfbGVuPj4xO24+PTE7bi0tKV90KHQsQSxuKTtyPWE7ZG8gbj10LmhlYXBbMV0sdC5oZWFwWzFdPXQuaGVhcFt0LmhlYXBfbGVuLS1dLF90KHQsQSwxKSxFPXQuaGVhcFsxXSx0LmhlYXBbLS10LmhlYXBfbWF4XT1uLHQuaGVhcFstLXQuaGVhcF9tYXhdPUUsQVtyKjJdPUFbbioyXStBW0UqMl0sdC5kZXB0aFtyXT0odC5kZXB0aFtuXT49dC5kZXB0aFtFXT90LmRlcHRoW25dOnQuZGVwdGhbRV0pKzEsQVtuKjIrMV09QVtFKjIrMV09cix0LmhlYXBbMV09cisrLF90KHQsQSwxKTt3aGlsZSh0LmhlYXBfbGVuPj0yKTt0LmhlYXBbLS10LmhlYXBfbWF4XT10LmhlYXBbMV0sZnModCxlKSxaZShBLG8sdC5ibF9jb3VudCl9LGVlPSh0LGUsQSk9PntsZXQgaSxzPS0xLGEsbj1lWzFdLEU9MCxvPTcscj00O2ZvcihuPT09MCYmKG89MTM4LHI9MyksZVsoQSsxKSoyKzFdPTY1NTM1LGk9MDtpPD1BO2krKylhPW4sbj1lWyhpKzEpKjIrMV0sISgrK0U8byYmYT09PW4pJiYoRTxyP3QuYmxfdHJlZVthKjJdKz1FOmEhPT0wPyhhIT09cyYmdC5ibF90cmVlW2EqMl0rKyx0LmJsX3RyZWVbbWUqMl0rKyk6RTw9MTA/dC5ibF90cmVlW0tlKjJdKys6dC5ibF90cmVlW0xlKjJdKyssRT0wLHM9YSxuPT09MD8obz0xMzgscj0zKTphPT09bj8obz02LHI9Myk6KG89NyxyPTQpKX0saWU9KHQsZSxBKT0+e2xldCBpLHM9LTEsYSxuPWVbMV0sRT0wLG89NyxyPTQ7Zm9yKG49PT0wJiYobz0xMzgscj0zKSxpPTA7aTw9QTtpKyspaWYoYT1uLG49ZVsoaSsxKSoyKzFdLCEoKytFPG8mJmE9PT1uKSl7aWYoRTxyKWRvIFcodCxhLHQuYmxfdHJlZSk7d2hpbGUoLS1FIT09MCk7ZWxzZSBhIT09MD8oYSE9PXMmJihXKHQsYSx0LmJsX3RyZWUpLEUtLSksVyh0LG1lLHQuYmxfdHJlZSkseSh0LEUtMywyKSk6RTw9MTA/KFcodCxLZSx0LmJsX3RyZWUpLHkodCxFLTMsMykpOihXKHQsTGUsdC5ibF90cmVlKSx5KHQsRS0xMSw3KSk7RT0wLHM9YSxuPT09MD8obz0xMzgscj0zKTphPT09bj8obz02LHI9Myk6KG89NyxyPTQpfX0sSXM9dD0+e2xldCBlO2ZvcihlZSh0LHQuZHluX2x0cmVlLHQubF9kZXNjLm1heF9jb2RlKSxlZSh0LHQuZHluX2R0cmVlLHQuZF9kZXNjLm1heF9jb2RlKSx1dCh0LHQuYmxfZGVzYyksZT15dC0xO2U+PTMmJnQuYmxfdHJlZVtOZVtlXSoyKzFdPT09MDtlLS0pO3JldHVybiB0Lm9wdF9sZW4rPTMqKGUrMSkrNSs1KzQsZX0sbHM9KHQsZSxBLGkpPT57bGV0IHM7Zm9yKHkodCxlLTI1Nyw1KSx5KHQsQS0xLDUpLHkodCxpLTQsNCkscz0wO3M8aTtzKyspeSh0LHQuYmxfdHJlZVtOZVtzXSoyKzFdLDMpO2llKHQsdC5keW5fbHRyZWUsZS0xKSxpZSh0LHQuZHluX2R0cmVlLEEtMSl9LGRzPXQ9PntsZXQgZT00MDkzNjI0NDQ3LEE7Zm9yKEE9MDtBPD0zMTtBKyssZT4+Pj0xKWlmKGUmMSYmdC5keW5fbHRyZWVbQSoyXSE9PTApcmV0dXJuIDA7aWYodC5keW5fbHRyZWVbMThdIT09MHx8dC5keW5fbHRyZWVbMjBdIT09MHx8dC5keW5fbHRyZWVbMjZdIT09MClyZXR1cm4gMTtmb3IoQT0zMjtBPGJBO0ErKylpZih0LmR5bl9sdHJlZVtBKjJdIT09MClyZXR1cm4gMTtyZXR1cm4gMH0sc2U9ITEsU3M9dD0+e3NlfHwoQ3MoKSxzZT0hMCksdC5sX2Rlc2M9bmV3IHd0KHQuZHluX2x0cmVlLEplKSx0LmRfZGVzYz1uZXcgd3QodC5keW5fZHRyZWUsdmUpLHQuYmxfZGVzYz1uZXcgd3QodC5ibF90cmVlLFdlKSx0LmJpX2J1Zj0wLHQuYmlfdmFsaWQ9MCxYZSh0KX0scWU9KHQsZSxBLGkpPT57eSh0LChyczw8MSkrKGk/MTowKSwzKSxWZSh0KSxrQSh0LEEpLGtBKHQsfkEpLEEmJnQucGVuZGluZ19idWYuc2V0KHQud2luZG93LnN1YmFycmF5KGUsZStBKSx0LnBlbmRpbmcpLHQucGVuZGluZys9QX0sRHM9dD0+e3kodCxiZTw8MSwzKSxXKHQsWXQsViksX3ModCl9LFJzPSh0LGUsQSxpKT0+e2xldCBzLGEsbj0wO3QubGV2ZWw+MD8odC5zdHJtLmRhdGFfdHlwZT09PTImJih0LnN0cm0uZGF0YV90eXBlPWRzKHQpKSx1dCh0LHQubF9kZXNjKSx1dCh0LHQuZF9kZXNjKSxuPUlzKHQpLHM9dC5vcHRfbGVuKzMrNz4+PjMsYT10LnN0YXRpY19sZW4rMys3Pj4+MyxhPD1zJiYocz1hKSk6cz1hPUErNSxBKzQ8PXMmJmUhPT0tMT9xZSh0LGUsQSxpKTp0LnN0cmF0ZWd5PT09NHx8YT09PXM/KHkodCwoYmU8PDEpKyhpPzE6MCksMyksdGUodCxWLHVBKSk6KHkodCwoaHM8PDEpKyhpPzE6MCksMyksbHModCx0LmxfZGVzYy5tYXhfY29kZSsxLHQuZF9kZXNjLm1heF9jb2RlKzEsbisxKSx0ZSh0LHQuZHluX2x0cmVlLHQuZHluX2R0cmVlKSksWGUodCksaSYmVmUodCl9LE1zPSh0LGUsQSk9Pih0LnBlbmRpbmdfYnVmW3Quc3ltX2J1Zit0LnN5bV9uZXh0KytdPWUsdC5wZW5kaW5nX2J1Zlt0LnN5bV9idWYrdC5zeW1fbmV4dCsrXT1lPj44LHQucGVuZGluZ19idWZbdC5zeW1fYnVmK3Quc3ltX25leHQrK109QSxlPT09MD90LmR5bl9sdHJlZVtBKjJdKys6KHQubWF0Y2hlcysrLGUtLSx0LmR5bl9sdHJlZVsoUEFbQV0rYkErMSkqMl0rKyx0LmR5bl9kdHJlZVt6ZShlKSoyXSsrKSx0LnN5bV9uZXh0PT09dC5zeW1fZW5kKSx4cz1TcyxRcz1xZSx1cz1ScyxGcz1NcyxUcz1Ecyxwcz17X3RyX2luaXQ6eHMsX3RyX3N0b3JlZF9ibG9jazpRcyxfdHJfZmx1c2hfYmxvY2s6dXMsX3RyX3RhbGx5OkZzLF90cl9hbGlnbjpUc30sVXM9KHQsZSxBLGkpPT57bGV0IHM9dCY2NTUzNXwwLGE9dD4+PjE2JjY1NTM1fDAsbj0wO2Zvcig7QSE9PTA7KXtuPUE+MmUzPzJlMzpBLEEtPW47ZG8gcz1zK2VbaSsrXXwwLGE9YStzfDA7d2hpbGUoLS1uKTtzJT02NTUyMSxhJT02NTUyMX1yZXR1cm4gc3xhPDwxNnwwfSxPQT1VcyxQcz0oKT0+e2xldCB0LGU9W107Zm9yKHZhciBBPTA7QTwyNTY7QSsrKXt0PUE7Zm9yKHZhciBpPTA7aTw4O2krKyl0PXQmMT8zOTg4MjkyMzg0XnQ+Pj4xOnQ+Pj4xO2VbQV09dH1yZXR1cm4gZX0sa3M9bmV3IFVpbnQzMkFycmF5KFBzKCkpLE9zPSh0LGUsQSxpKT0+e2xldCBzPWtzLGE9aStBO3RePS0xO2ZvcihsZXQgbj1pO248YTtuKyspdD10Pj4+OF5zWyh0XmVbbl0pJjI1NV07cmV0dXJuIHReLTF9LFA9T3MsaEE9ezI6Im5lZWQgZGljdGlvbmFyeSIsMToic3RyZWFtIGVuZCIsMDoiIiwiLTEiOiJmaWxlIGVycm9yIiwiLTIiOiJzdHJlYW0gZXJyb3IiLCItMyI6ImRhdGEgZXJyb3IiLCItNCI6Imluc3VmZmljaWVudCBtZW1vcnkiLCItNSI6ImJ1ZmZlciBlcnJvciIsIi02IjoiaW5jb21wYXRpYmxlIHZlcnNpb24ifSxTQT17Wl9OT19GTFVTSDowLFpfUEFSVElBTF9GTFVTSDoxLFpfU1lOQ19GTFVTSDoyLFpfRlVMTF9GTFVTSDozLFpfRklOSVNIOjQsWl9CTE9DSzo1LFpfVFJFRVM6NixaX09LOjAsWl9TVFJFQU1fRU5EOjEsWl9ORUVEX0RJQ1Q6MixaX0VSUk5POi0xLFpfU1RSRUFNX0VSUk9SOi0yLFpfREFUQV9FUlJPUjotMyxaX01FTV9FUlJPUjotNCxaX0JVRl9FUlJPUjotNSxaX05PX0NPTVBSRVNTSU9OOjAsWl9CRVNUX1NQRUVEOjEsWl9CRVNUX0NPTVBSRVNTSU9OOjksWl9ERUZBVUxUX0NPTVBSRVNTSU9OOi0xLFpfRklMVEVSRUQ6MSxaX0hVRkZNQU5fT05MWToyLFpfUkxFOjMsWl9GSVhFRDo0LFpfREVGQVVMVF9TVFJBVEVHWTowLFpfQklOQVJZOjAsWl9URVhUOjEsWl9VTktOT1dOOjIsWl9ERUZMQVRFRDo4fSx7X3RyX2luaXQ6SHMsX3RyX3N0b3JlZF9ibG9jazpGdCxfdHJfZmx1c2hfYmxvY2s6eXMsX3RyX3RhbGx5OmlBLF90cl9hbGlnbjpZc309cHMse1pfTk9fRkxVU0g6c0EsWl9QQVJUSUFMX0ZMVVNIOmJzLFpfRlVMTF9GTFVTSDpHcyxaX0ZJTklTSDpMLFpfQkxPQ0s6YWUsWl9PSzprLFpfU1RSRUFNX0VORDpuZSxaX1NUUkVBTV9FUlJPUjp6LFpfREFUQV9FUlJPUjptcyxaX0JVRl9FUlJPUjpmdCxaX0RFRkFVTFRfQ09NUFJFU1NJT046S3MsWl9GSUxURVJFRDpMcyxaX0hVRkZNQU5fT05MWTpYQSxaX1JMRTpOcyxaX0ZJWEVEOkpzLFpfREVGQVVMVF9TVFJBVEVHWTp2cyxaX1VOS05PV046V3MsWl9ERUZMQVRFRDphdH09U0EsenM9OSxqcz0xNSxacz04LFhzPTI5LFZzPTI1NixUdD1WcysxK1hzLHFzPTMwLCRzPTE5LEFhPTIqVHQrMSx0YT0xNSx4PTMsZUE9MjU4LGo9ZUEreCsxLGVhPTMyLElBPTQyLEd0PTU3LHB0PTY5LFV0PTczLFB0PTkxLGt0PTEwMyxFQT0xMTMseEE9NjY2LEg9MSxEQT0yLG9BPTMsUkE9NCxpYT0zLHJBPSh0LGUpPT4odC5tc2c9aEFbZV0sZSksRWU9dD0+dCoyLSh0PjQ/OTowKSx0QT10PT57bGV0IGU9dC5sZW5ndGg7Zm9yKDstLWU+PTA7KXRbZV09MH0sc2E9dD0+e2xldCBlLEEsaSxzPXQud19zaXplO2U9dC5oYXNoX3NpemUsaT1lO2RvIEE9dC5oZWFkWy0taV0sdC5oZWFkW2ldPUE+PXM/QS1zOjA7d2hpbGUoLS1lKTtlPXMsaT1lO2RvIEE9dC5wcmV2Wy0taV0sdC5wcmV2W2ldPUE+PXM/QS1zOjA7d2hpbGUoLS1lKX0sYWE9KHQsZSxBKT0+KGU8PHQuaGFzaF9zaGlmdF5BKSZ0Lmhhc2hfbWFzayxhQT1hYSxZPXQ9PntsZXQgZT10LnN0YXRlLEE9ZS5wZW5kaW5nO0E+dC5hdmFpbF9vdXQmJihBPXQuYXZhaWxfb3V0KSxBIT09MCYmKHQub3V0cHV0LnNldChlLnBlbmRpbmdfYnVmLnN1YmFycmF5KGUucGVuZGluZ19vdXQsZS5wZW5kaW5nX291dCtBKSx0Lm5leHRfb3V0KSx0Lm5leHRfb3V0Kz1BLGUucGVuZGluZ19vdXQrPUEsdC50b3RhbF9vdXQrPUEsdC5hdmFpbF9vdXQtPUEsZS5wZW5kaW5nLT1BLGUucGVuZGluZz09PTAmJihlLnBlbmRpbmdfb3V0PTApKX0sYj0odCxlKT0+e3lzKHQsdC5ibG9ja19zdGFydD49MD90LmJsb2NrX3N0YXJ0Oi0xLHQuc3Ryc3RhcnQtdC5ibG9ja19zdGFydCxlKSx0LmJsb2NrX3N0YXJ0PXQuc3Ryc3RhcnQsWSh0LnN0cm0pfSx1PSh0LGUpPT57dC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZX0sTUE9KHQsZSk9Pnt0LnBlbmRpbmdfYnVmW3QucGVuZGluZysrXT1lPj4+OCYyNTUsdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmcrK109ZSYyNTV9LE90PSh0LGUsQSxpKT0+e2xldCBzPXQuYXZhaWxfaW47cmV0dXJuIHM+aSYmKHM9aSkscz09PTA/MDoodC5hdmFpbF9pbi09cyxlLnNldCh0LmlucHV0LnN1YmFycmF5KHQubmV4dF9pbix0Lm5leHRfaW4rcyksQSksdC5zdGF0ZS53cmFwPT09MT90LmFkbGVyPU9BKHQuYWRsZXIsZSxzLEEpOnQuc3RhdGUud3JhcD09PTImJih0LmFkbGVyPVAodC5hZGxlcixlLHMsQSkpLHQubmV4dF9pbis9cyx0LnRvdGFsX2luKz1zLHMpfSwkZT0odCxlKT0+e2xldCBBPXQubWF4X2NoYWluX2xlbmd0aCxpPXQuc3Ryc3RhcnQscyxhLG49dC5wcmV2X2xlbmd0aCxFPXQubmljZV9tYXRjaCxvPXQuc3Ryc3RhcnQ+dC53X3NpemUtaj90LnN0cnN0YXJ0LSh0Lndfc2l6ZS1qKTowLHI9dC53aW5kb3csaD10LndfbWFzayx3PXQucHJldixjPXQuc3Ryc3RhcnQrZUEsZz1yW2krbi0xXSxmPXJbaStuXTt0LnByZXZfbGVuZ3RoPj10Lmdvb2RfbWF0Y2gmJihBPj49MiksRT50Lmxvb2thaGVhZCYmKEU9dC5sb29rYWhlYWQpO2RvIGlmKHM9ZSwhKHJbcytuXSE9PWZ8fHJbcytuLTFdIT09Z3x8cltzXSE9PXJbaV18fHJbKytzXSE9PXJbaSsxXSkpe2krPTIscysrO2RvO3doaWxlKHJbKytpXT09PXJbKytzXSYmclsrK2ldPT09clsrK3NdJiZyWysraV09PT1yWysrc10mJnJbKytpXT09PXJbKytzXSYmclsrK2ldPT09clsrK3NdJiZyWysraV09PT1yWysrc10mJnJbKytpXT09PXJbKytzXSYmclsrK2ldPT09clsrK3NdJiZpPGMpO2lmKGE9ZUEtKGMtaSksaT1jLWVBLGE+bil7aWYodC5tYXRjaF9zdGFydD1lLG49YSxhPj1FKWJyZWFrO2c9cltpK24tMV0sZj1yW2krbl19fXdoaWxlKChlPXdbZSZoXSk+byYmLS1BIT09MCk7cmV0dXJuIG48PXQubG9va2FoZWFkP246dC5sb29rYWhlYWR9LGxBPXQ9PntsZXQgZT10Lndfc2l6ZSxBLGkscztkb3tpZihpPXQud2luZG93X3NpemUtdC5sb29rYWhlYWQtdC5zdHJzdGFydCx0LnN0cnN0YXJ0Pj1lKyhlLWopJiYodC53aW5kb3cuc2V0KHQud2luZG93LnN1YmFycmF5KGUsZStlLWkpLDApLHQubWF0Y2hfc3RhcnQtPWUsdC5zdHJzdGFydC09ZSx0LmJsb2NrX3N0YXJ0LT1lLHQuaW5zZXJ0PnQuc3Ryc3RhcnQmJih0Lmluc2VydD10LnN0cnN0YXJ0KSxzYSh0KSxpKz1lKSx0LnN0cm0uYXZhaWxfaW49PT0wKWJyZWFrO2lmKEE9T3QodC5zdHJtLHQud2luZG93LHQuc3Ryc3RhcnQrdC5sb29rYWhlYWQsaSksdC5sb29rYWhlYWQrPUEsdC5sb29rYWhlYWQrdC5pbnNlcnQ+PXgpZm9yKHM9dC5zdHJzdGFydC10Lmluc2VydCx0Lmluc19oPXQud2luZG93W3NdLHQuaW5zX2g9YUEodCx0Lmluc19oLHQud2luZG93W3MrMV0pO3QuaW5zZXJ0JiYodC5pbnNfaD1hQSh0LHQuaW5zX2gsdC53aW5kb3dbcyt4LTFdKSx0LnByZXZbcyZ0LndfbWFza109dC5oZWFkW3QuaW5zX2hdLHQuaGVhZFt0Lmluc19oXT1zLHMrKyx0Lmluc2VydC0tLCEodC5sb29rYWhlYWQrdC5pbnNlcnQ8eCkpOyk7fXdoaWxlKHQubG9va2FoZWFkPGomJnQuc3RybS5hdmFpbF9pbiE9PTApfSxBaT0odCxlKT0+e2xldCBBPXQucGVuZGluZ19idWZfc2l6ZS01PnQud19zaXplP3Qud19zaXplOnQucGVuZGluZ19idWZfc2l6ZS01LGkscyxhLG49MCxFPXQuc3RybS5hdmFpbF9pbjtkb3tpZihpPTY1NTM1LGE9dC5iaV92YWxpZCs0Mj4+Myx0LnN0cm0uYXZhaWxfb3V0PGF8fChhPXQuc3RybS5hdmFpbF9vdXQtYSxzPXQuc3Ryc3RhcnQtdC5ibG9ja19zdGFydCxpPnMrdC5zdHJtLmF2YWlsX2luJiYoaT1zK3Quc3RybS5hdmFpbF9pbiksaT5hJiYoaT1hKSxpPEEmJihpPT09MCYmZSE9PUx8fGU9PT1zQXx8aSE9PXMrdC5zdHJtLmF2YWlsX2luKSkpYnJlYWs7bj1lPT09TCYmaT09PXMrdC5zdHJtLmF2YWlsX2luPzE6MCxGdCh0LDAsMCxuKSx0LnBlbmRpbmdfYnVmW3QucGVuZGluZy00XT1pLHQucGVuZGluZ19idWZbdC5wZW5kaW5nLTNdPWk+PjgsdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmctMl09fmksdC5wZW5kaW5nX2J1Zlt0LnBlbmRpbmctMV09fmk+PjgsWSh0LnN0cm0pLHMmJihzPmkmJihzPWkpLHQuc3RybS5vdXRwdXQuc2V0KHQud2luZG93LnN1YmFycmF5KHQuYmxvY2tfc3RhcnQsdC5ibG9ja19zdGFydCtzKSx0LnN0cm0ubmV4dF9vdXQpLHQuc3RybS5uZXh0X291dCs9cyx0LnN0cm0uYXZhaWxfb3V0LT1zLHQuc3RybS50b3RhbF9vdXQrPXMsdC5ibG9ja19zdGFydCs9cyxpLT1zKSxpJiYoT3QodC5zdHJtLHQuc3RybS5vdXRwdXQsdC5zdHJtLm5leHRfb3V0LGkpLHQuc3RybS5uZXh0X291dCs9aSx0LnN0cm0uYXZhaWxfb3V0LT1pLHQuc3RybS50b3RhbF9vdXQrPWkpfXdoaWxlKG49PT0wKTtyZXR1cm4gRS09dC5zdHJtLmF2YWlsX2luLEUmJihFPj10Lndfc2l6ZT8odC5tYXRjaGVzPTIsdC53aW5kb3cuc2V0KHQuc3RybS5pbnB1dC5zdWJhcnJheSh0LnN0cm0ubmV4dF9pbi10Lndfc2l6ZSx0LnN0cm0ubmV4dF9pbiksMCksdC5zdHJzdGFydD10Lndfc2l6ZSx0Lmluc2VydD10LnN0cnN0YXJ0KToodC53aW5kb3dfc2l6ZS10LnN0cnN0YXJ0PD1FJiYodC5zdHJzdGFydC09dC53X3NpemUsdC53aW5kb3cuc2V0KHQud2luZG93LnN1YmFycmF5KHQud19zaXplLHQud19zaXplK3Quc3Ryc3RhcnQpLDApLHQubWF0Y2hlczwyJiZ0Lm1hdGNoZXMrKyx0Lmluc2VydD50LnN0cnN0YXJ0JiYodC5pbnNlcnQ9dC5zdHJzdGFydCkpLHQud2luZG93LnNldCh0LnN0cm0uaW5wdXQuc3ViYXJyYXkodC5zdHJtLm5leHRfaW4tRSx0LnN0cm0ubmV4dF9pbiksdC5zdHJzdGFydCksdC5zdHJzdGFydCs9RSx0Lmluc2VydCs9RT50Lndfc2l6ZS10Lmluc2VydD90Lndfc2l6ZS10Lmluc2VydDpFKSx0LmJsb2NrX3N0YXJ0PXQuc3Ryc3RhcnQpLHQuaGlnaF93YXRlcjx0LnN0cnN0YXJ0JiYodC5oaWdoX3dhdGVyPXQuc3Ryc3RhcnQpLG4/UkE6ZSE9PXNBJiZlIT09TCYmdC5zdHJtLmF2YWlsX2luPT09MCYmdC5zdHJzdGFydD09PXQuYmxvY2tfc3RhcnQ/REE6KGE9dC53aW5kb3dfc2l6ZS10LnN0cnN0YXJ0LHQuc3RybS5hdmFpbF9pbj5hJiZ0LmJsb2NrX3N0YXJ0Pj10Lndfc2l6ZSYmKHQuYmxvY2tfc3RhcnQtPXQud19zaXplLHQuc3Ryc3RhcnQtPXQud19zaXplLHQud2luZG93LnNldCh0LndpbmRvdy5zdWJhcnJheSh0Lndfc2l6ZSx0Lndfc2l6ZSt0LnN0cnN0YXJ0KSwwKSx0Lm1hdGNoZXM8MiYmdC5tYXRjaGVzKyssYSs9dC53X3NpemUsdC5pbnNlcnQ+dC5zdHJzdGFydCYmKHQuaW5zZXJ0PXQuc3Ryc3RhcnQpKSxhPnQuc3RybS5hdmFpbF9pbiYmKGE9dC5zdHJtLmF2YWlsX2luKSxhJiYoT3QodC5zdHJtLHQud2luZG93LHQuc3Ryc3RhcnQsYSksdC5zdHJzdGFydCs9YSx0Lmluc2VydCs9YT50Lndfc2l6ZS10Lmluc2VydD90Lndfc2l6ZS10Lmluc2VydDphKSx0LmhpZ2hfd2F0ZXI8dC5zdHJzdGFydCYmKHQuaGlnaF93YXRlcj10LnN0cnN0YXJ0KSxhPXQuYmlfdmFsaWQrNDI+PjMsYT10LnBlbmRpbmdfYnVmX3NpemUtYT42NTUzNT82NTUzNTp0LnBlbmRpbmdfYnVmX3NpemUtYSxBPWE+dC53X3NpemU/dC53X3NpemU6YSxzPXQuc3Ryc3RhcnQtdC5ibG9ja19zdGFydCwocz49QXx8KHN8fGU9PT1MKSYmZSE9PXNBJiZ0LnN0cm0uYXZhaWxfaW49PT0wJiZzPD1hKSYmKGk9cz5hP2E6cyxuPWU9PT1MJiZ0LnN0cm0uYXZhaWxfaW49PT0wJiZpPT09cz8xOjAsRnQodCx0LmJsb2NrX3N0YXJ0LGksbiksdC5ibG9ja19zdGFydCs9aSxZKHQuc3RybSkpLG4/b0E6SCl9LEN0PSh0LGUpPT57bGV0IEEsaTtmb3IoOzspe2lmKHQubG9va2FoZWFkPGope2lmKGxBKHQpLHQubG9va2FoZWFkPGomJmU9PT1zQSlyZXR1cm4gSDtpZih0Lmxvb2thaGVhZD09PTApYnJlYWt9aWYoQT0wLHQubG9va2FoZWFkPj14JiYodC5pbnNfaD1hQSh0LHQuaW5zX2gsdC53aW5kb3dbdC5zdHJzdGFydCt4LTFdKSxBPXQucHJldlt0LnN0cnN0YXJ0JnQud19tYXNrXT10LmhlYWRbdC5pbnNfaF0sdC5oZWFkW3QuaW5zX2hdPXQuc3Ryc3RhcnQpLEEhPT0wJiZ0LnN0cnN0YXJ0LUE8PXQud19zaXplLWomJih0Lm1hdGNoX2xlbmd0aD0kZSh0LEEpKSx0Lm1hdGNoX2xlbmd0aD49eClpZihpPWlBKHQsdC5zdHJzdGFydC10Lm1hdGNoX3N0YXJ0LHQubWF0Y2hfbGVuZ3RoLXgpLHQubG9va2FoZWFkLT10Lm1hdGNoX2xlbmd0aCx0Lm1hdGNoX2xlbmd0aDw9dC5tYXhfbGF6eV9tYXRjaCYmdC5sb29rYWhlYWQ+PXgpe3QubWF0Y2hfbGVuZ3RoLS07ZG8gdC5zdHJzdGFydCsrLHQuaW5zX2g9YUEodCx0Lmluc19oLHQud2luZG93W3Quc3Ryc3RhcnQreC0xXSksQT10LnByZXZbdC5zdHJzdGFydCZ0LndfbWFza109dC5oZWFkW3QuaW5zX2hdLHQuaGVhZFt0Lmluc19oXT10LnN0cnN0YXJ0O3doaWxlKC0tdC5tYXRjaF9sZW5ndGghPT0wKTt0LnN0cnN0YXJ0Kyt9ZWxzZSB0LnN0cnN0YXJ0Kz10Lm1hdGNoX2xlbmd0aCx0Lm1hdGNoX2xlbmd0aD0wLHQuaW5zX2g9dC53aW5kb3dbdC5zdHJzdGFydF0sdC5pbnNfaD1hQSh0LHQuaW5zX2gsdC53aW5kb3dbdC5zdHJzdGFydCsxXSk7ZWxzZSBpPWlBKHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0XSksdC5sb29rYWhlYWQtLSx0LnN0cnN0YXJ0Kys7aWYoaSYmKGIodCwhMSksdC5zdHJtLmF2YWlsX291dD09PTApKXJldHVybiBIfXJldHVybiB0Lmluc2VydD10LnN0cnN0YXJ0PHgtMT90LnN0cnN0YXJ0OngtMSxlPT09TD8oYih0LCEwKSx0LnN0cm0uYXZhaWxfb3V0PT09MD9vQTpSQSk6dC5zeW1fbmV4dCYmKGIodCwhMSksdC5zdHJtLmF2YWlsX291dD09PTApP0g6REF9LF9BPSh0LGUpPT57bGV0IEEsaSxzO2Zvcig7Oyl7aWYodC5sb29rYWhlYWQ8ail7aWYobEEodCksdC5sb29rYWhlYWQ8aiYmZT09PXNBKXJldHVybiBIO2lmKHQubG9va2FoZWFkPT09MClicmVha31pZihBPTAsdC5sb29rYWhlYWQ+PXgmJih0Lmluc19oPWFBKHQsdC5pbnNfaCx0LndpbmRvd1t0LnN0cnN0YXJ0K3gtMV0pLEE9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydCksdC5wcmV2X2xlbmd0aD10Lm1hdGNoX2xlbmd0aCx0LnByZXZfbWF0Y2g9dC5tYXRjaF9zdGFydCx0Lm1hdGNoX2xlbmd0aD14LTEsQSE9PTAmJnQucHJldl9sZW5ndGg8dC5tYXhfbGF6eV9tYXRjaCYmdC5zdHJzdGFydC1BPD10Lndfc2l6ZS1qJiYodC5tYXRjaF9sZW5ndGg9JGUodCxBKSx0Lm1hdGNoX2xlbmd0aDw9NSYmKHQuc3RyYXRlZ3k9PT1Mc3x8dC5tYXRjaF9sZW5ndGg9PT14JiZ0LnN0cnN0YXJ0LXQubWF0Y2hfc3RhcnQ+NDA5NikmJih0Lm1hdGNoX2xlbmd0aD14LTEpKSx0LnByZXZfbGVuZ3RoPj14JiZ0Lm1hdGNoX2xlbmd0aDw9dC5wcmV2X2xlbmd0aCl7cz10LnN0cnN0YXJ0K3QubG9va2FoZWFkLXgsaT1pQSh0LHQuc3Ryc3RhcnQtMS10LnByZXZfbWF0Y2gsdC5wcmV2X2xlbmd0aC14KSx0Lmxvb2thaGVhZC09dC5wcmV2X2xlbmd0aC0xLHQucHJldl9sZW5ndGgtPTI7ZG8rK3Quc3Ryc3RhcnQ8PXMmJih0Lmluc19oPWFBKHQsdC5pbnNfaCx0LndpbmRvd1t0LnN0cnN0YXJ0K3gtMV0pLEE9dC5wcmV2W3Quc3Ryc3RhcnQmdC53X21hc2tdPXQuaGVhZFt0Lmluc19oXSx0LmhlYWRbdC5pbnNfaF09dC5zdHJzdGFydCk7d2hpbGUoLS10LnByZXZfbGVuZ3RoIT09MCk7aWYodC5tYXRjaF9hdmFpbGFibGU9MCx0Lm1hdGNoX2xlbmd0aD14LTEsdC5zdHJzdGFydCsrLGkmJihiKHQsITEpLHQuc3RybS5hdmFpbF9vdXQ9PT0wKSlyZXR1cm4gSH1lbHNlIGlmKHQubWF0Y2hfYXZhaWxhYmxlKXtpZihpPWlBKHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0LTFdKSxpJiZiKHQsITEpLHQuc3Ryc3RhcnQrKyx0Lmxvb2thaGVhZC0tLHQuc3RybS5hdmFpbF9vdXQ9PT0wKXJldHVybiBIfWVsc2UgdC5tYXRjaF9hdmFpbGFibGU9MSx0LnN0cnN0YXJ0KyssdC5sb29rYWhlYWQtLX1yZXR1cm4gdC5tYXRjaF9hdmFpbGFibGUmJihpPWlBKHQsMCx0LndpbmRvd1t0LnN0cnN0YXJ0LTFdKSx0Lm1hdGNoX2F2YWlsYWJsZT0wKSx0Lmluc2VydD10LnN0cnN0YXJ0PHgtMT90LnN0cnN0YXJ0OngtMSxlPT09TD8oYih0LCEwKSx0LnN0cm0uYXZhaWxfb3V0PT09MD9vQTpSQSk6dC5zeW1fbmV4dCYmKGIodCwhMSksdC5zdHJtLmF2YWlsX291dD09PTApP0g6REF9LG5hPSh0LGUpPT57bGV0IEEsaSxzLGEsbj10LndpbmRvdztmb3IoOzspe2lmKHQubG9va2FoZWFkPD1lQSl7aWYobEEodCksdC5sb29rYWhlYWQ8PWVBJiZlPT09c0EpcmV0dXJuIEg7aWYodC5sb29rYWhlYWQ9PT0wKWJyZWFrfWlmKHQubWF0Y2hfbGVuZ3RoPTAsdC5sb29rYWhlYWQ+PXgmJnQuc3Ryc3RhcnQ+MCYmKHM9dC5zdHJzdGFydC0xLGk9bltzXSxpPT09blsrK3NdJiZpPT09blsrK3NdJiZpPT09blsrK3NdKSl7YT10LnN0cnN0YXJ0K2VBO2RvO3doaWxlKGk9PT1uWysrc10mJmk9PT1uWysrc10mJmk9PT1uWysrc10mJmk9PT1uWysrc10mJmk9PT1uWysrc10mJmk9PT1uWysrc10mJmk9PT1uWysrc10mJmk9PT1uWysrc10mJnM8YSk7dC5tYXRjaF9sZW5ndGg9ZUEtKGEtcyksdC5tYXRjaF9sZW5ndGg+dC5sb29rYWhlYWQmJih0Lm1hdGNoX2xlbmd0aD10Lmxvb2thaGVhZCl9aWYodC5tYXRjaF9sZW5ndGg+PXg/KEE9aUEodCwxLHQubWF0Y2hfbGVuZ3RoLXgpLHQubG9va2FoZWFkLT10Lm1hdGNoX2xlbmd0aCx0LnN0cnN0YXJ0Kz10Lm1hdGNoX2xlbmd0aCx0Lm1hdGNoX2xlbmd0aD0wKTooQT1pQSh0LDAsdC53aW5kb3dbdC5zdHJzdGFydF0pLHQubG9va2FoZWFkLS0sdC5zdHJzdGFydCsrKSxBJiYoYih0LCExKSx0LnN0cm0uYXZhaWxfb3V0PT09MCkpcmV0dXJuIEh9cmV0dXJuIHQuaW5zZXJ0PTAsZT09PUw/KGIodCwhMCksdC5zdHJtLmF2YWlsX291dD09PTA/b0E6UkEpOnQuc3ltX25leHQmJihiKHQsITEpLHQuc3RybS5hdmFpbF9vdXQ9PT0wKT9IOkRBfSxFYT0odCxlKT0+e2xldCBBO2Zvcig7Oyl7aWYodC5sb29rYWhlYWQ9PT0wJiYobEEodCksdC5sb29rYWhlYWQ9PT0wKSl7aWYoZT09PXNBKXJldHVybiBIO2JyZWFrfWlmKHQubWF0Y2hfbGVuZ3RoPTAsQT1pQSh0LDAsdC53aW5kb3dbdC5zdHJzdGFydF0pLHQubG9va2FoZWFkLS0sdC5zdHJzdGFydCsrLEEmJihiKHQsITEpLHQuc3RybS5hdmFpbF9vdXQ9PT0wKSlyZXR1cm4gSH1yZXR1cm4gdC5pbnNlcnQ9MCxlPT09TD8oYih0LCEwKSx0LnN0cm0uYXZhaWxfb3V0PT09MD9vQTpSQSk6dC5zeW1fbmV4dCYmKGIodCwhMSksdC5zdHJtLmF2YWlsX291dD09PTApP0g6REF9O2Z1bmN0aW9uIHYodCxlLEEsaSxzKXt0aGlzLmdvb2RfbGVuZ3RoPXQsdGhpcy5tYXhfbGF6eT1lLHRoaXMubmljZV9sZW5ndGg9QSx0aGlzLm1heF9jaGFpbj1pLHRoaXMuZnVuYz1zfXZhciBRQT1bbmV3IHYoMCwwLDAsMCxBaSksbmV3IHYoNCw0LDgsNCxDdCksbmV3IHYoNCw1LDE2LDgsQ3QpLG5ldyB2KDQsNiwzMiwzMixDdCksbmV3IHYoNCw0LDE2LDE2LF9BKSxuZXcgdig4LDE2LDMyLDMyLF9BKSxuZXcgdig4LDE2LDEyOCwxMjgsX0EpLG5ldyB2KDgsMzIsMTI4LDI1NixfQSksbmV3IHYoMzIsMTI4LDI1OCwxMDI0LF9BKSxuZXcgdigzMiwyNTgsMjU4LDQwOTYsX0EpXSxyYT10PT57dC53aW5kb3dfc2l6ZT0yKnQud19zaXplLHRBKHQuaGVhZCksdC5tYXhfbGF6eV9tYXRjaD1RQVt0LmxldmVsXS5tYXhfbGF6eSx0Lmdvb2RfbWF0Y2g9UUFbdC5sZXZlbF0uZ29vZF9sZW5ndGgsdC5uaWNlX21hdGNoPVFBW3QubGV2ZWxdLm5pY2VfbGVuZ3RoLHQubWF4X2NoYWluX2xlbmd0aD1RQVt0LmxldmVsXS5tYXhfY2hhaW4sdC5zdHJzdGFydD0wLHQuYmxvY2tfc3RhcnQ9MCx0Lmxvb2thaGVhZD0wLHQuaW5zZXJ0PTAsdC5tYXRjaF9sZW5ndGg9dC5wcmV2X2xlbmd0aD14LTEsdC5tYXRjaF9hdmFpbGFibGU9MCx0Lmluc19oPTB9O2Z1bmN0aW9uIGhhKCl7dGhpcy5zdHJtPW51bGwsdGhpcy5zdGF0dXM9MCx0aGlzLnBlbmRpbmdfYnVmPW51bGwsdGhpcy5wZW5kaW5nX2J1Zl9zaXplPTAsdGhpcy5wZW5kaW5nX291dD0wLHRoaXMucGVuZGluZz0wLHRoaXMud3JhcD0wLHRoaXMuZ3poZWFkPW51bGwsdGhpcy5nemluZGV4PTAsdGhpcy5tZXRob2Q9YXQsdGhpcy5sYXN0X2ZsdXNoPS0xLHRoaXMud19zaXplPTAsdGhpcy53X2JpdHM9MCx0aGlzLndfbWFzaz0wLHRoaXMud2luZG93PW51bGwsdGhpcy53aW5kb3dfc2l6ZT0wLHRoaXMucHJldj1udWxsLHRoaXMuaGVhZD1udWxsLHRoaXMuaW5zX2g9MCx0aGlzLmhhc2hfc2l6ZT0wLHRoaXMuaGFzaF9iaXRzPTAsdGhpcy5oYXNoX21hc2s9MCx0aGlzLmhhc2hfc2hpZnQ9MCx0aGlzLmJsb2NrX3N0YXJ0PTAsdGhpcy5tYXRjaF9sZW5ndGg9MCx0aGlzLnByZXZfbWF0Y2g9MCx0aGlzLm1hdGNoX2F2YWlsYWJsZT0wLHRoaXMuc3Ryc3RhcnQ9MCx0aGlzLm1hdGNoX3N0YXJ0PTAsdGhpcy5sb29rYWhlYWQ9MCx0aGlzLnByZXZfbGVuZ3RoPTAsdGhpcy5tYXhfY2hhaW5fbGVuZ3RoPTAsdGhpcy5tYXhfbGF6eV9tYXRjaD0wLHRoaXMubGV2ZWw9MCx0aGlzLnN0cmF0ZWd5PTAsdGhpcy5nb29kX21hdGNoPTAsdGhpcy5uaWNlX21hdGNoPTAsdGhpcy5keW5fbHRyZWU9bmV3IFVpbnQxNkFycmF5KEFhKjIpLHRoaXMuZHluX2R0cmVlPW5ldyBVaW50MTZBcnJheSgoMipxcysxKSoyKSx0aGlzLmJsX3RyZWU9bmV3IFVpbnQxNkFycmF5KCgyKiRzKzEpKjIpLHRBKHRoaXMuZHluX2x0cmVlKSx0QSh0aGlzLmR5bl9kdHJlZSksdEEodGhpcy5ibF90cmVlKSx0aGlzLmxfZGVzYz1udWxsLHRoaXMuZF9kZXNjPW51bGwsdGhpcy5ibF9kZXNjPW51bGwsdGhpcy5ibF9jb3VudD1uZXcgVWludDE2QXJyYXkodGErMSksdGhpcy5oZWFwPW5ldyBVaW50MTZBcnJheSgyKlR0KzEpLHRBKHRoaXMuaGVhcCksdGhpcy5oZWFwX2xlbj0wLHRoaXMuaGVhcF9tYXg9MCx0aGlzLmRlcHRoPW5ldyBVaW50MTZBcnJheSgyKlR0KzEpLHRBKHRoaXMuZGVwdGgpLHRoaXMuc3ltX2J1Zj0wLHRoaXMubGl0X2J1ZnNpemU9MCx0aGlzLnN5bV9uZXh0PTAsdGhpcy5zeW1fZW5kPTAsdGhpcy5vcHRfbGVuPTAsdGhpcy5zdGF0aWNfbGVuPTAsdGhpcy5tYXRjaGVzPTAsdGhpcy5pbnNlcnQ9MCx0aGlzLmJpX2J1Zj0wLHRoaXMuYmlfdmFsaWQ9MH12YXIgR0E9dD0+e2lmKCF0KXJldHVybiAxO2xldCBlPXQuc3RhdGU7cmV0dXJuIWV8fGUuc3RybSE9PXR8fGUuc3RhdHVzIT09SUEmJmUuc3RhdHVzIT09R3QmJmUuc3RhdHVzIT09cHQmJmUuc3RhdHVzIT09VXQmJmUuc3RhdHVzIT09UHQmJmUuc3RhdHVzIT09a3QmJmUuc3RhdHVzIT09RUEmJmUuc3RhdHVzIT09eEE/MTowfSx0aT10PT57aWYoR0EodCkpcmV0dXJuIHJBKHQseik7dC50b3RhbF9pbj10LnRvdGFsX291dD0wLHQuZGF0YV90eXBlPVdzO2xldCBlPXQuc3RhdGU7cmV0dXJuIGUucGVuZGluZz0wLGUucGVuZGluZ19vdXQ9MCxlLndyYXA8MCYmKGUud3JhcD0tZS53cmFwKSxlLnN0YXR1cz1lLndyYXA9PT0yP0d0OmUud3JhcD9JQTpFQSx0LmFkbGVyPWUud3JhcD09PTI/MDoxLGUubGFzdF9mbHVzaD0tMixIcyhlKSxrfSxlaT10PT57bGV0IGU9dGkodCk7cmV0dXJuIGU9PT1rJiZyYSh0LnN0YXRlKSxlfSxvYT0odCxlKT0+R0EodCl8fHQuc3RhdGUud3JhcCE9PTI/ejoodC5zdGF0ZS5nemhlYWQ9ZSxrKSxpaT0odCxlLEEsaSxzLGEpPT57aWYoIXQpcmV0dXJuIHo7bGV0IG49MTtpZihlPT09S3MmJihlPTYpLGk8MD8obj0wLGk9LWkpOmk+MTUmJihuPTIsaS09MTYpLHM8MXx8cz56c3x8QSE9PWF0fHxpPDh8fGk+MTV8fGU8MHx8ZT45fHxhPDB8fGE+SnN8fGk9PT04JiZuIT09MSlyZXR1cm4gckEodCx6KTtpPT09OCYmKGk9OSk7bGV0IEU9bmV3IGhhO3JldHVybiB0LnN0YXRlPUUsRS5zdHJtPXQsRS5zdGF0dXM9SUEsRS53cmFwPW4sRS5nemhlYWQ9bnVsbCxFLndfYml0cz1pLEUud19zaXplPTE8PEUud19iaXRzLEUud19tYXNrPUUud19zaXplLTEsRS5oYXNoX2JpdHM9cys3LEUuaGFzaF9zaXplPTE8PEUuaGFzaF9iaXRzLEUuaGFzaF9tYXNrPUUuaGFzaF9zaXplLTEsRS5oYXNoX3NoaWZ0PX5+KChFLmhhc2hfYml0cyt4LTEpL3gpLEUud2luZG93PW5ldyBVaW50OEFycmF5KEUud19zaXplKjIpLEUuaGVhZD1uZXcgVWludDE2QXJyYXkoRS5oYXNoX3NpemUpLEUucHJldj1uZXcgVWludDE2QXJyYXkoRS53X3NpemUpLEUubGl0X2J1ZnNpemU9MTw8cys2LEUucGVuZGluZ19idWZfc2l6ZT1FLmxpdF9idWZzaXplKjQsRS5wZW5kaW5nX2J1Zj1uZXcgVWludDhBcnJheShFLnBlbmRpbmdfYnVmX3NpemUpLEUuc3ltX2J1Zj1FLmxpdF9idWZzaXplLEUuc3ltX2VuZD0oRS5saXRfYnVmc2l6ZS0xKSozLEUubGV2ZWw9ZSxFLnN0cmF0ZWd5PWEsRS5tZXRob2Q9QSxlaSh0KX0sZ2E9KHQsZSk9PmlpKHQsZSxhdCxqcyxacyx2cyksY2E9KHQsZSk9PntpZihHQSh0KXx8ZT5hZXx8ZTwwKXJldHVybiB0P3JBKHQseik6ejtsZXQgQT10LnN0YXRlO2lmKCF0Lm91dHB1dHx8dC5hdmFpbF9pbiE9PTAmJiF0LmlucHV0fHxBLnN0YXR1cz09PXhBJiZlIT09TClyZXR1cm4gckEodCx0LmF2YWlsX291dD09PTA/ZnQ6eik7bGV0IGk9QS5sYXN0X2ZsdXNoO2lmKEEubGFzdF9mbHVzaD1lLEEucGVuZGluZyE9PTApe2lmKFkodCksdC5hdmFpbF9vdXQ9PT0wKXJldHVybiBBLmxhc3RfZmx1c2g9LTEsa31lbHNlIGlmKHQuYXZhaWxfaW49PT0wJiZFZShlKTw9RWUoaSkmJmUhPT1MKXJldHVybiByQSh0LGZ0KTtpZihBLnN0YXR1cz09PXhBJiZ0LmF2YWlsX2luIT09MClyZXR1cm4gckEodCxmdCk7aWYoQS5zdGF0dXM9PT1JQSYmQS53cmFwPT09MCYmKEEuc3RhdHVzPUVBKSxBLnN0YXR1cz09PUlBKXtsZXQgcz1hdCsoQS53X2JpdHMtODw8NCk8PDgsYT0tMTtpZihBLnN0cmF0ZWd5Pj1YQXx8QS5sZXZlbDwyP2E9MDpBLmxldmVsPDY/YT0xOkEubGV2ZWw9PT02P2E9MjphPTMsc3w9YTw8NixBLnN0cnN0YXJ0IT09MCYmKHN8PWVhKSxzKz0zMS1zJTMxLE1BKEEscyksQS5zdHJzdGFydCE9PTAmJihNQShBLHQuYWRsZXI+Pj4xNiksTUEoQSx0LmFkbGVyJjY1NTM1KSksdC5hZGxlcj0xLEEuc3RhdHVzPUVBLFkodCksQS5wZW5kaW5nIT09MClyZXR1cm4gQS5sYXN0X2ZsdXNoPS0xLGt9aWYoQS5zdGF0dXM9PT1HdCl7aWYodC5hZGxlcj0wLHUoQSwzMSksdShBLDEzOSksdShBLDgpLEEuZ3poZWFkKXUoQSwoQS5nemhlYWQudGV4dD8xOjApKyhBLmd6aGVhZC5oY3JjPzI6MCkrKEEuZ3poZWFkLmV4dHJhPzQ6MCkrKEEuZ3poZWFkLm5hbWU/ODowKSsoQS5nemhlYWQuY29tbWVudD8xNjowKSksdShBLEEuZ3poZWFkLnRpbWUmMjU1KSx1KEEsQS5nemhlYWQudGltZT4+OCYyNTUpLHUoQSxBLmd6aGVhZC50aW1lPj4xNiYyNTUpLHUoQSxBLmd6aGVhZC50aW1lPj4yNCYyNTUpLHUoQSxBLmxldmVsPT09OT8yOkEuc3RyYXRlZ3k+PVhBfHxBLmxldmVsPDI/NDowKSx1KEEsQS5nemhlYWQub3MmMjU1KSxBLmd6aGVhZC5leHRyYSYmQS5nemhlYWQuZXh0cmEubGVuZ3RoJiYodShBLEEuZ3poZWFkLmV4dHJhLmxlbmd0aCYyNTUpLHUoQSxBLmd6aGVhZC5leHRyYS5sZW5ndGg+PjgmMjU1KSksQS5nemhlYWQuaGNyYyYmKHQuYWRsZXI9UCh0LmFkbGVyLEEucGVuZGluZ19idWYsQS5wZW5kaW5nLDApKSxBLmd6aW5kZXg9MCxBLnN0YXR1cz1wdDtlbHNlIGlmKHUoQSwwKSx1KEEsMCksdShBLDApLHUoQSwwKSx1KEEsMCksdShBLEEubGV2ZWw9PT05PzI6QS5zdHJhdGVneT49WEF8fEEubGV2ZWw8Mj80OjApLHUoQSxpYSksQS5zdGF0dXM9RUEsWSh0KSxBLnBlbmRpbmchPT0wKXJldHVybiBBLmxhc3RfZmx1c2g9LTEsa31pZihBLnN0YXR1cz09PXB0KXtpZihBLmd6aGVhZC5leHRyYSl7bGV0IHM9QS5wZW5kaW5nLGE9KEEuZ3poZWFkLmV4dHJhLmxlbmd0aCY2NTUzNSktQS5nemluZGV4O2Zvcig7QS5wZW5kaW5nK2E+QS5wZW5kaW5nX2J1Zl9zaXplOyl7bGV0IEU9QS5wZW5kaW5nX2J1Zl9zaXplLUEucGVuZGluZztpZihBLnBlbmRpbmdfYnVmLnNldChBLmd6aGVhZC5leHRyYS5zdWJhcnJheShBLmd6aW5kZXgsQS5nemluZGV4K0UpLEEucGVuZGluZyksQS5wZW5kaW5nPUEucGVuZGluZ19idWZfc2l6ZSxBLmd6aGVhZC5oY3JjJiZBLnBlbmRpbmc+cyYmKHQuYWRsZXI9UCh0LmFkbGVyLEEucGVuZGluZ19idWYsQS5wZW5kaW5nLXMscykpLEEuZ3ppbmRleCs9RSxZKHQpLEEucGVuZGluZyE9PTApcmV0dXJuIEEubGFzdF9mbHVzaD0tMSxrO3M9MCxhLT1FfWxldCBuPW5ldyBVaW50OEFycmF5KEEuZ3poZWFkLmV4dHJhKTtBLnBlbmRpbmdfYnVmLnNldChuLnN1YmFycmF5KEEuZ3ppbmRleCxBLmd6aW5kZXgrYSksQS5wZW5kaW5nKSxBLnBlbmRpbmcrPWEsQS5nemhlYWQuaGNyYyYmQS5wZW5kaW5nPnMmJih0LmFkbGVyPVAodC5hZGxlcixBLnBlbmRpbmdfYnVmLEEucGVuZGluZy1zLHMpKSxBLmd6aW5kZXg9MH1BLnN0YXR1cz1VdH1pZihBLnN0YXR1cz09PVV0KXtpZihBLmd6aGVhZC5uYW1lKXtsZXQgcz1BLnBlbmRpbmcsYTtkb3tpZihBLnBlbmRpbmc9PT1BLnBlbmRpbmdfYnVmX3NpemUpe2lmKEEuZ3poZWFkLmhjcmMmJkEucGVuZGluZz5zJiYodC5hZGxlcj1QKHQuYWRsZXIsQS5wZW5kaW5nX2J1ZixBLnBlbmRpbmctcyxzKSksWSh0KSxBLnBlbmRpbmchPT0wKXJldHVybiBBLmxhc3RfZmx1c2g9LTEsaztzPTB9QS5nemluZGV4PEEuZ3poZWFkLm5hbWUubGVuZ3RoP2E9QS5nemhlYWQubmFtZS5jaGFyQ29kZUF0KEEuZ3ppbmRleCsrKSYyNTU6YT0wLHUoQSxhKX13aGlsZShhIT09MCk7QS5nemhlYWQuaGNyYyYmQS5wZW5kaW5nPnMmJih0LmFkbGVyPVAodC5hZGxlcixBLnBlbmRpbmdfYnVmLEEucGVuZGluZy1zLHMpKSxBLmd6aW5kZXg9MH1BLnN0YXR1cz1QdH1pZihBLnN0YXR1cz09PVB0KXtpZihBLmd6aGVhZC5jb21tZW50KXtsZXQgcz1BLnBlbmRpbmcsYTtkb3tpZihBLnBlbmRpbmc9PT1BLnBlbmRpbmdfYnVmX3NpemUpe2lmKEEuZ3poZWFkLmhjcmMmJkEucGVuZGluZz5zJiYodC5hZGxlcj1QKHQuYWRsZXIsQS5wZW5kaW5nX2J1ZixBLnBlbmRpbmctcyxzKSksWSh0KSxBLnBlbmRpbmchPT0wKXJldHVybiBBLmxhc3RfZmx1c2g9LTEsaztzPTB9QS5nemluZGV4PEEuZ3poZWFkLmNvbW1lbnQubGVuZ3RoP2E9QS5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KEEuZ3ppbmRleCsrKSYyNTU6YT0wLHUoQSxhKX13aGlsZShhIT09MCk7QS5nemhlYWQuaGNyYyYmQS5wZW5kaW5nPnMmJih0LmFkbGVyPVAodC5hZGxlcixBLnBlbmRpbmdfYnVmLEEucGVuZGluZy1zLHMpKX1BLnN0YXR1cz1rdH1pZihBLnN0YXR1cz09PWt0KXtpZihBLmd6aGVhZC5oY3JjKXtpZihBLnBlbmRpbmcrMj5BLnBlbmRpbmdfYnVmX3NpemUmJihZKHQpLEEucGVuZGluZyE9PTApKXJldHVybiBBLmxhc3RfZmx1c2g9LTEsazt1KEEsdC5hZGxlciYyNTUpLHUoQSx0LmFkbGVyPj44JjI1NSksdC5hZGxlcj0wfWlmKEEuc3RhdHVzPUVBLFkodCksQS5wZW5kaW5nIT09MClyZXR1cm4gQS5sYXN0X2ZsdXNoPS0xLGt9aWYodC5hdmFpbF9pbiE9PTB8fEEubG9va2FoZWFkIT09MHx8ZSE9PXNBJiZBLnN0YXR1cyE9PXhBKXtsZXQgcz1BLmxldmVsPT09MD9BaShBLGUpOkEuc3RyYXRlZ3k9PT1YQT9FYShBLGUpOkEuc3RyYXRlZ3k9PT1Ocz9uYShBLGUpOlFBW0EubGV2ZWxdLmZ1bmMoQSxlKTtpZigocz09PW9BfHxzPT09UkEpJiYoQS5zdGF0dXM9eEEpLHM9PT1IfHxzPT09b0EpcmV0dXJuIHQuYXZhaWxfb3V0PT09MCYmKEEubGFzdF9mbHVzaD0tMSksaztpZihzPT09REEmJihlPT09YnM/WXMoQSk6ZSE9PWFlJiYoRnQoQSwwLDAsITEpLGU9PT1HcyYmKHRBKEEuaGVhZCksQS5sb29rYWhlYWQ9PT0wJiYoQS5zdHJzdGFydD0wLEEuYmxvY2tfc3RhcnQ9MCxBLmluc2VydD0wKSkpLFkodCksdC5hdmFpbF9vdXQ9PT0wKSlyZXR1cm4gQS5sYXN0X2ZsdXNoPS0xLGt9cmV0dXJuIGUhPT1MP2s6QS53cmFwPD0wP25lOihBLndyYXA9PT0yPyh1KEEsdC5hZGxlciYyNTUpLHUoQSx0LmFkbGVyPj44JjI1NSksdShBLHQuYWRsZXI+PjE2JjI1NSksdShBLHQuYWRsZXI+PjI0JjI1NSksdShBLHQudG90YWxfaW4mMjU1KSx1KEEsdC50b3RhbF9pbj4+OCYyNTUpLHUoQSx0LnRvdGFsX2luPj4xNiYyNTUpLHUoQSx0LnRvdGFsX2luPj4yNCYyNTUpKTooTUEoQSx0LmFkbGVyPj4+MTYpLE1BKEEsdC5hZGxlciY2NTUzNSkpLFkodCksQS53cmFwPjAmJihBLndyYXA9LUEud3JhcCksQS5wZW5kaW5nIT09MD9rOm5lKX0sQmE9dD0+e2lmKEdBKHQpKXJldHVybiB6O2xldCBlPXQuc3RhdGUuc3RhdHVzO3JldHVybiB0LnN0YXRlPW51bGwsZT09PUVBP3JBKHQsbXMpOmt9LHdhPSh0LGUpPT57bGV0IEE9ZS5sZW5ndGg7aWYoR0EodCkpcmV0dXJuIHo7bGV0IGk9dC5zdGF0ZSxzPWkud3JhcDtpZihzPT09Mnx8cz09PTEmJmkuc3RhdHVzIT09SUF8fGkubG9va2FoZWFkKXJldHVybiB6O2lmKHM9PT0xJiYodC5hZGxlcj1PQSh0LmFkbGVyLGUsQSwwKSksaS53cmFwPTAsQT49aS53X3NpemUpe3M9PT0wJiYodEEoaS5oZWFkKSxpLnN0cnN0YXJ0PTAsaS5ibG9ja19zdGFydD0wLGkuaW5zZXJ0PTApO2xldCBvPW5ldyBVaW50OEFycmF5KGkud19zaXplKTtvLnNldChlLnN1YmFycmF5KEEtaS53X3NpemUsQSksMCksZT1vLEE9aS53X3NpemV9bGV0IGE9dC5hdmFpbF9pbixuPXQubmV4dF9pbixFPXQuaW5wdXQ7Zm9yKHQuYXZhaWxfaW49QSx0Lm5leHRfaW49MCx0LmlucHV0PWUsbEEoaSk7aS5sb29rYWhlYWQ+PXg7KXtsZXQgbz1pLnN0cnN0YXJ0LHI9aS5sb29rYWhlYWQtKHgtMSk7ZG8gaS5pbnNfaD1hQShpLGkuaW5zX2gsaS53aW5kb3dbbyt4LTFdKSxpLnByZXZbbyZpLndfbWFza109aS5oZWFkW2kuaW5zX2hdLGkuaGVhZFtpLmluc19oXT1vLG8rKzt3aGlsZSgtLXIpO2kuc3Ryc3RhcnQ9byxpLmxvb2thaGVhZD14LTEsbEEoaSl9cmV0dXJuIGkuc3Ryc3RhcnQrPWkubG9va2FoZWFkLGkuYmxvY2tfc3RhcnQ9aS5zdHJzdGFydCxpLmluc2VydD1pLmxvb2thaGVhZCxpLmxvb2thaGVhZD0wLGkubWF0Y2hfbGVuZ3RoPWkucHJldl9sZW5ndGg9eC0xLGkubWF0Y2hfYXZhaWxhYmxlPTAsdC5uZXh0X2luPW4sdC5pbnB1dD1FLHQuYXZhaWxfaW49YSxpLndyYXA9cyxrfSxfYT1nYSxmYT1paSxDYT1laSxJYT10aSxsYT1vYSxkYT1jYSxTYT1CYSxEYT13YSxSYT0icGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSIsRkE9e2RlZmxhdGVJbml0Ol9hLGRlZmxhdGVJbml0MjpmYSxkZWZsYXRlUmVzZXQ6Q2EsZGVmbGF0ZVJlc2V0S2VlcDpJYSxkZWZsYXRlU2V0SGVhZGVyOmxhLGRlZmxhdGU6ZGEsZGVmbGF0ZUVuZDpTYSxkZWZsYXRlU2V0RGljdGlvbmFyeTpEYSxkZWZsYXRlSW5mbzpSYX0sTWE9KHQsZSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpLHhhPWZ1bmN0aW9uKHQpe2xldCBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtmb3IoO2UubGVuZ3RoOyl7bGV0IEE9ZS5zaGlmdCgpO2lmKEEpe2lmKHR5cGVvZiBBIT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKEErIm11c3QgYmUgbm9uLW9iamVjdCIpO2ZvcihsZXQgaSBpbiBBKU1hKEEsaSkmJih0W2ldPUFbaV0pfX1yZXR1cm4gdH0sUWE9dD0+e2xldCBlPTA7Zm9yKGxldCBpPTAscz10Lmxlbmd0aDtpPHM7aSsrKWUrPXRbaV0ubGVuZ3RoO2xldCBBPW5ldyBVaW50OEFycmF5KGUpO2ZvcihsZXQgaT0wLHM9MCxhPXQubGVuZ3RoO2k8YTtpKyspe2xldCBuPXRbaV07QS5zZXQobixzKSxzKz1uLmxlbmd0aH1yZXR1cm4gQX0sbnQ9e2Fzc2lnbjp4YSxmbGF0dGVuQ2h1bmtzOlFhfSxzaT0hMDt0cnl7U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50OEFycmF5KDEpKX1jYXRjaHtzaT0hMX12YXIgSEE9bmV3IFVpbnQ4QXJyYXkoMjU2KTtmb3IobGV0IHQ9MDt0PDI1Njt0KyspSEFbdF09dD49MjUyPzY6dD49MjQ4PzU6dD49MjQwPzQ6dD49MjI0PzM6dD49MTkyPzI6MTtIQVsyNTRdPUhBWzI1NF09MTt2YXIgdWE9dD0+e2lmKHR5cGVvZiBUZXh0RW5jb2Rlcj09ImZ1bmN0aW9uIiYmVGV4dEVuY29kZXIucHJvdG90eXBlLmVuY29kZSlyZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHQpO2xldCBlLEEsaSxzLGEsbj10Lmxlbmd0aCxFPTA7Zm9yKHM9MDtzPG47cysrKUE9dC5jaGFyQ29kZUF0KHMpLChBJjY0NTEyKT09PTU1Mjk2JiZzKzE8biYmKGk9dC5jaGFyQ29kZUF0KHMrMSksKGkmNjQ1MTIpPT09NTYzMjAmJihBPTY1NTM2KyhBLTU1Mjk2PDwxMCkrKGktNTYzMjApLHMrKykpLEUrPUE8MTI4PzE6QTwyMDQ4PzI6QTw2NTUzNj8zOjQ7Zm9yKGU9bmV3IFVpbnQ4QXJyYXkoRSksYT0wLHM9MDthPEU7cysrKUE9dC5jaGFyQ29kZUF0KHMpLChBJjY0NTEyKT09PTU1Mjk2JiZzKzE8biYmKGk9dC5jaGFyQ29kZUF0KHMrMSksKGkmNjQ1MTIpPT09NTYzMjAmJihBPTY1NTM2KyhBLTU1Mjk2PDwxMCkrKGktNTYzMjApLHMrKykpLEE8MTI4P2VbYSsrXT1BOkE8MjA0OD8oZVthKytdPTE5MnxBPj4+NixlW2ErK109MTI4fEEmNjMpOkE8NjU1MzY/KGVbYSsrXT0yMjR8QT4+PjEyLGVbYSsrXT0xMjh8QT4+PjYmNjMsZVthKytdPTEyOHxBJjYzKTooZVthKytdPTI0MHxBPj4+MTgsZVthKytdPTEyOHxBPj4+MTImNjMsZVthKytdPTEyOHxBPj4+NiY2MyxlW2ErK109MTI4fEEmNjMpO3JldHVybiBlfSxGYT0odCxlKT0+e2lmKGU8NjU1MzQmJnQuc3ViYXJyYXkmJnNpKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsdC5sZW5ndGg9PT1lP3Q6dC5zdWJhcnJheSgwLGUpKTtsZXQgQT0iIjtmb3IobGV0IGk9MDtpPGU7aSsrKUErPVN0cmluZy5mcm9tQ2hhckNvZGUodFtpXSk7cmV0dXJuIEF9LFRhPSh0LGUpPT57bGV0IEE9ZXx8dC5sZW5ndGg7aWYodHlwZW9mIFRleHREZWNvZGVyPT0iZnVuY3Rpb24iJiZUZXh0RGVjb2Rlci5wcm90b3R5cGUuZGVjb2RlKXJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodC5zdWJhcnJheSgwLGUpKTtsZXQgaSxzLGE9bmV3IEFycmF5KEEqMik7Zm9yKHM9MCxpPTA7aTxBOyl7bGV0IG49dFtpKytdO2lmKG48MTI4KXthW3MrK109bjtjb250aW51ZX1sZXQgRT1IQVtuXTtpZihFPjQpe2FbcysrXT02NTUzMyxpKz1FLTE7Y29udGludWV9Zm9yKG4mPUU9PT0yPzMxOkU9PT0zPzE1Ojc7RT4xJiZpPEE7KW49bjw8Nnx0W2krK10mNjMsRS0tO2lmKEU+MSl7YVtzKytdPTY1NTMzO2NvbnRpbnVlfW48NjU1MzY/YVtzKytdPW46KG4tPTY1NTM2LGFbcysrXT01NTI5NnxuPj4xMCYxMDIzLGFbcysrXT01NjMyMHxuJjEwMjMpfXJldHVybiBGYShhLHMpfSxwYT0odCxlKT0+e2U9ZXx8dC5sZW5ndGgsZT50Lmxlbmd0aCYmKGU9dC5sZW5ndGgpO2xldCBBPWUtMTtmb3IoO0E+PTAmJih0W0FdJjE5Mik9PT0xMjg7KUEtLTtyZXR1cm4gQTwwfHxBPT09MD9lOkErSEFbdFtBXV0+ZT9BOmV9LHlBPXtzdHJpbmcyYnVmOnVhLGJ1ZjJzdHJpbmc6VGEsdXRmOGJvcmRlcjpwYX07ZnVuY3Rpb24gVWEoKXt0aGlzLmlucHV0PW51bGwsdGhpcy5uZXh0X2luPTAsdGhpcy5hdmFpbF9pbj0wLHRoaXMudG90YWxfaW49MCx0aGlzLm91dHB1dD1udWxsLHRoaXMubmV4dF9vdXQ9MCx0aGlzLmF2YWlsX291dD0wLHRoaXMudG90YWxfb3V0PTAsdGhpcy5tc2c9IiIsdGhpcy5zdGF0ZT1udWxsLHRoaXMuZGF0YV90eXBlPTIsdGhpcy5hZGxlcj0wfXZhciBhaT1VYSxuaT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLHtaX05PX0ZMVVNIOlBhLFpfU1lOQ19GTFVTSDprYSxaX0ZVTExfRkxVU0g6T2EsWl9GSU5JU0g6SGEsWl9PSzppdCxaX1NUUkVBTV9FTkQ6eWEsWl9ERUZBVUxUX0NPTVBSRVNTSU9OOllhLFpfREVGQVVMVF9TVFJBVEVHWTpiYSxaX0RFRkxBVEVEOkdhfT1TQTtmdW5jdGlvbiBtQSh0KXt0aGlzLm9wdGlvbnM9bnQuYXNzaWduKHtsZXZlbDpZYSxtZXRob2Q6R2EsY2h1bmtTaXplOjE2Mzg0LHdpbmRvd0JpdHM6MTUsbWVtTGV2ZWw6OCxzdHJhdGVneTpiYX0sdHx8e30pO2xldCBlPXRoaXMub3B0aW9ucztlLnJhdyYmZS53aW5kb3dCaXRzPjA/ZS53aW5kb3dCaXRzPS1lLndpbmRvd0JpdHM6ZS5nemlwJiZlLndpbmRvd0JpdHM+MCYmZS53aW5kb3dCaXRzPDE2JiYoZS53aW5kb3dCaXRzKz0xNiksdGhpcy5lcnI9MCx0aGlzLm1zZz0iIix0aGlzLmVuZGVkPSExLHRoaXMuY2h1bmtzPVtdLHRoaXMuc3RybT1uZXcgYWksdGhpcy5zdHJtLmF2YWlsX291dD0wO2xldCBBPUZBLmRlZmxhdGVJbml0Mih0aGlzLnN0cm0sZS5sZXZlbCxlLm1ldGhvZCxlLndpbmRvd0JpdHMsZS5tZW1MZXZlbCxlLnN0cmF0ZWd5KTtpZihBIT09aXQpdGhyb3cgbmV3IEVycm9yKGhBW0FdKTtpZihlLmhlYWRlciYmRkEuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sZS5oZWFkZXIpLGUuZGljdGlvbmFyeSl7bGV0IGk7aWYodHlwZW9mIGUuZGljdGlvbmFyeT09InN0cmluZyI/aT15QS5zdHJpbmcyYnVmKGUuZGljdGlvbmFyeSk6bmkuY2FsbChlLmRpY3Rpb25hcnkpPT09IltvYmplY3QgQXJyYXlCdWZmZXJdIj9pPW5ldyBVaW50OEFycmF5KGUuZGljdGlvbmFyeSk6aT1lLmRpY3Rpb25hcnksQT1GQS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0saSksQSE9PWl0KXRocm93IG5ldyBFcnJvcihoQVtBXSk7dGhpcy5fZGljdF9zZXQ9ITB9fW1BLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQsZSl7bGV0IEE9dGhpcy5zdHJtLGk9dGhpcy5vcHRpb25zLmNodW5rU2l6ZSxzLGE7aWYodGhpcy5lbmRlZClyZXR1cm4hMTtmb3IoZT09PX5+ZT9hPWU6YT1lPT09ITA/SGE6UGEsdHlwZW9mIHQ9PSJzdHJpbmciP0EuaW5wdXQ9eUEuc3RyaW5nMmJ1Zih0KTpuaS5jYWxsKHQpPT09IltvYmplY3QgQXJyYXlCdWZmZXJdIj9BLmlucHV0PW5ldyBVaW50OEFycmF5KHQpOkEuaW5wdXQ9dCxBLm5leHRfaW49MCxBLmF2YWlsX2luPUEuaW5wdXQubGVuZ3RoOzspe2lmKEEuYXZhaWxfb3V0PT09MCYmKEEub3V0cHV0PW5ldyBVaW50OEFycmF5KGkpLEEubmV4dF9vdXQ9MCxBLmF2YWlsX291dD1pKSwoYT09PWthfHxhPT09T2EpJiZBLmF2YWlsX291dDw9Nil7dGhpcy5vbkRhdGEoQS5vdXRwdXQuc3ViYXJyYXkoMCxBLm5leHRfb3V0KSksQS5hdmFpbF9vdXQ9MDtjb250aW51ZX1pZihzPUZBLmRlZmxhdGUoQSxhKSxzPT09eWEpcmV0dXJuIEEubmV4dF9vdXQ+MCYmdGhpcy5vbkRhdGEoQS5vdXRwdXQuc3ViYXJyYXkoMCxBLm5leHRfb3V0KSkscz1GQS5kZWZsYXRlRW5kKHRoaXMuc3RybSksdGhpcy5vbkVuZChzKSx0aGlzLmVuZGVkPSEwLHM9PT1pdDtpZihBLmF2YWlsX291dD09PTApe3RoaXMub25EYXRhKEEub3V0cHV0KTtjb250aW51ZX1pZihhPjAmJkEubmV4dF9vdXQ+MCl7dGhpcy5vbkRhdGEoQS5vdXRwdXQuc3ViYXJyYXkoMCxBLm5leHRfb3V0KSksQS5hdmFpbF9vdXQ9MDtjb250aW51ZX1pZihBLmF2YWlsX2luPT09MClicmVha31yZXR1cm4hMH07bUEucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbih0KXt0aGlzLmNodW5rcy5wdXNoKHQpfTttQS5wcm90b3R5cGUub25FbmQ9ZnVuY3Rpb24odCl7dD09PWl0JiYodGhpcy5yZXN1bHQ9bnQuZmxhdHRlbkNodW5rcyh0aGlzLmNodW5rcykpLHRoaXMuY2h1bmtzPVtdLHRoaXMuZXJyPXQsdGhpcy5tc2c9dGhpcy5zdHJtLm1zZ307ZnVuY3Rpb24gbXQodCxlKXtsZXQgQT1uZXcgbUEoZSk7aWYoQS5wdXNoKHQsITApLEEuZXJyKXRocm93IEEubXNnfHxoQVtBLmVycl07cmV0dXJuIEEucmVzdWx0fWZ1bmN0aW9uIG1hKHQsZSl7cmV0dXJuIGU9ZXx8e30sZS5yYXc9ITAsbXQodCxlKX1mdW5jdGlvbiBLYSh0LGUpe3JldHVybiBlPWV8fHt9LGUuZ3ppcD0hMCxtdCh0LGUpfXZhciBMYT1tQSxOYT1tdCxKYT1tYSx2YT1LYSxXYT1TQSx6YT17RGVmbGF0ZTpMYSxkZWZsYXRlOk5hLGRlZmxhdGVSYXc6SmEsZ3ppcDp2YSxjb25zdGFudHM6V2F9LFZBPTE2MjA5LGphPTE2MTkxLFphPWZ1bmN0aW9uKGUsQSl7bGV0IGkscyxhLG4sRSxvLHIsaCx3LGMsZyxmLEYsZCxDLFEsbCxCLEQscCxfLE0sUyxJLFI9ZS5zdGF0ZTtpPWUubmV4dF9pbixTPWUuaW5wdXQscz1pKyhlLmF2YWlsX2luLTUpLGE9ZS5uZXh0X291dCxJPWUub3V0cHV0LG49YS0oQS1lLmF2YWlsX291dCksRT1hKyhlLmF2YWlsX291dC0yNTcpLG89Ui5kbWF4LHI9Ui53c2l6ZSxoPVIud2hhdmUsdz1SLnduZXh0LGM9Ui53aW5kb3csZz1SLmhvbGQsZj1SLmJpdHMsRj1SLmxlbmNvZGUsZD1SLmRpc3Rjb2RlLEM9KDE8PFIubGVuYml0cyktMSxRPSgxPDxSLmRpc3RiaXRzKS0xO0E6ZG97ZjwxNSYmKGcrPVNbaSsrXTw8ZixmKz04LGcrPVNbaSsrXTw8ZixmKz04KSxsPUZbZyZDXTt0OmZvcig7Oyl7aWYoQj1sPj4+MjQsZz4+Pj1CLGYtPUIsQj1sPj4+MTYmMjU1LEI9PT0wKUlbYSsrXT1sJjY1NTM1O2Vsc2UgaWYoQiYxNil7RD1sJjY1NTM1LEImPTE1LEImJihmPEImJihnKz1TW2krK108PGYsZis9OCksRCs9ZyYoMTw8QiktMSxnPj4+PUIsZi09QiksZjwxNSYmKGcrPVNbaSsrXTw8ZixmKz04LGcrPVNbaSsrXTw8ZixmKz04KSxsPWRbZyZRXTtlOmZvcig7Oyl7aWYoQj1sPj4+MjQsZz4+Pj1CLGYtPUIsQj1sPj4+MTYmMjU1LEImMTYpe2lmKHA9bCY2NTUzNSxCJj0xNSxmPEImJihnKz1TW2krK108PGYsZis9OCxmPEImJihnKz1TW2krK108PGYsZis9OCkpLHArPWcmKDE8PEIpLTEscD5vKXtlLm1zZz0iaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2siLFIubW9kZT1WQTticmVhayBBfWlmKGc+Pj49QixmLT1CLEI9YS1uLHA+Qil7aWYoQj1wLUIsQj5oJiZSLnNhbmUpe2UubXNnPSJpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayIsUi5tb2RlPVZBO2JyZWFrIEF9aWYoXz0wLE09Yyx3PT09MCl7aWYoXys9ci1CLEI8RCl7RC09QjtkbyBJW2ErK109Y1tfKytdO3doaWxlKC0tQik7Xz1hLXAsTT1JfX1lbHNlIGlmKHc8Qil7aWYoXys9cit3LUIsQi09dyxCPEQpe0QtPUI7ZG8gSVthKytdPWNbXysrXTt3aGlsZSgtLUIpO2lmKF89MCx3PEQpe0I9dyxELT1CO2RvIElbYSsrXT1jW18rK107d2hpbGUoLS1CKTtfPWEtcCxNPUl9fX1lbHNlIGlmKF8rPXctQixCPEQpe0QtPUI7ZG8gSVthKytdPWNbXysrXTt3aGlsZSgtLUIpO189YS1wLE09SX1mb3IoO0Q+MjspSVthKytdPU1bXysrXSxJW2ErK109TVtfKytdLElbYSsrXT1NW18rK10sRC09MztEJiYoSVthKytdPU1bXysrXSxEPjEmJihJW2ErK109TVtfKytdKSl9ZWxzZXtfPWEtcDtkbyBJW2ErK109SVtfKytdLElbYSsrXT1JW18rK10sSVthKytdPUlbXysrXSxELT0zO3doaWxlKEQ+Mik7RCYmKElbYSsrXT1JW18rK10sRD4xJiYoSVthKytdPUlbXysrXSkpfX1lbHNlIGlmKChCJjY0KT09PTApe2w9ZFsobCY2NTUzNSkrKGcmKDE8PEIpLTEpXTtjb250aW51ZSBlfWVsc2V7ZS5tc2c9ImludmFsaWQgZGlzdGFuY2UgY29kZSIsUi5tb2RlPVZBO2JyZWFrIEF9YnJlYWt9fWVsc2UgaWYoKEImNjQpPT09MCl7bD1GWyhsJjY1NTM1KSsoZyYoMTw8QiktMSldO2NvbnRpbnVlIHR9ZWxzZSBpZihCJjMyKXtSLm1vZGU9amE7YnJlYWsgQX1lbHNle2UubXNnPSJpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUiLFIubW9kZT1WQTticmVhayBBfWJyZWFrfX13aGlsZShpPHMmJmE8RSk7RD1mPj4zLGktPUQsZi09RDw8MyxnJj0oMTw8ZiktMSxlLm5leHRfaW49aSxlLm5leHRfb3V0PWEsZS5hdmFpbF9pbj1pPHM/NSsocy1pKTo1LShpLXMpLGUuYXZhaWxfb3V0PWE8RT8yNTcrKEUtYSk6MjU3LShhLUUpLFIuaG9sZD1nLFIuYml0cz1mfSxmQT0xNSxyZT04NTIsaGU9NTkyLG9lPTAsSXQ9MSxnZT0yLFhhPW5ldyBVaW50MTZBcnJheShbMyw0LDUsNiw3LDgsOSwxMCwxMSwxMywxNSwxNywxOSwyMywyNywzMSwzNSw0Myw1MSw1OSw2Nyw4Myw5OSwxMTUsMTMxLDE2MywxOTUsMjI3LDI1OCwwLDBdKSxWYT1uZXcgVWludDhBcnJheShbMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTYsMTcsMTcsMTcsMTcsMTgsMTgsMTgsMTgsMTksMTksMTksMTksMjAsMjAsMjAsMjAsMjEsMjEsMjEsMjEsMTYsNzIsNzhdKSxxYT1uZXcgVWludDE2QXJyYXkoWzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3NywwLDBdKSwkYT1uZXcgVWludDhBcnJheShbMTYsMTYsMTYsMTYsMTcsMTcsMTgsMTgsMTksMTksMjAsMjAsMjEsMjEsMjIsMjIsMjMsMjMsMjQsMjQsMjUsMjUsMjYsMjYsMjcsMjcsMjgsMjgsMjksMjksNjQsNjRdKSxBbj0odCxlLEEsaSxzLGEsbixFKT0+e2xldCBvPUUuYml0cyxyPTAsaD0wLHc9MCxjPTAsZz0wLGY9MCxGPTAsZD0wLEM9MCxRPTAsbCxCLEQscCxfLE09bnVsbCxTLEk9bmV3IFVpbnQxNkFycmF5KGZBKzEpLFI9bmV3IFVpbnQxNkFycmF5KGZBKzEpLFo9bnVsbCxvdCx3QSxaQTtmb3Iocj0wO3I8PWZBO3IrKylJW3JdPTA7Zm9yKGg9MDtoPGk7aCsrKUlbZVtBK2hdXSsrO2ZvcihnPW8sYz1mQTtjPj0xJiZJW2NdPT09MDtjLS0pO2lmKGc+YyYmKGc9YyksYz09PTApcmV0dXJuIHNbYSsrXT0xPDwyNHw2NDw8MTZ8MCxzW2ErK109MTw8MjR8NjQ8PDE2fDAsRS5iaXRzPTEsMDtmb3Iodz0xO3c8YyYmSVt3XT09PTA7dysrKTtmb3IoZzx3JiYoZz13KSxkPTEscj0xO3I8PWZBO3IrKylpZihkPDw9MSxkLT1JW3JdLGQ8MClyZXR1cm4tMTtpZihkPjAmJih0PT09b2V8fGMhPT0xKSlyZXR1cm4tMTtmb3IoUlsxXT0wLHI9MTtyPGZBO3IrKylSW3IrMV09UltyXStJW3JdO2ZvcihoPTA7aDxpO2grKyllW0EraF0hPT0wJiYobltSW2VbQStoXV0rK109aCk7aWYodD09PW9lPyhNPVo9bixTPTIwKTp0PT09SXQ/KE09WGEsWj1WYSxTPTI1Nyk6KE09cWEsWj0kYSxTPTApLFE9MCxoPTAscj13LF89YSxmPWcsRj0wLEQ9LTEsQz0xPDxnLHA9Qy0xLHQ9PT1JdCYmQz5yZXx8dD09PWdlJiZDPmhlKXJldHVybiAxO2Zvcig7Oyl7b3Q9ci1GLG5baF0rMTxTPyh3QT0wLFpBPW5baF0pOm5baF0+PVM/KHdBPVpbbltoXS1TXSxaQT1NW25baF0tU10pOih3QT05NixaQT0wKSxsPTE8PHItRixCPTE8PGYsdz1CO2RvIEItPWwsc1tfKyhRPj5GKStCXT1vdDw8MjR8d0E8PDE2fFpBfDA7d2hpbGUoQiE9PTApO2ZvcihsPTE8PHItMTtRJmw7KWw+Pj0xO2lmKGwhPT0wPyhRJj1sLTEsUSs9bCk6UT0wLGgrKywtLUlbcl09PT0wKXtpZihyPT09YylicmVhaztyPWVbQStuW2hdXX1pZihyPmcmJihRJnApIT09RCl7Zm9yKEY9PT0wJiYoRj1nKSxfKz13LGY9ci1GLGQ9MTw8ZjtmK0Y8YyYmKGQtPUlbZitGXSwhKGQ8PTApKTspZisrLGQ8PD0xO2lmKEMrPTE8PGYsdD09PUl0JiZDPnJlfHx0PT09Z2UmJkM+aGUpcmV0dXJuIDE7RD1RJnAsc1tEXT1nPDwyNHxmPDwxNnxfLWF8MH19cmV0dXJuIFEhPT0wJiYoc1tfK1FdPXItRjw8MjR8NjQ8PDE2fDApLEUuYml0cz1nLDB9LFRBPUFuLHRuPTAsRWk9MSxyaT0yLHtaX0ZJTklTSDpjZSxaX0JMT0NLOmVuLFpfVFJFRVM6cUEsWl9PSzpnQSxaX1NUUkVBTV9FTkQ6c24sWl9ORUVEX0RJQ1Q6YW4sWl9TVFJFQU1fRVJST1I6TixaX0RBVEFfRVJST1I6aGksWl9NRU1fRVJST1I6b2ksWl9CVUZfRVJST1I6bm4sWl9ERUZMQVRFRDpCZX09U0EsRXQ9MTYxODAsd2U9MTYxODEsX2U9MTYxODIsZmU9MTYxODMsQ2U9MTYxODQsSWU9MTYxODUsbGU9MTYxODYsZGU9MTYxODcsU2U9MTYxODgsRGU9MTYxODksc3Q9MTYxOTAsWD0xNjE5MSxsdD0xNjE5MixSZT0xNjE5MyxkdD0xNjE5NCxNZT0xNjE5NSx4ZT0xNjE5NixRZT0xNjE5Nyx1ZT0xNjE5OCwkQT0xNjE5OSxBdD0xNjIwMCxGZT0xNjIwMSxUZT0xNjIwMixwZT0xNjIwMyxVZT0xNjIwNCxQZT0xNjIwNSxTdD0xNjIwNixrZT0xNjIwNyxPZT0xNjIwOCxUPTE2MjA5LGdpPTE2MjEwLGNpPTE2MjExLEVuPTg1Mixybj01OTIsaG49MTUsb249aG4sSGU9dD0+KHQ+Pj4yNCYyNTUpKyh0Pj4+OCY2NTI4MCkrKCh0JjY1MjgwKTw8OCkrKCh0JjI1NSk8PDI0KTtmdW5jdGlvbiBnbigpe3RoaXMuc3RybT1udWxsLHRoaXMubW9kZT0wLHRoaXMubGFzdD0hMSx0aGlzLndyYXA9MCx0aGlzLmhhdmVkaWN0PSExLHRoaXMuZmxhZ3M9MCx0aGlzLmRtYXg9MCx0aGlzLmNoZWNrPTAsdGhpcy50b3RhbD0wLHRoaXMuaGVhZD1udWxsLHRoaXMud2JpdHM9MCx0aGlzLndzaXplPTAsdGhpcy53aGF2ZT0wLHRoaXMud25leHQ9MCx0aGlzLndpbmRvdz1udWxsLHRoaXMuaG9sZD0wLHRoaXMuYml0cz0wLHRoaXMubGVuZ3RoPTAsdGhpcy5vZmZzZXQ9MCx0aGlzLmV4dHJhPTAsdGhpcy5sZW5jb2RlPW51bGwsdGhpcy5kaXN0Y29kZT1udWxsLHRoaXMubGVuYml0cz0wLHRoaXMuZGlzdGJpdHM9MCx0aGlzLm5jb2RlPTAsdGhpcy5ubGVuPTAsdGhpcy5uZGlzdD0wLHRoaXMuaGF2ZT0wLHRoaXMubmV4dD1udWxsLHRoaXMubGVucz1uZXcgVWludDE2QXJyYXkoMzIwKSx0aGlzLndvcms9bmV3IFVpbnQxNkFycmF5KDI4OCksdGhpcy5sZW5keW49bnVsbCx0aGlzLmRpc3RkeW49bnVsbCx0aGlzLnNhbmU9MCx0aGlzLmJhY2s9MCx0aGlzLndhcz0wfXZhciBjQT10PT57aWYoIXQpcmV0dXJuIDE7bGV0IGU9dC5zdGF0ZTtyZXR1cm4hZXx8ZS5zdHJtIT09dHx8ZS5tb2RlPEV0fHxlLm1vZGU+Y2k/MTowfSxCaT10PT57aWYoY0EodCkpcmV0dXJuIE47bGV0IGU9dC5zdGF0ZTtyZXR1cm4gdC50b3RhbF9pbj10LnRvdGFsX291dD1lLnRvdGFsPTAsdC5tc2c9IiIsZS53cmFwJiYodC5hZGxlcj1lLndyYXAmMSksZS5tb2RlPUV0LGUubGFzdD0wLGUuaGF2ZWRpY3Q9MCxlLmZsYWdzPS0xLGUuZG1heD0zMjc2OCxlLmhlYWQ9bnVsbCxlLmhvbGQ9MCxlLmJpdHM9MCxlLmxlbmNvZGU9ZS5sZW5keW49bmV3IEludDMyQXJyYXkoRW4pLGUuZGlzdGNvZGU9ZS5kaXN0ZHluPW5ldyBJbnQzMkFycmF5KHJuKSxlLnNhbmU9MSxlLmJhY2s9LTEsZ0F9LHdpPXQ9PntpZihjQSh0KSlyZXR1cm4gTjtsZXQgZT10LnN0YXRlO3JldHVybiBlLndzaXplPTAsZS53aGF2ZT0wLGUud25leHQ9MCxCaSh0KX0sX2k9KHQsZSk9PntsZXQgQTtpZihjQSh0KSlyZXR1cm4gTjtsZXQgaT10LnN0YXRlO3JldHVybiBlPDA/KEE9MCxlPS1lKTooQT0oZT4+NCkrNSxlPDQ4JiYoZSY9MTUpKSxlJiYoZTw4fHxlPjE1KT9OOihpLndpbmRvdyE9PW51bGwmJmkud2JpdHMhPT1lJiYoaS53aW5kb3c9bnVsbCksaS53cmFwPUEsaS53Yml0cz1lLHdpKHQpKX0sZmk9KHQsZSk9PntpZighdClyZXR1cm4gTjtsZXQgQT1uZXcgZ247dC5zdGF0ZT1BLEEuc3RybT10LEEud2luZG93PW51bGwsQS5tb2RlPUV0O2xldCBpPV9pKHQsZSk7cmV0dXJuIGkhPT1nQSYmKHQuc3RhdGU9bnVsbCksaX0sY249dD0+ZmkodCxvbikseWU9ITAsRHQsUnQsQm49dD0+e2lmKHllKXtEdD1uZXcgSW50MzJBcnJheSg1MTIpLFJ0PW5ldyBJbnQzMkFycmF5KDMyKTtsZXQgZT0wO2Zvcig7ZTwxNDQ7KXQubGVuc1tlKytdPTg7Zm9yKDtlPDI1NjspdC5sZW5zW2UrK109OTtmb3IoO2U8MjgwOyl0LmxlbnNbZSsrXT03O2Zvcig7ZTwyODg7KXQubGVuc1tlKytdPTg7Zm9yKFRBKEVpLHQubGVucywwLDI4OCxEdCwwLHQud29yayx7Yml0czo5fSksZT0wO2U8MzI7KXQubGVuc1tlKytdPTU7VEEocmksdC5sZW5zLDAsMzIsUnQsMCx0Lndvcmsse2JpdHM6NX0pLHllPSExfXQubGVuY29kZT1EdCx0LmxlbmJpdHM9OSx0LmRpc3Rjb2RlPVJ0LHQuZGlzdGJpdHM9NX0sQ2k9KHQsZSxBLGkpPT57bGV0IHMsYT10LnN0YXRlO3JldHVybiBhLndpbmRvdz09PW51bGwmJihhLndzaXplPTE8PGEud2JpdHMsYS53bmV4dD0wLGEud2hhdmU9MCxhLndpbmRvdz1uZXcgVWludDhBcnJheShhLndzaXplKSksaT49YS53c2l6ZT8oYS53aW5kb3cuc2V0KGUuc3ViYXJyYXkoQS1hLndzaXplLEEpLDApLGEud25leHQ9MCxhLndoYXZlPWEud3NpemUpOihzPWEud3NpemUtYS53bmV4dCxzPmkmJihzPWkpLGEud2luZG93LnNldChlLnN1YmFycmF5KEEtaSxBLWkrcyksYS53bmV4dCksaS09cyxpPyhhLndpbmRvdy5zZXQoZS5zdWJhcnJheShBLWksQSksMCksYS53bmV4dD1pLGEud2hhdmU9YS53c2l6ZSk6KGEud25leHQrPXMsYS53bmV4dD09PWEud3NpemUmJihhLnduZXh0PTApLGEud2hhdmU8YS53c2l6ZSYmKGEud2hhdmUrPXMpKSksMH0sd249KHQsZSk9PntsZXQgQSxpLHMsYSxuLEUsbyxyLGgsdyxjLGcsZixGLGQ9MCxDLFEsbCxCLEQscCxfLE0sUz1uZXcgVWludDhBcnJheSg0KSxJLFIsWj1uZXcgVWludDhBcnJheShbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV0pO2lmKGNBKHQpfHwhdC5vdXRwdXR8fCF0LmlucHV0JiZ0LmF2YWlsX2luIT09MClyZXR1cm4gTjtBPXQuc3RhdGUsQS5tb2RlPT09WCYmKEEubW9kZT1sdCksbj10Lm5leHRfb3V0LHM9dC5vdXRwdXQsbz10LmF2YWlsX291dCxhPXQubmV4dF9pbixpPXQuaW5wdXQsRT10LmF2YWlsX2luLHI9QS5ob2xkLGg9QS5iaXRzLHc9RSxjPW8sTT1nQTtBOmZvcig7Oylzd2l0Y2goQS5tb2RlKXtjYXNlIEV0OmlmKEEud3JhcD09PTApe0EubW9kZT1sdDticmVha31mb3IoO2g8MTY7KXtpZihFPT09MClicmVhayBBO0UtLSxyKz1pW2ErK108PGgsaCs9OH1pZihBLndyYXAmMiYmcj09PTM1NjE1KXtBLndiaXRzPT09MCYmKEEud2JpdHM9MTUpLEEuY2hlY2s9MCxTWzBdPXImMjU1LFNbMV09cj4+PjgmMjU1LEEuY2hlY2s9UChBLmNoZWNrLFMsMiwwKSxyPTAsaD0wLEEubW9kZT13ZTticmVha31pZihBLmhlYWQmJihBLmhlYWQuZG9uZT0hMSksIShBLndyYXAmMSl8fCgoKHImMjU1KTw8OCkrKHI+PjgpKSUzMSl7dC5tc2c9ImluY29ycmVjdCBoZWFkZXIgY2hlY2siLEEubW9kZT1UO2JyZWFrfWlmKChyJjE1KSE9PUJlKXt0Lm1zZz0idW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QiLEEubW9kZT1UO2JyZWFrfWlmKHI+Pj49NCxoLT00LF89KHImMTUpKzgsQS53Yml0cz09PTAmJihBLndiaXRzPV8pLF8+MTV8fF8+QS53Yml0cyl7dC5tc2c9ImludmFsaWQgd2luZG93IHNpemUiLEEubW9kZT1UO2JyZWFrfUEuZG1heD0xPDxBLndiaXRzLEEuZmxhZ3M9MCx0LmFkbGVyPUEuY2hlY2s9MSxBLm1vZGU9ciY1MTI/RGU6WCxyPTAsaD0wO2JyZWFrO2Nhc2Ugd2U6Zm9yKDtoPDE2Oyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9aWYoQS5mbGFncz1yLChBLmZsYWdzJjI1NSkhPT1CZSl7dC5tc2c9InVua25vd24gY29tcHJlc3Npb24gbWV0aG9kIixBLm1vZGU9VDticmVha31pZihBLmZsYWdzJjU3MzQ0KXt0Lm1zZz0idW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0IixBLm1vZGU9VDticmVha31BLmhlYWQmJihBLmhlYWQudGV4dD1yPj44JjEpLEEuZmxhZ3MmNTEyJiZBLndyYXAmNCYmKFNbMF09ciYyNTUsU1sxXT1yPj4+OCYyNTUsQS5jaGVjaz1QKEEuY2hlY2ssUywyLDApKSxyPTAsaD0wLEEubW9kZT1fZTtjYXNlIF9lOmZvcig7aDwzMjspe2lmKEU9PT0wKWJyZWFrIEE7RS0tLHIrPWlbYSsrXTw8aCxoKz04fUEuaGVhZCYmKEEuaGVhZC50aW1lPXIpLEEuZmxhZ3MmNTEyJiZBLndyYXAmNCYmKFNbMF09ciYyNTUsU1sxXT1yPj4+OCYyNTUsU1syXT1yPj4+MTYmMjU1LFNbM109cj4+PjI0JjI1NSxBLmNoZWNrPVAoQS5jaGVjayxTLDQsMCkpLHI9MCxoPTAsQS5tb2RlPWZlO2Nhc2UgZmU6Zm9yKDtoPDE2Oyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9QS5oZWFkJiYoQS5oZWFkLnhmbGFncz1yJjI1NSxBLmhlYWQub3M9cj4+OCksQS5mbGFncyY1MTImJkEud3JhcCY0JiYoU1swXT1yJjI1NSxTWzFdPXI+Pj44JjI1NSxBLmNoZWNrPVAoQS5jaGVjayxTLDIsMCkpLHI9MCxoPTAsQS5tb2RlPUNlO2Nhc2UgQ2U6aWYoQS5mbGFncyYxMDI0KXtmb3IoO2g8MTY7KXtpZihFPT09MClicmVhayBBO0UtLSxyKz1pW2ErK108PGgsaCs9OH1BLmxlbmd0aD1yLEEuaGVhZCYmKEEuaGVhZC5leHRyYV9sZW49ciksQS5mbGFncyY1MTImJkEud3JhcCY0JiYoU1swXT1yJjI1NSxTWzFdPXI+Pj44JjI1NSxBLmNoZWNrPVAoQS5jaGVjayxTLDIsMCkpLHI9MCxoPTB9ZWxzZSBBLmhlYWQmJihBLmhlYWQuZXh0cmE9bnVsbCk7QS5tb2RlPUllO2Nhc2UgSWU6aWYoQS5mbGFncyYxMDI0JiYoZz1BLmxlbmd0aCxnPkUmJihnPUUpLGcmJihBLmhlYWQmJihfPUEuaGVhZC5leHRyYV9sZW4tQS5sZW5ndGgsQS5oZWFkLmV4dHJhfHwoQS5oZWFkLmV4dHJhPW5ldyBVaW50OEFycmF5KEEuaGVhZC5leHRyYV9sZW4pKSxBLmhlYWQuZXh0cmEuc2V0KGkuc3ViYXJyYXkoYSxhK2cpLF8pKSxBLmZsYWdzJjUxMiYmQS53cmFwJjQmJihBLmNoZWNrPVAoQS5jaGVjayxpLGcsYSkpLEUtPWcsYSs9ZyxBLmxlbmd0aC09ZyksQS5sZW5ndGgpKWJyZWFrIEE7QS5sZW5ndGg9MCxBLm1vZGU9bGU7Y2FzZSBsZTppZihBLmZsYWdzJjIwNDgpe2lmKEU9PT0wKWJyZWFrIEE7Zz0wO2RvIF89aVthK2crK10sQS5oZWFkJiZfJiZBLmxlbmd0aDw2NTUzNiYmKEEuaGVhZC5uYW1lKz1TdHJpbmcuZnJvbUNoYXJDb2RlKF8pKTt3aGlsZShfJiZnPEUpO2lmKEEuZmxhZ3MmNTEyJiZBLndyYXAmNCYmKEEuY2hlY2s9UChBLmNoZWNrLGksZyxhKSksRS09ZyxhKz1nLF8pYnJlYWsgQX1lbHNlIEEuaGVhZCYmKEEuaGVhZC5uYW1lPW51bGwpO0EubGVuZ3RoPTAsQS5tb2RlPWRlO2Nhc2UgZGU6aWYoQS5mbGFncyY0MDk2KXtpZihFPT09MClicmVhayBBO2c9MDtkbyBfPWlbYStnKytdLEEuaGVhZCYmXyYmQS5sZW5ndGg8NjU1MzYmJihBLmhlYWQuY29tbWVudCs9U3RyaW5nLmZyb21DaGFyQ29kZShfKSk7d2hpbGUoXyYmZzxFKTtpZihBLmZsYWdzJjUxMiYmQS53cmFwJjQmJihBLmNoZWNrPVAoQS5jaGVjayxpLGcsYSkpLEUtPWcsYSs9ZyxfKWJyZWFrIEF9ZWxzZSBBLmhlYWQmJihBLmhlYWQuY29tbWVudD1udWxsKTtBLm1vZGU9U2U7Y2FzZSBTZTppZihBLmZsYWdzJjUxMil7Zm9yKDtoPDE2Oyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9aWYoQS53cmFwJjQmJnIhPT0oQS5jaGVjayY2NTUzNSkpe3QubXNnPSJoZWFkZXIgY3JjIG1pc21hdGNoIixBLm1vZGU9VDticmVha31yPTAsaD0wfUEuaGVhZCYmKEEuaGVhZC5oY3JjPUEuZmxhZ3M+PjkmMSxBLmhlYWQuZG9uZT0hMCksdC5hZGxlcj1BLmNoZWNrPTAsQS5tb2RlPVg7YnJlYWs7Y2FzZSBEZTpmb3IoO2g8MzI7KXtpZihFPT09MClicmVhayBBO0UtLSxyKz1pW2ErK108PGgsaCs9OH10LmFkbGVyPUEuY2hlY2s9SGUocikscj0wLGg9MCxBLm1vZGU9c3Q7Y2FzZSBzdDppZihBLmhhdmVkaWN0PT09MClyZXR1cm4gdC5uZXh0X291dD1uLHQuYXZhaWxfb3V0PW8sdC5uZXh0X2luPWEsdC5hdmFpbF9pbj1FLEEuaG9sZD1yLEEuYml0cz1oLGFuO3QuYWRsZXI9QS5jaGVjaz0xLEEubW9kZT1YO2Nhc2UgWDppZihlPT09ZW58fGU9PT1xQSlicmVhayBBO2Nhc2UgbHQ6aWYoQS5sYXN0KXtyPj4+PWgmNyxoLT1oJjcsQS5tb2RlPVN0O2JyZWFrfWZvcig7aDwzOyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9c3dpdGNoKEEubGFzdD1yJjEscj4+Pj0xLGgtPTEsciYzKXtjYXNlIDA6QS5tb2RlPVJlO2JyZWFrO2Nhc2UgMTppZihCbihBKSxBLm1vZGU9JEEsZT09PXFBKXtyPj4+PTIsaC09MjticmVhayBBfWJyZWFrO2Nhc2UgMjpBLm1vZGU9eGU7YnJlYWs7Y2FzZSAzOnQubXNnPSJpbnZhbGlkIGJsb2NrIHR5cGUiLEEubW9kZT1UfXI+Pj49MixoLT0yO2JyZWFrO2Nhc2UgUmU6Zm9yKHI+Pj49aCY3LGgtPWgmNztoPDMyOyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9aWYoKHImNjU1MzUpIT09KHI+Pj4xNl42NTUzNSkpe3QubXNnPSJpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzIixBLm1vZGU9VDticmVha31pZihBLmxlbmd0aD1yJjY1NTM1LHI9MCxoPTAsQS5tb2RlPWR0LGU9PT1xQSlicmVhayBBO2Nhc2UgZHQ6QS5tb2RlPU1lO2Nhc2UgTWU6aWYoZz1BLmxlbmd0aCxnKXtpZihnPkUmJihnPUUpLGc+byYmKGc9byksZz09PTApYnJlYWsgQTtzLnNldChpLnN1YmFycmF5KGEsYStnKSxuKSxFLT1nLGErPWcsby09ZyxuKz1nLEEubGVuZ3RoLT1nO2JyZWFrfUEubW9kZT1YO2JyZWFrO2Nhc2UgeGU6Zm9yKDtoPDE0Oyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9aWYoQS5ubGVuPShyJjMxKSsyNTcscj4+Pj01LGgtPTUsQS5uZGlzdD0ociYzMSkrMSxyPj4+PTUsaC09NSxBLm5jb2RlPShyJjE1KSs0LHI+Pj49NCxoLT00LEEubmxlbj4yODZ8fEEubmRpc3Q+MzApe3QubXNnPSJ0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyIsQS5tb2RlPVQ7YnJlYWt9QS5oYXZlPTAsQS5tb2RlPVFlO2Nhc2UgUWU6Zm9yKDtBLmhhdmU8QS5uY29kZTspe2Zvcig7aDwzOyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9QS5sZW5zW1pbQS5oYXZlKytdXT1yJjcscj4+Pj0zLGgtPTN9Zm9yKDtBLmhhdmU8MTk7KUEubGVuc1taW0EuaGF2ZSsrXV09MDtpZihBLmxlbmNvZGU9QS5sZW5keW4sQS5sZW5iaXRzPTcsST17Yml0czpBLmxlbmJpdHN9LE09VEEodG4sQS5sZW5zLDAsMTksQS5sZW5jb2RlLDAsQS53b3JrLEkpLEEubGVuYml0cz1JLmJpdHMsTSl7dC5tc2c9ImludmFsaWQgY29kZSBsZW5ndGhzIHNldCIsQS5tb2RlPVQ7YnJlYWt9QS5oYXZlPTAsQS5tb2RlPXVlO2Nhc2UgdWU6Zm9yKDtBLmhhdmU8QS5ubGVuK0EubmRpc3Q7KXtmb3IoO2Q9QS5sZW5jb2RlW3ImKDE8PEEubGVuYml0cyktMV0sQz1kPj4+MjQsUT1kPj4+MTYmMjU1LGw9ZCY2NTUzNSwhKEM8PWgpOyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9aWYobDwxNilyPj4+PUMsaC09QyxBLmxlbnNbQS5oYXZlKytdPWw7ZWxzZXtpZihsPT09MTYpe2ZvcihSPUMrMjtoPFI7KXtpZihFPT09MClicmVhayBBO0UtLSxyKz1pW2ErK108PGgsaCs9OH1pZihyPj4+PUMsaC09QyxBLmhhdmU9PT0wKXt0Lm1zZz0iaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCIsQS5tb2RlPVQ7YnJlYWt9Xz1BLmxlbnNbQS5oYXZlLTFdLGc9MysociYzKSxyPj4+PTIsaC09Mn1lbHNlIGlmKGw9PT0xNyl7Zm9yKFI9QyszO2g8Ujspe2lmKEU9PT0wKWJyZWFrIEE7RS0tLHIrPWlbYSsrXTw8aCxoKz04fXI+Pj49QyxoLT1DLF89MCxnPTMrKHImNykscj4+Pj0zLGgtPTN9ZWxzZXtmb3IoUj1DKzc7aDxSOyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9cj4+Pj1DLGgtPUMsXz0wLGc9MTErKHImMTI3KSxyPj4+PTcsaC09N31pZihBLmhhdmUrZz5BLm5sZW4rQS5uZGlzdCl7dC5tc2c9ImludmFsaWQgYml0IGxlbmd0aCByZXBlYXQiLEEubW9kZT1UO2JyZWFrfWZvcig7Zy0tOylBLmxlbnNbQS5oYXZlKytdPV99fWlmKEEubW9kZT09PVQpYnJlYWs7aWYoQS5sZW5zWzI1Nl09PT0wKXt0Lm1zZz0iaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrIixBLm1vZGU9VDticmVha31pZihBLmxlbmJpdHM9OSxJPXtiaXRzOkEubGVuYml0c30sTT1UQShFaSxBLmxlbnMsMCxBLm5sZW4sQS5sZW5jb2RlLDAsQS53b3JrLEkpLEEubGVuYml0cz1JLmJpdHMsTSl7dC5tc2c9ImludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCIsQS5tb2RlPVQ7YnJlYWt9aWYoQS5kaXN0Yml0cz02LEEuZGlzdGNvZGU9QS5kaXN0ZHluLEk9e2JpdHM6QS5kaXN0Yml0c30sTT1UQShyaSxBLmxlbnMsQS5ubGVuLEEubmRpc3QsQS5kaXN0Y29kZSwwLEEud29yayxJKSxBLmRpc3RiaXRzPUkuYml0cyxNKXt0Lm1zZz0iaW52YWxpZCBkaXN0YW5jZXMgc2V0IixBLm1vZGU9VDticmVha31pZihBLm1vZGU9JEEsZT09PXFBKWJyZWFrIEE7Y2FzZSAkQTpBLm1vZGU9QXQ7Y2FzZSBBdDppZihFPj02JiZvPj0yNTgpe3QubmV4dF9vdXQ9bix0LmF2YWlsX291dD1vLHQubmV4dF9pbj1hLHQuYXZhaWxfaW49RSxBLmhvbGQ9cixBLmJpdHM9aCxaYSh0LGMpLG49dC5uZXh0X291dCxzPXQub3V0cHV0LG89dC5hdmFpbF9vdXQsYT10Lm5leHRfaW4saT10LmlucHV0LEU9dC5hdmFpbF9pbixyPUEuaG9sZCxoPUEuYml0cyxBLm1vZGU9PT1YJiYoQS5iYWNrPS0xKTticmVha31mb3IoQS5iYWNrPTA7ZD1BLmxlbmNvZGVbciYoMTw8QS5sZW5iaXRzKS0xXSxDPWQ+Pj4yNCxRPWQ+Pj4xNiYyNTUsbD1kJjY1NTM1LCEoQzw9aCk7KXtpZihFPT09MClicmVhayBBO0UtLSxyKz1pW2ErK108PGgsaCs9OH1pZihRJiYoUSYyNDApPT09MCl7Zm9yKEI9QyxEPVEscD1sO2Q9QS5sZW5jb2RlW3ArKChyJigxPDxCK0QpLTEpPj5CKV0sQz1kPj4+MjQsUT1kPj4+MTYmMjU1LGw9ZCY2NTUzNSwhKEIrQzw9aCk7KXtpZihFPT09MClicmVhayBBO0UtLSxyKz1pW2ErK108PGgsaCs9OH1yPj4+PUIsaC09QixBLmJhY2srPUJ9aWYocj4+Pj1DLGgtPUMsQS5iYWNrKz1DLEEubGVuZ3RoPWwsUT09PTApe0EubW9kZT1QZTticmVha31pZihRJjMyKXtBLmJhY2s9LTEsQS5tb2RlPVg7YnJlYWt9aWYoUSY2NCl7dC5tc2c9ImludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSIsQS5tb2RlPVQ7YnJlYWt9QS5leHRyYT1RJjE1LEEubW9kZT1GZTtjYXNlIEZlOmlmKEEuZXh0cmEpe2ZvcihSPUEuZXh0cmE7aDxSOyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9QS5sZW5ndGgrPXImKDE8PEEuZXh0cmEpLTEscj4+Pj1BLmV4dHJhLGgtPUEuZXh0cmEsQS5iYWNrKz1BLmV4dHJhfUEud2FzPUEubGVuZ3RoLEEubW9kZT1UZTtjYXNlIFRlOmZvcig7ZD1BLmRpc3Rjb2RlW3ImKDE8PEEuZGlzdGJpdHMpLTFdLEM9ZD4+PjI0LFE9ZD4+PjE2JjI1NSxsPWQmNjU1MzUsIShDPD1oKTspe2lmKEU9PT0wKWJyZWFrIEE7RS0tLHIrPWlbYSsrXTw8aCxoKz04fWlmKChRJjI0MCk9PT0wKXtmb3IoQj1DLEQ9USxwPWw7ZD1BLmRpc3Rjb2RlW3ArKChyJigxPDxCK0QpLTEpPj5CKV0sQz1kPj4+MjQsUT1kPj4+MTYmMjU1LGw9ZCY2NTUzNSwhKEIrQzw9aCk7KXtpZihFPT09MClicmVhayBBO0UtLSxyKz1pW2ErK108PGgsaCs9OH1yPj4+PUIsaC09QixBLmJhY2srPUJ9aWYocj4+Pj1DLGgtPUMsQS5iYWNrKz1DLFEmNjQpe3QubXNnPSJpbnZhbGlkIGRpc3RhbmNlIGNvZGUiLEEubW9kZT1UO2JyZWFrfUEub2Zmc2V0PWwsQS5leHRyYT1RJjE1LEEubW9kZT1wZTtjYXNlIHBlOmlmKEEuZXh0cmEpe2ZvcihSPUEuZXh0cmE7aDxSOyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9QS5vZmZzZXQrPXImKDE8PEEuZXh0cmEpLTEscj4+Pj1BLmV4dHJhLGgtPUEuZXh0cmEsQS5iYWNrKz1BLmV4dHJhfWlmKEEub2Zmc2V0PkEuZG1heCl7dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIixBLm1vZGU9VDticmVha31BLm1vZGU9VWU7Y2FzZSBVZTppZihvPT09MClicmVhayBBO2lmKGc9Yy1vLEEub2Zmc2V0Pmcpe2lmKGc9QS5vZmZzZXQtZyxnPkEud2hhdmUmJkEuc2FuZSl7dC5tc2c9ImludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrIixBLm1vZGU9VDticmVha31nPkEud25leHQ/KGctPUEud25leHQsZj1BLndzaXplLWcpOmY9QS53bmV4dC1nLGc+QS5sZW5ndGgmJihnPUEubGVuZ3RoKSxGPUEud2luZG93fWVsc2UgRj1zLGY9bi1BLm9mZnNldCxnPUEubGVuZ3RoO2c+byYmKGc9byksby09ZyxBLmxlbmd0aC09ZztkbyBzW24rK109RltmKytdO3doaWxlKC0tZyk7QS5sZW5ndGg9PT0wJiYoQS5tb2RlPUF0KTticmVhaztjYXNlIFBlOmlmKG89PT0wKWJyZWFrIEE7c1tuKytdPUEubGVuZ3RoLG8tLSxBLm1vZGU9QXQ7YnJlYWs7Y2FzZSBTdDppZihBLndyYXApe2Zvcig7aDwzMjspe2lmKEU9PT0wKWJyZWFrIEE7RS0tLHJ8PWlbYSsrXTw8aCxoKz04fWlmKGMtPW8sdC50b3RhbF9vdXQrPWMsQS50b3RhbCs9YyxBLndyYXAmNCYmYyYmKHQuYWRsZXI9QS5jaGVjaz1BLmZsYWdzP1AoQS5jaGVjayxzLGMsbi1jKTpPQShBLmNoZWNrLHMsYyxuLWMpKSxjPW8sQS53cmFwJjQmJihBLmZsYWdzP3I6SGUocikpIT09QS5jaGVjayl7dC5tc2c9ImluY29ycmVjdCBkYXRhIGNoZWNrIixBLm1vZGU9VDticmVha31yPTAsaD0wfUEubW9kZT1rZTtjYXNlIGtlOmlmKEEud3JhcCYmQS5mbGFncyl7Zm9yKDtoPDMyOyl7aWYoRT09PTApYnJlYWsgQTtFLS0scis9aVthKytdPDxoLGgrPTh9aWYoQS53cmFwJjQmJnIhPT0oQS50b3RhbCY0Mjk0OTY3Mjk1KSl7dC5tc2c9ImluY29ycmVjdCBsZW5ndGggY2hlY2siLEEubW9kZT1UO2JyZWFrfXI9MCxoPTB9QS5tb2RlPU9lO2Nhc2UgT2U6TT1zbjticmVhayBBO2Nhc2UgVDpNPWhpO2JyZWFrIEE7Y2FzZSBnaTpyZXR1cm4gb2k7Y2FzZSBjaTpkZWZhdWx0OnJldHVybiBOfXJldHVybiB0Lm5leHRfb3V0PW4sdC5hdmFpbF9vdXQ9byx0Lm5leHRfaW49YSx0LmF2YWlsX2luPUUsQS5ob2xkPXIsQS5iaXRzPWgsKEEud3NpemV8fGMhPT10LmF2YWlsX291dCYmQS5tb2RlPFQmJihBLm1vZGU8U3R8fGUhPT1jZSkpJiZDaSh0LHQub3V0cHV0LHQubmV4dF9vdXQsYy10LmF2YWlsX291dCksdy09dC5hdmFpbF9pbixjLT10LmF2YWlsX291dCx0LnRvdGFsX2luKz13LHQudG90YWxfb3V0Kz1jLEEudG90YWwrPWMsQS53cmFwJjQmJmMmJih0LmFkbGVyPUEuY2hlY2s9QS5mbGFncz9QKEEuY2hlY2sscyxjLHQubmV4dF9vdXQtYyk6T0EoQS5jaGVjayxzLGMsdC5uZXh0X291dC1jKSksdC5kYXRhX3R5cGU9QS5iaXRzKyhBLmxhc3Q/NjQ6MCkrKEEubW9kZT09PVg/MTI4OjApKyhBLm1vZGU9PT0kQXx8QS5tb2RlPT09ZHQ/MjU2OjApLCh3PT09MCYmYz09PTB8fGU9PT1jZSkmJk09PT1nQSYmKE09bm4pLE19LF9uPXQ9PntpZihjQSh0KSlyZXR1cm4gTjtsZXQgZT10LnN0YXRlO3JldHVybiBlLndpbmRvdyYmKGUud2luZG93PW51bGwpLHQuc3RhdGU9bnVsbCxnQX0sZm49KHQsZSk9PntpZihjQSh0KSlyZXR1cm4gTjtsZXQgQT10LnN0YXRlO3JldHVybihBLndyYXAmMik9PT0wP046KEEuaGVhZD1lLGUuZG9uZT0hMSxnQSl9LENuPSh0LGUpPT57bGV0IEE9ZS5sZW5ndGgsaSxzLGE7cmV0dXJuIGNBKHQpfHwoaT10LnN0YXRlLGkud3JhcCE9PTAmJmkubW9kZSE9PXN0KT9OOmkubW9kZT09PXN0JiYocz0xLHM9T0EocyxlLEEsMCkscyE9PWkuY2hlY2spP2hpOihhPUNpKHQsZSxBLEEpLGE/KGkubW9kZT1naSxvaSk6KGkuaGF2ZWRpY3Q9MSxnQSkpfSxJbj13aSxsbj1faSxkbj1CaSxTbj1jbixEbj1maSxSbj13bixNbj1fbix4bj1mbixRbj1Dbix1bj0icGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSIscT17aW5mbGF0ZVJlc2V0OkluLGluZmxhdGVSZXNldDI6bG4saW5mbGF0ZVJlc2V0S2VlcDpkbixpbmZsYXRlSW5pdDpTbixpbmZsYXRlSW5pdDI6RG4saW5mbGF0ZTpSbixpbmZsYXRlRW5kOk1uLGluZmxhdGVHZXRIZWFkZXI6eG4saW5mbGF0ZVNldERpY3Rpb25hcnk6UW4saW5mbGF0ZUluZm86dW59O2Z1bmN0aW9uIEZuKCl7dGhpcy50ZXh0PTAsdGhpcy50aW1lPTAsdGhpcy54ZmxhZ3M9MCx0aGlzLm9zPTAsdGhpcy5leHRyYT1udWxsLHRoaXMuZXh0cmFfbGVuPTAsdGhpcy5uYW1lPSIiLHRoaXMuY29tbWVudD0iIix0aGlzLmhjcmM9MCx0aGlzLmRvbmU9ITF9dmFyIFRuPUZuLElpPU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcse1pfTk9fRkxVU0g6cG4sWl9GSU5JU0g6VW4sWl9PSzpZQSxaX1NUUkVBTV9FTkQ6TXQsWl9ORUVEX0RJQ1Q6eHQsWl9TVFJFQU1fRVJST1I6UG4sWl9EQVRBX0VSUk9SOlllLFpfTUVNX0VSUk9SOmtufT1TQTtmdW5jdGlvbiBLQSh0KXt0aGlzLm9wdGlvbnM9bnQuYXNzaWduKHtjaHVua1NpemU6MTAyNCo2NCx3aW5kb3dCaXRzOjE1LHRvOiIifSx0fHx7fSk7bGV0IGU9dGhpcy5vcHRpb25zO2UucmF3JiZlLndpbmRvd0JpdHM+PTAmJmUud2luZG93Qml0czwxNiYmKGUud2luZG93Qml0cz0tZS53aW5kb3dCaXRzLGUud2luZG93Qml0cz09PTAmJihlLndpbmRvd0JpdHM9LTE1KSksZS53aW5kb3dCaXRzPj0wJiZlLndpbmRvd0JpdHM8MTYmJiEodCYmdC53aW5kb3dCaXRzKSYmKGUud2luZG93Qml0cys9MzIpLGUud2luZG93Qml0cz4xNSYmZS53aW5kb3dCaXRzPDQ4JiYoZS53aW5kb3dCaXRzJjE1KT09PTAmJihlLndpbmRvd0JpdHN8PTE1KSx0aGlzLmVycj0wLHRoaXMubXNnPSIiLHRoaXMuZW5kZWQ9ITEsdGhpcy5jaHVua3M9W10sdGhpcy5zdHJtPW5ldyBhaSx0aGlzLnN0cm0uYXZhaWxfb3V0PTA7bGV0IEE9cS5pbmZsYXRlSW5pdDIodGhpcy5zdHJtLGUud2luZG93Qml0cyk7aWYoQSE9PVlBKXRocm93IG5ldyBFcnJvcihoQVtBXSk7aWYodGhpcy5oZWFkZXI9bmV3IFRuLHEuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sdGhpcy5oZWFkZXIpLGUuZGljdGlvbmFyeSYmKHR5cGVvZiBlLmRpY3Rpb25hcnk9PSJzdHJpbmciP2UuZGljdGlvbmFyeT15QS5zdHJpbmcyYnVmKGUuZGljdGlvbmFyeSk6SWkuY2FsbChlLmRpY3Rpb25hcnkpPT09IltvYmplY3QgQXJyYXlCdWZmZXJdIiYmKGUuZGljdGlvbmFyeT1uZXcgVWludDhBcnJheShlLmRpY3Rpb25hcnkpKSxlLnJhdyYmKEE9cS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sZS5kaWN0aW9uYXJ5KSxBIT09WUEpKSl0aHJvdyBuZXcgRXJyb3IoaEFbQV0pfUtBLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQsZSl7bGV0IEE9dGhpcy5zdHJtLGk9dGhpcy5vcHRpb25zLmNodW5rU2l6ZSxzPXRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5LGEsbixFO2lmKHRoaXMuZW5kZWQpcmV0dXJuITE7Zm9yKGU9PT1+fmU/bj1lOm49ZT09PSEwP1VuOnBuLElpLmNhbGwodCk9PT0iW29iamVjdCBBcnJheUJ1ZmZlcl0iP0EuaW5wdXQ9bmV3IFVpbnQ4QXJyYXkodCk6QS5pbnB1dD10LEEubmV4dF9pbj0wLEEuYXZhaWxfaW49QS5pbnB1dC5sZW5ndGg7Oyl7Zm9yKEEuYXZhaWxfb3V0PT09MCYmKEEub3V0cHV0PW5ldyBVaW50OEFycmF5KGkpLEEubmV4dF9vdXQ9MCxBLmF2YWlsX291dD1pKSxhPXEuaW5mbGF0ZShBLG4pLGE9PT14dCYmcyYmKGE9cS5pbmZsYXRlU2V0RGljdGlvbmFyeShBLHMpLGE9PT1ZQT9hPXEuaW5mbGF0ZShBLG4pOmE9PT1ZZSYmKGE9eHQpKTtBLmF2YWlsX2luPjAmJmE9PT1NdCYmQS5zdGF0ZS53cmFwPjAmJnRbQS5uZXh0X2luXSE9PTA7KXEuaW5mbGF0ZVJlc2V0KEEpLGE9cS5pbmZsYXRlKEEsbik7c3dpdGNoKGEpe2Nhc2UgUG46Y2FzZSBZZTpjYXNlIHh0OmNhc2Uga246cmV0dXJuIHRoaXMub25FbmQoYSksdGhpcy5lbmRlZD0hMCwhMX1pZihFPUEuYXZhaWxfb3V0LEEubmV4dF9vdXQmJihBLmF2YWlsX291dD09PTB8fGE9PT1NdCkpaWYodGhpcy5vcHRpb25zLnRvPT09InN0cmluZyIpe2xldCBvPXlBLnV0Zjhib3JkZXIoQS5vdXRwdXQsQS5uZXh0X291dCkscj1BLm5leHRfb3V0LW8saD15QS5idWYyc3RyaW5nKEEub3V0cHV0LG8pO0EubmV4dF9vdXQ9cixBLmF2YWlsX291dD1pLXIsciYmQS5vdXRwdXQuc2V0KEEub3V0cHV0LnN1YmFycmF5KG8sbytyKSwwKSx0aGlzLm9uRGF0YShoKX1lbHNlIHRoaXMub25EYXRhKEEub3V0cHV0Lmxlbmd0aD09PUEubmV4dF9vdXQ/QS5vdXRwdXQ6QS5vdXRwdXQuc3ViYXJyYXkoMCxBLm5leHRfb3V0KSk7aWYoIShhPT09WUEmJkU9PT0wKSl7aWYoYT09PU10KXJldHVybiBhPXEuaW5mbGF0ZUVuZCh0aGlzLnN0cm0pLHRoaXMub25FbmQoYSksdGhpcy5lbmRlZD0hMCwhMDtpZihBLmF2YWlsX2luPT09MClicmVha319cmV0dXJuITB9O0tBLnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24odCl7dGhpcy5jaHVua3MucHVzaCh0KX07S0EucHJvdG90eXBlLm9uRW5kPWZ1bmN0aW9uKHQpe3Q9PT1ZQSYmKHRoaXMub3B0aW9ucy50bz09PSJzdHJpbmciP3RoaXMucmVzdWx0PXRoaXMuY2h1bmtzLmpvaW4oIiIpOnRoaXMucmVzdWx0PW50LmZsYXR0ZW5DaHVua3ModGhpcy5jaHVua3MpKSx0aGlzLmNodW5rcz1bXSx0aGlzLmVycj10LHRoaXMubXNnPXRoaXMuc3RybS5tc2d9O2Z1bmN0aW9uIEt0KHQsZSl7bGV0IEE9bmV3IEtBKGUpO2lmKEEucHVzaCh0KSxBLmVycil0aHJvdyBBLm1zZ3x8aEFbQS5lcnJdO3JldHVybiBBLnJlc3VsdH1mdW5jdGlvbiBPbih0LGUpe3JldHVybiBlPWV8fHt9LGUucmF3PSEwLEt0KHQsZSl9dmFyIEhuPUtBLHluPUt0LFluPU9uLGJuPUt0LEduPVNBLG1uPXtJbmZsYXRlOkhuLGluZmxhdGU6eW4saW5mbGF0ZVJhdzpZbix1bmd6aXA6Ym4sY29uc3RhbnRzOkdufSx7RGVmbGF0ZTppRSxkZWZsYXRlOktuLGRlZmxhdGVSYXc6c0UsZ3ppcDphRX09emEse0luZmxhdGU6TG4saW5mbGF0ZTpuRSxpbmZsYXRlUmF3OkVFLHVuZ3ppcDpyRX09bW47dmFyIGxpPUtuO3ZhciBkaT1Mbjt2YXIgTEE9Y2xhc3N7Y29uc3RydWN0b3IoZSxBPSExLGk9ITApe3RoaXMuZGV2aWNlPWUsdGhpcy50cmFjaW5nPUEsdGhpcy5zbGlwUmVhZGVyRW5hYmxlZD0hMSx0aGlzLmJhdWRyYXRlPTAsdGhpcy50cmFjZUxvZz0iIix0aGlzLmxhc3RUcmFjZVRpbWU9RGF0ZS5ub3coKSx0aGlzLmJ1ZmZlcj1uZXcgVWludDhBcnJheSgwKSx0aGlzLlNMSVBfRU5EPTE5Mix0aGlzLlNMSVBfRVNDPTIxOSx0aGlzLlNMSVBfRVNDX0VORD0yMjAsdGhpcy5TTElQX0VTQ19FU0M9MjIxLHRoaXMuX0RUUl9zdGF0ZT0hMSx0aGlzLnNsaXBSZWFkZXJFbmFibGVkPWl9Z2V0SW5mbygpe2xldCBlPXRoaXMuZGV2aWNlLmdldEluZm8oKTtyZXR1cm4gZS51c2JWZW5kb3JJZCYmZS51c2JQcm9kdWN0SWQ/YFdlYlNlcmlhbCBWZW5kb3JJRCAweCR7ZS51c2JWZW5kb3JJZC50b1N0cmluZygxNil9IFByb2R1Y3RJRCAweCR7ZS51c2JQcm9kdWN0SWQudG9TdHJpbmcoMTYpfWA6IiJ9Z2V0UGlkKCl7cmV0dXJuIHRoaXMuZGV2aWNlLmdldEluZm8oKS51c2JQcm9kdWN0SWR9dHJhY2UoZSl7bGV0IHM9YCR7YFRSQUNFICR7KERhdGUubm93KCktdGhpcy5sYXN0VHJhY2VUaW1lKS50b0ZpeGVkKDMpfWB9ICR7ZX1gO2NvbnNvbGUubG9nKHMpLHRoaXMudHJhY2VMb2crPXMrYApgfWFzeW5jIHJldHVyblRyYWNlKCl7dHJ5e2F3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRoaXMudHJhY2VMb2cpLGNvbnNvbGUubG9nKCJUZXh0IGNvcGllZCB0byBjbGlwYm9hcmQhIil9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcigiRmFpbGVkIHRvIGNvcHkgdGV4dDoiLGUpfX1oZXhpZnkoZSl7cmV0dXJuIEFycmF5LmZyb20oZSkubWFwKEE9PkEudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIjAiKSkuam9pbigiIikucGFkRW5kKDE2LCIgIil9aGV4Q29udmVydChlLEE9ITApe2lmKEEmJmUubGVuZ3RoPjE2KXtsZXQgaT0iIixzPWU7Zm9yKDtzLmxlbmd0aD4wOyl7bGV0IGE9cy5zbGljZSgwLDE2KSxuPVN0cmluZy5mcm9tQ2hhckNvZGUoLi4uYSkuc3BsaXQoIiIpLm1hcChFPT5FPT09IiAifHxFPj0iICImJkU8PSJ+IiYmRSE9PSIgICI/RToiLiIpLmpvaW4oIiIpO3M9cy5zbGljZSgxNiksaSs9YAogICAgJHt0aGlzLmhleGlmeShhLnNsaWNlKDAsOCkpfSAke3RoaXMuaGV4aWZ5KGEuc2xpY2UoOCkpfSB8ICR7bn1gfXJldHVybiBpfWVsc2UgcmV0dXJuIHRoaXMuaGV4aWZ5KGUpfXNsaXBXcml0ZXIoZSl7bGV0IEE9W107QS5wdXNoKDE5Mik7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDtpKyspZVtpXT09PTIxOT9BLnB1c2goMjE5LDIyMSk6ZVtpXT09PTE5Mj9BLnB1c2goMjE5LDIyMCk6QS5wdXNoKGVbaV0pO3JldHVybiBBLnB1c2goMTkyKSxuZXcgVWludDhBcnJheShBKX1hc3luYyB3cml0ZShlKXtsZXQgQT10aGlzLnNsaXBXcml0ZXIoZSk7aWYodGhpcy5kZXZpY2Uud3JpdGFibGUpe2xldCBpPXRoaXMuZGV2aWNlLndyaXRhYmxlLmdldFdyaXRlcigpO3RoaXMudHJhY2luZyYmKGNvbnNvbGUubG9nKCJXcml0ZSBieXRlcyIpLHRoaXMudHJhY2UoYFdyaXRlICR7QS5sZW5ndGh9IGJ5dGVzOiAke3RoaXMuaGV4Q29udmVydChBKX1gKSksYXdhaXQgaS53cml0ZShBKSxpLnJlbGVhc2VMb2NrKCl9fWFwcGVuZEFycmF5KGUsQSl7bGV0IGk9bmV3IFVpbnQ4QXJyYXkoZS5sZW5ndGgrQS5sZW5ndGgpO3JldHVybiBpLnNldChlKSxpLnNldChBLGUubGVuZ3RoKSxpfWFzeW5jKnJlYWRMb29wKGUpe2lmKHRoaXMucmVhZGVyKXRyeXtmb3IoOzspe2xldCBBPW5ldyBQcm9taXNlKChuLEUpPT5zZXRUaW1lb3V0KCgpPT5FKG5ldyBFcnJvcigiUmVhZCB0aW1lb3V0IGV4Y2VlZGVkIikpLGUpKSxpPWF3YWl0IFByb21pc2UucmFjZShbdGhpcy5yZWFkZXIucmVhZCgpLEFdKTtpZihpPT09bnVsbClicmVhaztsZXR7dmFsdWU6cyxkb25lOmF9PWk7aWYoYXx8IXMpYnJlYWs7eWllbGQgc319Y2F0Y2goQSl7Y29uc29sZS5lcnJvcigiRXJyb3IgcmVhZGluZyBmcm9tIHNlcmlhbCBwb3J0OiIsQSl9ZmluYWxseXt0aGlzLmJ1ZmZlcj1uZXcgVWludDhBcnJheSgwKX19YXN5bmMgbmV3UmVhZChlLEEpe2lmKHRoaXMuYnVmZmVyLmxlbmd0aD49ZSl7bGV0IHM9dGhpcy5idWZmZXIuc2xpY2UoMCxlKTtyZXR1cm4gdGhpcy5idWZmZXI9dGhpcy5idWZmZXIuc2xpY2UoZSksc31mb3IoO3RoaXMuYnVmZmVyLmxlbmd0aDxlOyl7bGV0IHM9dGhpcy5yZWFkTG9vcChBKSx7dmFsdWU6YSxkb25lOm59PWF3YWl0IHMubmV4dCgpO2lmKG58fCFhKWJyZWFrO3RoaXMuYnVmZmVyPXRoaXMuYXBwZW5kQXJyYXkodGhpcy5idWZmZXIsYSl9bGV0IGk9dGhpcy5idWZmZXIuc2xpY2UoMCxlKTtyZXR1cm4gdGhpcy5idWZmZXI9dGhpcy5idWZmZXIuc2xpY2UoZSksaX1hc3luYyBmbHVzaElucHV0KCl7dmFyIGU7dGhpcy5yZWFkZXImJiFhd2FpdCB0aGlzLnJlYWRlci5jbG9zZWQmJihhd2FpdCB0aGlzLnJlYWRlci5jYW5jZWwoKSx0aGlzLnJlYWRlci5yZWxlYXNlTG9jaygpLHRoaXMucmVhZGVyPShlPXRoaXMuZGV2aWNlLnJlYWRhYmxlKT09PW51bGx8fGU9PT12b2lkIDA/dm9pZCAwOmUuZ2V0UmVhZGVyKCkpfWFzeW5jIGZsdXNoT3V0cHV0KCl7dmFyIGUsQTt0aGlzLmJ1ZmZlcj1uZXcgVWludDhBcnJheSgwKSxhd2FpdCgoZT10aGlzLmRldmljZS53cml0YWJsZSk9PT1udWxsfHxlPT09dm9pZCAwP3ZvaWQgMDplLmdldFdyaXRlcigpLmNsb3NlKCkpLChBPXRoaXMuZGV2aWNlLndyaXRhYmxlKT09PW51bGx8fEE9PT12b2lkIDB8fEEuZ2V0V3JpdGVyKCkucmVsZWFzZUxvY2soKX1pbldhaXRpbmcoKXtyZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RofWRldGVjdFBhbmljSGFuZGxlcihlKXtsZXQgQT0vRz91cnUgTWVkaXRhdGlvbiBFcnJvcjogKD86Q29yZSBcZCBwYW5pYydlZCBcKChbYS16QS1aIF0qKVwpKT8vLGk9L0Y/YXRhbCBleGNlcHRpb24gXChcZCtcKTogKD86KFthLXpBLVogXSopPy4qZXBjKT8vLHM9bmV3IFRleHREZWNvZGVyKCJ1dGYtOCIpLmRlY29kZShlKSxhPXMubWF0Y2goQSl8fHMubWF0Y2goaSk7aWYoYSl7bGV0IG49YVsxXXx8YVsyXSxFPWBHdXJ1IE1lZGl0YXRpb24gRXJyb3IgZGV0ZWN0ZWQke24/YCAoJHtufSlgOiIifWA7dGhyb3cgbmV3IEVycm9yKEUpfX1hc3luYypyZWFkKGUpe3ZhciBBO3RoaXMucmVhZGVyfHwodGhpcy5yZWFkZXI9KEE9dGhpcy5kZXZpY2UucmVhZGFibGUpPT09bnVsbHx8QT09PXZvaWQgMD92b2lkIDA6QS5nZXRSZWFkZXIoKSk7bGV0IGk9bnVsbCxzPSExLGE9ITE7Zm9yKDs7KXtsZXQgbj10aGlzLmluV2FpdGluZygpLEU9YXdhaXQgdGhpcy5uZXdSZWFkKG4+MD9uOjEsZSk7aWYoIUV8fEUubGVuZ3RoPT09MCl7bGV0IHI9aT09PW51bGw/YT8iU2VyaWFsIGRhdGEgc3RyZWFtIHN0b3BwZWQ6IFBvc3NpYmxlIHNlcmlhbCBub2lzZSBvciBjb3JydXB0aW9uLiI6Ik5vIHNlcmlhbCBkYXRhIHJlY2VpdmVkLiI6IlBhY2tldCBjb250ZW50IHRyYW5zZmVyIHN0b3BwZWQiO3Rocm93IHRoaXMudHJhY2UociksbmV3IEVycm9yKHIpfXRoaXMudHJhY2UoYFJlYWQgJHtFLmxlbmd0aH0gYnl0ZXM6ICR7dGhpcy5oZXhDb252ZXJ0KEUpfWApO2xldCBvPTA7Zm9yKDtvPEUubGVuZ3RoOyl7bGV0IHI9RVtvKytdO2lmKGk9PT1udWxsKWlmKHI9PT10aGlzLlNMSVBfRU5EKWk9bmV3IFVpbnQ4QXJyYXkoMCk7ZWxzZXt0aGlzLnRyYWNlKGBSZWFkIGludmFsaWQgZGF0YTogJHt0aGlzLmhleENvbnZlcnQoRSl9YCk7bGV0IGg9YXdhaXQgdGhpcy5uZXdSZWFkKHRoaXMuaW5XYWl0aW5nKCksZSk7dGhyb3cgdGhpcy50cmFjZShgUmVtYWluaW5nIGRhdGEgaW4gc2VyaWFsIGJ1ZmZlcjogJHt0aGlzLmhleENvbnZlcnQoaCl9YCksdGhpcy5kZXRlY3RQYW5pY0hhbmRsZXIobmV3IFVpbnQ4QXJyYXkoWy4uLkUsLi4uaHx8W11dKSksbmV3IEVycm9yKGBJbnZhbGlkIGhlYWQgb2YgcGFja2V0ICgweCR7ci50b1N0cmluZygxNil9KTogUG9zc2libGUgc2VyaWFsIG5vaXNlIG9yIGNvcnJ1cHRpb24uYCl9ZWxzZSBpZihzKWlmKHM9ITEscj09PXRoaXMuU0xJUF9FU0NfRU5EKWk9dGhpcy5hcHBlbmRBcnJheShpLG5ldyBVaW50OEFycmF5KFt0aGlzLlNMSVBfRU5EXSkpO2Vsc2UgaWYocj09PXRoaXMuU0xJUF9FU0NfRVNDKWk9dGhpcy5hcHBlbmRBcnJheShpLG5ldyBVaW50OEFycmF5KFt0aGlzLlNMSVBfRVNDXSkpO2Vsc2V7dGhpcy50cmFjZShgUmVhZCBpbnZhbGlkIGRhdGE6ICR7dGhpcy5oZXhDb252ZXJ0KEUpfWApO2xldCBoPWF3YWl0IHRoaXMubmV3UmVhZCh0aGlzLmluV2FpdGluZygpLGUpO3Rocm93IHRoaXMudHJhY2UoYFJlbWFpbmluZyBkYXRhIGluIHNlcmlhbCBidWZmZXI6ICR7dGhpcy5oZXhDb252ZXJ0KGgpfWApLHRoaXMuZGV0ZWN0UGFuaWNIYW5kbGVyKG5ldyBVaW50OEFycmF5KFsuLi5FLC4uLmh8fFtdXSkpLG5ldyBFcnJvcihgSW52YWxpZCBTTElQIGVzY2FwZSAoMHhkYiwgMHgke3IudG9TdHJpbmcoMTYpfSlgKX1lbHNlIHI9PT10aGlzLlNMSVBfRVNDP3M9ITA6cj09PXRoaXMuU0xJUF9FTkQ/KHRoaXMudHJhY2UoYFJlY2VpdmVkIGZ1bGwgcGFja2V0OiAke3RoaXMuaGV4Q29udmVydChpKX1gKSx0aGlzLmJ1ZmZlcj10aGlzLmFwcGVuZEFycmF5KHRoaXMuYnVmZmVyLEUuc2xpY2UobykpLHlpZWxkIGksaT1udWxsLGE9ITApOmk9dGhpcy5hcHBlbmRBcnJheShpLG5ldyBVaW50OEFycmF5KFtyXSkpfX19YXN5bmMqcmF3UmVhZCgpe2lmKHRoaXMucmVhZGVyKXRyeXtmb3IoOzspe2xldHt2YWx1ZTplLGRvbmU6QX09YXdhaXQgdGhpcy5yZWFkZXIucmVhZCgpO2lmKEF8fCFlKWJyZWFrO3RoaXMudHJhY2luZyYmKGNvbnNvbGUubG9nKCJSYXcgUmVhZCBieXRlcyIpLHRoaXMudHJhY2UoYFJlYWQgJHtlLmxlbmd0aH0gYnl0ZXM6ICR7dGhpcy5oZXhDb252ZXJ0KGUpfWApKSx5aWVsZCBlfX1jYXRjaChlKXtjb25zb2xlLmVycm9yKCJFcnJvciByZWFkaW5nIGZyb20gc2VyaWFsIHBvcnQ6IixlKX1maW5hbGx5e3RoaXMuYnVmZmVyPW5ldyBVaW50OEFycmF5KDApfX1hc3luYyBzZXRSVFMoZSl7YXdhaXQgdGhpcy5kZXZpY2Uuc2V0U2lnbmFscyh7cmVxdWVzdFRvU2VuZDplfSksYXdhaXQgdGhpcy5zZXREVFIodGhpcy5fRFRSX3N0YXRlKX1hc3luYyBzZXREVFIoZSl7dGhpcy5fRFRSX3N0YXRlPWUsYXdhaXQgdGhpcy5kZXZpY2Uuc2V0U2lnbmFscyh7ZGF0YVRlcm1pbmFsUmVhZHk6ZX0pfWFzeW5jIGNvbm5lY3QoZT0xMTUyMDAsQT17fSl7dmFyIGk7YXdhaXQgdGhpcy5kZXZpY2Uub3Blbih7YmF1ZFJhdGU6ZSxkYXRhQml0czpBPy5kYXRhQml0cyxzdG9wQml0czpBPy5zdG9wQml0cyxidWZmZXJTaXplOkE/LmJ1ZmZlclNpemUscGFyaXR5OkE/LnBhcml0eSxmbG93Q29udHJvbDpBPy5mbG93Q29udHJvbH0pLHRoaXMuYmF1ZHJhdGU9ZSx0aGlzLnJlYWRlcj0oaT10aGlzLmRldmljZS5yZWFkYWJsZSk9PT1udWxsfHxpPT09dm9pZCAwP3ZvaWQgMDppLmdldFJlYWRlcigpfWFzeW5jIHNsZWVwKGUpe3JldHVybiBuZXcgUHJvbWlzZShBPT5zZXRUaW1lb3V0KEEsZSkpfWFzeW5jIHdhaXRGb3JVbmxvY2soZSl7Zm9yKDt0aGlzLmRldmljZS5yZWFkYWJsZSYmdGhpcy5kZXZpY2UucmVhZGFibGUubG9ja2VkfHx0aGlzLmRldmljZS53cml0YWJsZSYmdGhpcy5kZXZpY2Uud3JpdGFibGUubG9ja2VkOylhd2FpdCB0aGlzLnNsZWVwKGUpfWFzeW5jIGRpc2Nvbm5lY3QoKXt2YXIgZSxBOyEoKGU9dGhpcy5kZXZpY2UucmVhZGFibGUpPT09bnVsbHx8ZT09PXZvaWQgMCkmJmUubG9ja2VkJiZhd2FpdCgoQT10aGlzLnJlYWRlcik9PT1udWxsfHxBPT09dm9pZCAwP3ZvaWQgMDpBLmNhbmNlbCgpKSxhd2FpdCB0aGlzLndhaXRGb3JVbmxvY2soNDAwKSxhd2FpdCB0aGlzLmRldmljZS5jbG9zZSgpLHRoaXMucmVhZGVyPXZvaWQgMH19O2Z1bmN0aW9uICQodCl7cmV0dXJuIG5ldyBQcm9taXNlKGU9PnNldFRpbWVvdXQoZSx0KSl9dmFyIE5BPWNsYXNze2NvbnN0cnVjdG9yKGUsQSl7dGhpcy5yZXNldERlbGF5PUEsdGhpcy50cmFuc3BvcnQ9ZX1hc3luYyByZXNldCgpe2F3YWl0IHRoaXMudHJhbnNwb3J0LnNldERUUighMSksYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0UlRTKCEwKSxhd2FpdCAkKDEwMCksYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0RFRSKCEwKSxhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXRSVFMoITEpLGF3YWl0ICQodGhpcy5yZXNldERlbGF5KSxhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXREVFIoITEpfX0sSkE9Y2xhc3N7Y29uc3RydWN0b3IoZSl7dGhpcy50cmFuc3BvcnQ9ZX1hc3luYyByZXNldCgpe2F3YWl0IHRoaXMudHJhbnNwb3J0LnNldFJUUyghMSksYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0RFRSKCExKSxhd2FpdCAkKDEwMCksYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0RFRSKCEwKSxhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXRSVFMoITEpLGF3YWl0ICQoMTAwKSxhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXRSVFMoITApLGF3YWl0IHRoaXMudHJhbnNwb3J0LnNldERUUighMSksYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0UlRTKCEwKSxhd2FpdCAkKDEwMCksYXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0UlRTKCExKSxhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZXREVFIoITEpfX0sdkE9Y2xhc3N7Y29uc3RydWN0b3IoZSxBPSExKXt0aGlzLnRyYW5zcG9ydD1lLHRoaXMudXNpbmdVc2JPdGc9QSx0aGlzLnRyYW5zcG9ydD1lfWFzeW5jIHJlc2V0KCl7dGhpcy51c2luZ1VzYk90Zz8oYXdhaXQgJCgyMDApLGF3YWl0IHRoaXMudHJhbnNwb3J0LnNldFJUUyghMSksYXdhaXQgJCgyMDApKTooYXdhaXQgJCgxMDApLGF3YWl0IHRoaXMudHJhbnNwb3J0LnNldFJUUyghMSkpfX07ZnVuY3Rpb24gU2kodCl7bGV0IGU9WyJEIiwiUiIsIlciXSxBPXQuc3BsaXQoInwiKTtmb3IobGV0IGkgb2YgQSl7bGV0IHM9aVswXSxhPWkuc2xpY2UoMSk7aWYoIWUuaW5jbHVkZXMocykpcmV0dXJuITE7aWYocz09PSJEInx8cz09PSJSIil7aWYoYSE9PSIwIiYmYSE9PSIxIilyZXR1cm4hMX1lbHNlIGlmKHM9PT0iVyIpe2xldCBuPXBhcnNlSW50KGEpO2lmKGlzTmFOKG4pfHxuPD0wKXJldHVybiExfX1yZXR1cm4hMH12YXIgV0E9Y2xhc3N7Y29uc3RydWN0b3IoZSxBKXt0aGlzLnRyYW5zcG9ydD1lLHRoaXMuc2VxdWVuY2VTdHJpbmc9QSx0aGlzLnRyYW5zcG9ydD1lfWFzeW5jIHJlc2V0KCl7bGV0IGU9e0Q6YXN5bmMgQT0+YXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0RFRSKEEpLFI6YXN5bmMgQT0+YXdhaXQgdGhpcy50cmFuc3BvcnQuc2V0UlRTKEEpLFc6YXN5bmMgQT0+YXdhaXQgJChBKX07dHJ5e2lmKCFTaSh0aGlzLnNlcXVlbmNlU3RyaW5nKSlyZXR1cm47bGV0IGk9dGhpcy5zZXF1ZW5jZVN0cmluZy5zcGxpdCgifCIpO2ZvcihsZXQgcyBvZiBpKXtsZXQgYT1zWzBdLG49cy5zbGljZSgxKTthPT09IlciP2F3YWl0IGUuVyhOdW1iZXIobikpOihhPT09IkQifHxhPT09IlIiKSYmYXdhaXQgZVthXShuPT09IjEiKX19Y2F0Y2h7dGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGN1c3RvbSByZXNldCBzZXF1ZW5jZSIpfX19O3ZhciBIaT1LKFJpKCkpO2FzeW5jIGZ1bmN0aW9uIHJ0KHQpe2xldCBlO3N3aXRjaCh0KXtjYXNlIkVTUDMyIjplPWF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PksoTWkoKSkpO2JyZWFrO2Nhc2UiRVNQMzItQzIiOmU9YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+Syh4aSgpKSk7YnJlYWs7Y2FzZSJFU1AzMi1DMyI6ZT1hd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5LKFFpKCkpKTticmVhaztjYXNlIkVTUDMyLUM1IjplPWF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PksodWkoKSkpO2JyZWFrO2Nhc2UiRVNQMzItQzYiOmU9YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+SyhGaSgpKSk7YnJlYWs7Y2FzZSJFU1AzMi1DNjEiOmU9YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+SyhUaSgpKSk7YnJlYWs7Y2FzZSJFU1AzMi1IMiI6ZT1hd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5LKHBpKCkpKTticmVhaztjYXNlIkVTUDMyLVA0IjplPWF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PksoVWkoKSkpO2JyZWFrO2Nhc2UiRVNQMzItUzIiOmU9YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+SyhQaSgpKSk7YnJlYWs7Y2FzZSJFU1AzMi1TMyI6ZT1hd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5LKGtpKCkpKTticmVhaztjYXNlIkVTUDgyNjYiOmU9YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+SyhPaSgpKSk7YnJlYWt9aWYoZSlyZXR1cm57YnNzX3N0YXJ0OmUuYnNzX3N0YXJ0LGRhdGE6ZS5kYXRhLGRhdGFfc3RhcnQ6ZS5kYXRhX3N0YXJ0LGVudHJ5OmUuZW50cnksdGV4dDplLnRleHQsdGV4dF9zdGFydDplLnRleHRfc3RhcnQsZGVjb2RlZERhdGE6THQoZS5kYXRhKSxkZWNvZGVkVGV4dDpMdChlLnRleHQpfX1mdW5jdGlvbiBMdCh0KXtsZXQgQT0oMCxIaS5kZWZhdWx0KSh0KS5zcGxpdCgiIikubWFwKGZ1bmN0aW9uKGkpe3JldHVybiBpLmNoYXJDb2RlQXQoMCl9KTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQSl9ZnVuY3Rpb24geWkodCxlLEE9MjU1KXtsZXQgaT10Lmxlbmd0aCVlO2lmKGkhPT0wKXtsZXQgcz1uZXcgVWludDhBcnJheShlLWkpLmZpbGwoQSksYT1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCtzLmxlbmd0aCk7cmV0dXJuIGEuc2V0KHQpLGEuc2V0KHMsdC5sZW5ndGgpLGF9cmV0dXJuIHR9YXN5bmMgZnVuY3Rpb24gQUUodCl7c3dpdGNoKHQpe2Nhc2UgMTU3MzYxOTU6e2xldHtFU1AzMlJPTTplfT1hd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT4oTnQoKSxZaSkpO3JldHVybiBuZXcgZX1jYXNlIDIwMzU0NjczNTpjYXNlIDE4Njc1OTE3OTE6Y2FzZSAyMDg0Njc1Njk1OntsZXR7RVNQMzJDMlJPTTplfT1hd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT4obWkoKSxHaSkpO3JldHVybiBuZXcgZX1jYXNlIDE3NjM3OTA5NTk6Y2FzZSA0NTYyMTY2ODc6Y2FzZSAxMjE2NDM4MzgzOmNhc2UgMTEzMDQ1NTE1MTp7bGV0e0VTUDMyQzNST006ZX09YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+KEp0KCksYmkpKTtyZXR1cm4gbmV3IGV9Y2FzZSA3NTI5MTA0NDc6e2xldHtFU1AzMkM2Uk9NOmV9PWF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PihodCgpLEtpKSk7cmV0dXJuIG5ldyBlfWNhc2UgNjA2MTY3MTUxOmNhc2UgODcxMzc0OTU5OmNhc2UgMTMzMzg3ODg5NTp7bGV0e0VTUDMyQzYxUk9NOmV9PWF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PihOaSgpLExpKSk7cmV0dXJuIG5ldyBlfWNhc2UgMjg1Mjk0NzAzOmNhc2UgMTY3NTcwNjQ3OTpjYXNlIDE2MDc1NDkwMzk6e2xldHtFU1AzMkM1Uk9NOmV9PWF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pih2aSgpLEppKSk7cmV0dXJuIG5ldyBlfWNhc2UgMzYxOTExMDUyODpjYXNlIDI1NDgyMzYzOTI6e2xldHtFU1AzMkgyUk9NOmV9PWF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9Pih6aSgpLFdpKSk7cmV0dXJuIG5ldyBlfWNhc2UgOTp7bGV0e0VTUDMyUzNST006ZX09YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+KFppKCksamkpKTtyZXR1cm4gbmV3IGV9Y2FzZSAxOTkwOntsZXR7RVNQMzJTMlJPTTplfT1hd2FpdCBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT4oVmkoKSxYaSkpO3JldHVybiBuZXcgZX1jYXNlIDQyOTM5NjgxMjk6e2xldHtFU1A4MjY2Uk9NOmV9PWF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PigkaSgpLHFpKSk7cmV0dXJuIG5ldyBlfWNhc2UgMDpjYXNlIDE4MjMwMzQ0MDpjYXNlIDExNzY3Njc2MTp7bGV0e0VTUDMyUDRST006ZX09YXdhaXQgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+KHRzKCksQXMpKTtyZXR1cm4gbmV3IGV9ZGVmYXVsdDpyZXR1cm4gbnVsbH19dmFyICR0PWNsYXNze2NvbnN0cnVjdG9yKGUpe3ZhciBBLGkscyxhLG4sRSxvLHI7dGhpcy5FU1BfUkFNX0JMT0NLPTYxNDQsdGhpcy5FU1BfRkxBU0hfQkVHSU49Mix0aGlzLkVTUF9GTEFTSF9EQVRBPTMsdGhpcy5FU1BfRkxBU0hfRU5EPTQsdGhpcy5FU1BfTUVNX0JFR0lOPTUsdGhpcy5FU1BfTUVNX0VORD02LHRoaXMuRVNQX01FTV9EQVRBPTcsdGhpcy5FU1BfV1JJVEVfUkVHPTksdGhpcy5FU1BfUkVBRF9SRUc9MTAsdGhpcy5FU1BfU1BJX0FUVEFDSD0xMyx0aGlzLkVTUF9DSEFOR0VfQkFVRFJBVEU9MTUsdGhpcy5FU1BfRkxBU0hfREVGTF9CRUdJTj0xNix0aGlzLkVTUF9GTEFTSF9ERUZMX0RBVEE9MTcsdGhpcy5FU1BfRkxBU0hfREVGTF9FTkQ9MTgsdGhpcy5FU1BfU1BJX0ZMQVNIX01ENT0xOSx0aGlzLkVTUF9FUkFTRV9GTEFTSD0yMDgsdGhpcy5FU1BfRVJBU0VfUkVHSU9OPTIwOSx0aGlzLkVTUF9SRUFEX0ZMQVNIPTIxMCx0aGlzLkVTUF9SVU5fVVNFUl9DT0RFPTIxMSx0aGlzLkVTUF9JTUFHRV9NQUdJQz0yMzMsdGhpcy5FU1BfQ0hFQ0tTVU1fTUFHSUM9MjM5LHRoaXMuUk9NX0lOVkFMSURfUkVDVl9NU0c9NSx0aGlzLkRFRkFVTFRfVElNRU9VVD0zZTMsdGhpcy5FUkFTRV9SRUdJT05fVElNRU9VVF9QRVJfTUI9M2U0LHRoaXMuRVJBU0VfV1JJVEVfVElNRU9VVF9QRVJfTUI9NGU0LHRoaXMuTUQ1X1RJTUVPVVRfUEVSX01CPThlMyx0aGlzLkNISVBfRVJBU0VfVElNRU9VVD0xMmU0LHRoaXMuRkxBU0hfUkVBRF9USU1FT1VUPTFlNSx0aGlzLk1BWF9USU1FT1VUPXRoaXMuQ0hJUF9FUkFTRV9USU1FT1VUKjIsdGhpcy5DSElQX0RFVEVDVF9NQUdJQ19SRUdfQUREUj0xMDczNzQ1OTIwLHRoaXMuREVURUNURURfRkxBU0hfU0laRVM9ezE4OiIyNTZLQiIsMTk6IjUxMktCIiwyMDoiMU1CIiwyMToiMk1CIiwyMjoiNE1CIiwyMzoiOE1CIiwyNDoiMTZNQiJ9LHRoaXMuREVURUNURURfRkxBU0hfU0laRVNfTlVNPXsxODoyNTYsMTk6NTEyLDIwOjEwMjQsMjE6MjA0OCwyMjo0MDk2LDIzOjgxOTIsMjQ6MTYzODR9LHRoaXMuVVNCX0pUQUdfU0VSSUFMX1BJRD00MDk3LHRoaXMucm9tQmF1ZHJhdGU9MTE1MjAwLHRoaXMuZGVidWdMb2dnaW5nPSExLHRoaXMuc3luY1N0dWJEZXRlY3RlZD0hMSx0aGlzLmZsYXNoU2l6ZUJ5dGVzPWZ1bmN0aW9uKGgpe2xldCB3PS0xO3JldHVybiBoLmluZGV4T2YoIktCIikhPT0tMT93PXBhcnNlSW50KGguc2xpY2UoMCxoLmluZGV4T2YoIktCIikpKSoxMDI0OmguaW5kZXhPZigiTUIiKSE9PS0xJiYodz1wYXJzZUludChoLnNsaWNlKDAsaC5pbmRleE9mKCJNQiIpKSkqMTAyNCoxMDI0KSx3fSx0aGlzLklTX1NUVUI9ITEsdGhpcy5GTEFTSF9XUklURV9TSVpFPTE2Mzg0LHRoaXMudHJhbnNwb3J0PWUudHJhbnNwb3J0LHRoaXMuYmF1ZHJhdGU9ZS5iYXVkcmF0ZSx0aGlzLnJlc2V0Q29uc3RydWN0b3JzPXtjbGFzc2ljUmVzZXQ6KGgsdyk9Pm5ldyBOQShoLHcpLGN1c3RvbVJlc2V0OihoLHcpPT5uZXcgV0EoaCx3KSxoYXJkUmVzZXQ6KGgsdyk9Pm5ldyB2QShoLHcpLHVzYkpUQUdTZXJpYWxSZXNldDpoPT5uZXcgSkEoaCl9LGUuc2VyaWFsT3B0aW9ucyYmKHRoaXMuc2VyaWFsT3B0aW9ucz1lLnNlcmlhbE9wdGlvbnMpLGUucm9tQmF1ZHJhdGUmJih0aGlzLnJvbUJhdWRyYXRlPWUucm9tQmF1ZHJhdGUpLGUudGVybWluYWwmJih0aGlzLnRlcm1pbmFsPWUudGVybWluYWwsdGhpcy50ZXJtaW5hbC5jbGVhbigpKSx0eXBlb2YgZS5kZWJ1Z0xvZ2dpbmc8InUiJiYodGhpcy5kZWJ1Z0xvZ2dpbmc9ZS5kZWJ1Z0xvZ2dpbmcpLGUucG9ydCYmKHRoaXMudHJhbnNwb3J0PW5ldyBMQShlLnBvcnQpKSx0eXBlb2YgZS5lbmFibGVUcmFjaW5nPCJ1IiYmKHRoaXMudHJhbnNwb3J0LnRyYWNpbmc9ZS5lbmFibGVUcmFjaW5nKSwhKChBPWUucmVzZXRDb25zdHJ1Y3RvcnMpPT09bnVsbHx8QT09PXZvaWQgMCkmJkEuY2xhc3NpY1Jlc2V0JiYodGhpcy5yZXNldENvbnN0cnVjdG9ycy5jbGFzc2ljUmVzZXQ9KGk9ZS5yZXNldENvbnN0cnVjdG9ycyk9PT1udWxsfHxpPT09dm9pZCAwP3ZvaWQgMDppLmNsYXNzaWNSZXNldCksISgocz1lLnJlc2V0Q29uc3RydWN0b3JzKT09PW51bGx8fHM9PT12b2lkIDApJiZzLmN1c3RvbVJlc2V0JiYodGhpcy5yZXNldENvbnN0cnVjdG9ycy5jdXN0b21SZXNldD0oYT1lLnJlc2V0Q29uc3RydWN0b3JzKT09PW51bGx8fGE9PT12b2lkIDA/dm9pZCAwOmEuY3VzdG9tUmVzZXQpLCEoKG49ZS5yZXNldENvbnN0cnVjdG9ycyk9PT1udWxsfHxuPT09dm9pZCAwKSYmbi5oYXJkUmVzZXQmJih0aGlzLnJlc2V0Q29uc3RydWN0b3JzLmhhcmRSZXNldD0oRT1lLnJlc2V0Q29uc3RydWN0b3JzKT09PW51bGx8fEU9PT12b2lkIDA/dm9pZCAwOkUuaGFyZFJlc2V0KSwhKChvPWUucmVzZXRDb25zdHJ1Y3RvcnMpPT09bnVsbHx8bz09PXZvaWQgMCkmJm8udXNiSlRBR1NlcmlhbFJlc2V0JiYodGhpcy5yZXNldENvbnN0cnVjdG9ycy51c2JKVEFHU2VyaWFsUmVzZXQ9KHI9ZS5yZXNldENvbnN0cnVjdG9ycyk9PT1udWxsfHxyPT09dm9pZCAwP3ZvaWQgMDpyLnVzYkpUQUdTZXJpYWxSZXNldCksdGhpcy5pbmZvKCJlc3B0b29sLmpzIiksdGhpcy5pbmZvKCJTZXJpYWwgcG9ydCAiK3RoaXMudHJhbnNwb3J0LmdldEluZm8oKSl9X3NsZWVwKGUpe3JldHVybiBuZXcgUHJvbWlzZShBPT5zZXRUaW1lb3V0KEEsZSkpfXdyaXRlKGUsQT0hMCl7dGhpcy50ZXJtaW5hbD9BP3RoaXMudGVybWluYWwud3JpdGVMaW5lKGUpOnRoaXMudGVybWluYWwud3JpdGUoZSk6Y29uc29sZS5sb2coZSl9ZXJyb3IoZSxBPSEwKXt0aGlzLndyaXRlKGBFcnJvcjogJHtlfWAsQSl9aW5mbyhlLEE9ITApe3RoaXMud3JpdGUoZSxBKX1kZWJ1ZyhlLEE9ITApe3RoaXMuZGVidWdMb2dnaW5nJiZ0aGlzLndyaXRlKGBEZWJ1ZzogJHtlfWAsQSl9X3Nob3J0VG9CeXRlYXJyYXkoZSl7cmV0dXJuIG5ldyBVaW50OEFycmF5KFtlJjI1NSxlPj44JjI1NV0pfV9pbnRUb0J5dGVBcnJheShlKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW2UmMjU1LGU+PjgmMjU1LGU+PjE2JjI1NSxlPj4yNCYyNTVdKX1fYnl0ZUFycmF5VG9TaG9ydChlLEEpe3JldHVybiBlfEE+Pjh9X2J5dGVBcnJheVRvSW50KGUsQSxpLHMpe3JldHVybiBlfEE8PDh8aTw8MTZ8czw8MjR9X2FwcGVuZEJ1ZmZlcihlLEEpe2xldCBpPW5ldyBVaW50OEFycmF5KGUuYnl0ZUxlbmd0aCtBLmJ5dGVMZW5ndGgpO3JldHVybiBpLnNldChuZXcgVWludDhBcnJheShlKSwwKSxpLnNldChuZXcgVWludDhBcnJheShBKSxlLmJ5dGVMZW5ndGgpLGkuYnVmZmVyfV9hcHBlbmRBcnJheShlLEEpe2xldCBpPW5ldyBVaW50OEFycmF5KGUubGVuZ3RoK0EubGVuZ3RoKTtyZXR1cm4gaS5zZXQoZSwwKSxpLnNldChBLGUubGVuZ3RoKSxpfXVpOFRvQnN0cihlKXtsZXQgQT0iIjtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKylBKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbaV0pO3JldHVybiBBfWJzdHJUb1VpOChlKXtsZXQgQT1uZXcgVWludDhBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDtpKyspQVtpXT1lLmNoYXJDb2RlQXQoaSk7cmV0dXJuIEF9YXN5bmMgZmx1c2hJbnB1dCgpe3RyeXthd2FpdCB0aGlzLnRyYW5zcG9ydC5mbHVzaElucHV0KCl9Y2F0Y2goZSl7dGhpcy5lcnJvcihlLm1lc3NhZ2UpfX1hc3luYyByZWFkUGFja2V0KGU9bnVsbCxBPXRoaXMuREVGQVVMVF9USU1FT1VUKXtmb3IobGV0IGk9MDtpPDEwMDtpKyspe2xldHt2YWx1ZTpzfT1hd2FpdCB0aGlzLnRyYW5zcG9ydC5yZWFkKEEpLm5leHQoKTtpZighc3x8cy5sZW5ndGg8OCljb250aW51ZTtsZXQgYT1zWzBdO2lmKGEhPT0xKWNvbnRpbnVlO2xldCBuPXNbMV0sRT10aGlzLl9ieXRlQXJyYXlUb0ludChzWzRdLHNbNV0sc1s2XSxzWzddKSxvPXMuc2xpY2UoOCk7aWYoYT09MSl7aWYoZT09bnVsbHx8bj09ZSlyZXR1cm5bRSxvXTtpZihvWzBdIT0wJiZvWzFdPT10aGlzLlJPTV9JTlZBTElEX1JFQ1ZfTVNHKXRocm93IGF3YWl0IHRoaXMuZmx1c2hJbnB1dCgpLG5ldyBVKCJ1bnN1cHBvcnRlZCBjb21tYW5kIGVycm9yIil9fXRocm93IG5ldyBVKCJpbnZhbGlkIHJlc3BvbnNlIil9YXN5bmMgY29tbWFuZChlPW51bGwsQT1uZXcgVWludDhBcnJheSgwKSxpPTAscz0hMCxhPXRoaXMuREVGQVVMVF9USU1FT1VUKXtpZihlIT1udWxsKXt0aGlzLnRyYW5zcG9ydC50cmFjaW5nJiZ0aGlzLnRyYW5zcG9ydC50cmFjZShgY29tbWFuZCBvcDoweCR7ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwiMCIpfSBkYXRhIGxlbj0ke0EubGVuZ3RofSB3YWl0X3Jlc3BvbnNlPSR7cz8xOjB9IHRpbWVvdXQ9JHsoYS8xZTMpLnRvRml4ZWQoMyl9IGRhdGE9JHt0aGlzLnRyYW5zcG9ydC5oZXhDb252ZXJ0KEEpfWApO2xldCBuPW5ldyBVaW50OEFycmF5KDgrQS5sZW5ndGgpO25bMF09MCxuWzFdPWUsblsyXT10aGlzLl9zaG9ydFRvQnl0ZWFycmF5KEEubGVuZ3RoKVswXSxuWzNdPXRoaXMuX3Nob3J0VG9CeXRlYXJyYXkoQS5sZW5ndGgpWzFdLG5bNF09dGhpcy5faW50VG9CeXRlQXJyYXkoaSlbMF0sbls1XT10aGlzLl9pbnRUb0J5dGVBcnJheShpKVsxXSxuWzZdPXRoaXMuX2ludFRvQnl0ZUFycmF5KGkpWzJdLG5bN109dGhpcy5faW50VG9CeXRlQXJyYXkoaSlbM107bGV0IEU7Zm9yKEU9MDtFPEEubGVuZ3RoO0UrKyluWzgrRV09QVtFXTthd2FpdCB0aGlzLnRyYW5zcG9ydC53cml0ZShuKX1yZXR1cm4gcz90aGlzLnJlYWRQYWNrZXQoZSxhKTpbMCxuZXcgVWludDhBcnJheSgwKV19YXN5bmMgcmVhZFJlZyhlLEE9dGhpcy5ERUZBVUxUX1RJTUVPVVQpe2xldCBpPXRoaXMuX2ludFRvQnl0ZUFycmF5KGUpO3JldHVybihhd2FpdCB0aGlzLmNvbW1hbmQodGhpcy5FU1BfUkVBRF9SRUcsaSx2b2lkIDAsdm9pZCAwLEEpKVswXX1hc3luYyB3cml0ZVJlZyhlLEEsaT00Mjk0OTY3Mjk1LHM9MCxhPTApe2xldCBuPXRoaXMuX2FwcGVuZEFycmF5KHRoaXMuX2ludFRvQnl0ZUFycmF5KGUpLHRoaXMuX2ludFRvQnl0ZUFycmF5KEEpKTtuPXRoaXMuX2FwcGVuZEFycmF5KG4sdGhpcy5faW50VG9CeXRlQXJyYXkoaSkpLG49dGhpcy5fYXBwZW5kQXJyYXkobix0aGlzLl9pbnRUb0J5dGVBcnJheShzKSksYT4wJiYobj10aGlzLl9hcHBlbmRBcnJheShuLHRoaXMuX2ludFRvQnl0ZUFycmF5KHRoaXMuY2hpcC5VQVJUX0RBVEVfUkVHX0FERFIpKSxuPXRoaXMuX2FwcGVuZEFycmF5KG4sdGhpcy5faW50VG9CeXRlQXJyYXkoMCkpLG49dGhpcy5fYXBwZW5kQXJyYXkobix0aGlzLl9pbnRUb0J5dGVBcnJheSgwKSksbj10aGlzLl9hcHBlbmRBcnJheShuLHRoaXMuX2ludFRvQnl0ZUFycmF5KGEpKSksYXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoIndyaXRlIHRhcmdldCBtZW1vcnkiLHRoaXMuRVNQX1dSSVRFX1JFRyxuKX1hc3luYyBzeW5jKCl7dGhpcy5kZWJ1ZygiU3luYyIpO2xldCBlPW5ldyBVaW50OEFycmF5KDM2KSxBO2ZvcihlWzBdPTcsZVsxXT03LGVbMl09MTgsZVszXT0zMixBPTA7QTwzMjtBKyspZVs0K0FdPTg1O3RyeXtsZXQgaT1hd2FpdCB0aGlzLmNvbW1hbmQoOCxlLHZvaWQgMCx2b2lkIDAsMTAwKTt0aGlzLnN5bmNTdHViRGV0ZWN0ZWQ9aVswXT09PTA7Zm9yKGxldCBzPTA7czw3O3MrKylpPWF3YWl0IHRoaXMuY29tbWFuZCgpLHRoaXMuc3luY1N0dWJEZXRlY3RlZD10aGlzLnN5bmNTdHViRGV0ZWN0ZWQmJmlbMF09PT0wO3JldHVybiBpfWNhdGNoKGkpe3Rocm93IHRoaXMuZGVidWcoIlN5bmMgZXJyICIraSksaX19YXN5bmMgX2Nvbm5lY3RBdHRlbXB0KGU9ImRlZmF1bHRfcmVzZXQiLEEpe3RoaXMuZGVidWcoIl9jb25uZWN0X2F0dGVtcHQgIitlKSxBJiZhd2FpdCBBLnJlc2V0KCk7bGV0IGk9dGhpcy50cmFuc3BvcnQuaW5XYWl0aW5nKCkscz1hd2FpdCB0aGlzLnRyYW5zcG9ydC5uZXdSZWFkKGk+MD9pOjEsdGhpcy5ERUZBVUxUX1RJTUVPVVQpLGE9QXJyYXkuZnJvbShzLGM9PlN0cmluZy5mcm9tQ2hhckNvZGUoYykpLmpvaW4oIiIpLG49L2Jvb3Q6KDB4WzAtOWEtZkEtRl0rKSguKndhaXRpbmcgZm9yIGRvd25sb2FkKT8vLEU9YS5tYXRjaChuKSxvPSExLHI9IiIsaD0hMTtFJiYobz0hMCxyPUVbMV0saD0hIUVbMl0pO2xldCB3PSIiO2ZvcihsZXQgYz0wO2M8NTtjKyspdHJ5e3RoaXMuZGVidWcoYFN5bmMgY29ubmVjdCBhdHRlbXB0ICR7Y31gKTtsZXQgZz1hd2FpdCB0aGlzLnN5bmMoKTtyZXR1cm4gdGhpcy5kZWJ1ZyhnWzBdLnRvU3RyaW5nKCkpLCJzdWNjZXNzIn1jYXRjaChnKXt0aGlzLmRlYnVnKGBFcnJvciBhdCBzeW5jICR7Z31gKSxnIGluc3RhbmNlb2YgRXJyb3I/dz1nLm1lc3NhZ2U6dHlwZW9mIGc9PSJzdHJpbmciP3c9Zzp3PUpTT04uc3RyaW5naWZ5KGcpfXJldHVybiBvJiYodz1gV3JvbmcgYm9vdCBtb2RlIGRldGVjdGVkICgke3J9KS4KICAgICAgICBUaGlzIGNoaXAgbmVlZHMgdG8gYmUgaW4gZG93bmxvYWQgbW9kZS5gLGgmJih3PWBEb3dubG9hZCBtb2RlIHN1Y2Nlc3NmdWxseSBkZXRlY3RlZCwgYnV0IGdldHRpbmcgbm8gc3luYyByZXBseToKICAgICAgICAgICBUaGUgc2VyaWFsIFRYIHBhdGggc2VlbXMgdG8gYmUgZG93bi5gKSksd31jb25zdHJ1Y3RSZXNldFNlcXVlbmNlKGUpe2lmKGUhPT0ibm9fcmVzZXQiKXtpZihlPT09InVzYl9yZXNldCJ8fHRoaXMudHJhbnNwb3J0LmdldFBpZCgpPT09dGhpcy5VU0JfSlRBR19TRVJJQUxfUElEKXtpZih0aGlzLnJlc2V0Q29uc3RydWN0b3JzLnVzYkpUQUdTZXJpYWxSZXNldClyZXR1cm4gdGhpcy5kZWJ1ZygidXNpbmcgVVNCIEpUQUcgU2VyaWFsIFJlc2V0IiksW3RoaXMucmVzZXRDb25zdHJ1Y3RvcnMudXNiSlRBR1NlcmlhbFJlc2V0KHRoaXMudHJhbnNwb3J0KV19ZWxzZSBpZih0aGlzLnJlc2V0Q29uc3RydWN0b3JzLmNsYXNzaWNSZXNldClyZXR1cm4gdGhpcy5kZWJ1ZygidXNpbmcgQ2xhc3NpYyBTZXJpYWwgUmVzZXQiKSxbdGhpcy5yZXNldENvbnN0cnVjdG9ycy5jbGFzc2ljUmVzZXQodGhpcy50cmFuc3BvcnQsNTApLHRoaXMucmVzZXRDb25zdHJ1Y3RvcnMuY2xhc3NpY1Jlc2V0KHRoaXMudHJhbnNwb3J0LDU1MCldfXJldHVybltdfWFzeW5jIGNvbm5lY3QoZT0iZGVmYXVsdF9yZXNldCIsQT03LGk9ITApe2xldCBzO3RoaXMuaW5mbygiQ29ubmVjdGluZy4uLiIsITEpLGF3YWl0IHRoaXMudHJhbnNwb3J0LmNvbm5lY3QodGhpcy5yb21CYXVkcmF0ZSx0aGlzLnNlcmlhbE9wdGlvbnMpO2xldCBhPXRoaXMuY29uc3RydWN0UmVzZXRTZXF1ZW5jZShlKTtmb3IobGV0IG49MDtuPEE7bisrKXtsZXQgRT1hLmxlbmd0aD4wP2FbbiVhLmxlbmd0aF06bnVsbDtpZihzPWF3YWl0IHRoaXMuX2Nvbm5lY3RBdHRlbXB0KGUsRSkscz09PSJzdWNjZXNzIilicmVha31pZihzIT09InN1Y2Nlc3MiKXRocm93IG5ldyBVKCJGYWlsZWQgdG8gY29ubmVjdCB3aXRoIHRoZSBkZXZpY2UiKTtpZih0aGlzLmRlYnVnKCJDb25uZWN0IGF0dGVtcHQgc3VjY2Vzc2Z1bC4iKSx0aGlzLmluZm8oYApccmAsITEpLGkpe2xldCBuPWF3YWl0IHRoaXMucmVhZFJlZyh0aGlzLkNISVBfREVURUNUX01BR0lDX1JFR19BRERSKT4+PjA7dGhpcy5kZWJ1ZygiQ2hpcCBNYWdpYyAiK24udG9TdHJpbmcoMTYpKTtsZXQgRT1hd2FpdCBBRShuKTtpZih0aGlzLmNoaXA9PT1udWxsKXRocm93IG5ldyBVKGBVbmV4cGVjdGVkIENISVAgbWFnaWMgdmFsdWUgJHtufS4gRmFpbGVkIHRvIGF1dG9kZXRlY3QgY2hpcCB0eXBlLmApO3RoaXMuY2hpcD1FfX1hc3luYyBkZXRlY3RDaGlwKGU9ImRlZmF1bHRfcmVzZXQiKXthd2FpdCB0aGlzLmNvbm5lY3QoZSksdGhpcy5pbmZvKCJEZXRlY3RpbmcgY2hpcCB0eXBlLi4uICIsITEpLHRoaXMuY2hpcCE9bnVsbD90aGlzLmluZm8odGhpcy5jaGlwLkNISVBfTkFNRSk6dGhpcy5pbmZvKCJ1bmtub3duISIpfWFzeW5jIGNoZWNrQ29tbWFuZChlPSIiLEE9bnVsbCxpPW5ldyBVaW50OEFycmF5KDApLHM9MCxhPXRoaXMuREVGQVVMVF9USU1FT1VUKXt0aGlzLmRlYnVnKCJjaGVja19jb21tYW5kICIrZSk7bGV0IG49YXdhaXQgdGhpcy5jb21tYW5kKEEsaSxzLHZvaWQgMCxhKTtyZXR1cm4gblsxXS5sZW5ndGg+ND9uWzFdOm5bMF19YXN5bmMgbWVtQmVnaW4oZSxBLGkscyl7aWYodGhpcy5JU19TVFVCKXtsZXQgbj1zLEU9cytlLG89YXdhaXQgcnQodGhpcy5jaGlwLkNISVBfTkFNRSk7aWYobyl7bGV0IHI9W1tvLmJzc19zdGFydHx8by5kYXRhX3N0YXJ0LG8uZGF0YV9zdGFydCtvLmRlY29kZWREYXRhLmxlbmd0aF0sW28udGV4dF9zdGFydCxvLnRleHRfc3RhcnQrby5kZWNvZGVkVGV4dC5sZW5ndGhdXTtmb3IobGV0W2gsd11vZiByKWlmKG48dyYmRT5oKXRocm93IG5ldyBVKGBTb2Z0d2FyZSBsb2FkZXIgaXMgcmVzaWRlbnQgYXQgMHgke2gudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIjAiKX0tMHgke3cudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIjAiKX0uCiAgICAgICAgICAgIENhbid0IGxvYWQgYmluYXJ5IGF0IG92ZXJsYXBwaW5nIGFkZHJlc3MgcmFuZ2UgMHgke24udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIjAiKX0tMHgke0UudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsIjAiKX0uCiAgICAgICAgICAgIEVpdGhlciBjaGFuZ2UgYmluYXJ5IGxvYWRpbmcgYWRkcmVzcywgb3IgdXNlIHRoZSBuby1zdHViIG9wdGlvbiB0byBkaXNhYmxlIHRoZSBzb2Z0d2FyZSBsb2FkZXIuYCl9fXRoaXMuZGVidWcoIm1lbV9iZWdpbiAiK2UrIiAiK0ErIiAiK2krIiAiK3MudG9TdHJpbmcoMTYpKTtsZXQgYT10aGlzLl9hcHBlbmRBcnJheSh0aGlzLl9pbnRUb0J5dGVBcnJheShlKSx0aGlzLl9pbnRUb0J5dGVBcnJheShBKSk7YT10aGlzLl9hcHBlbmRBcnJheShhLHRoaXMuX2ludFRvQnl0ZUFycmF5KGkpKSxhPXRoaXMuX2FwcGVuZEFycmF5KGEsdGhpcy5faW50VG9CeXRlQXJyYXkocykpLGF3YWl0IHRoaXMuY2hlY2tDb21tYW5kKCJlbnRlciBSQU0gZG93bmxvYWQgbW9kZSIsdGhpcy5FU1BfTUVNX0JFR0lOLGEpfWNoZWNrc3VtKGUsQT10aGlzLkVTUF9DSEVDS1NVTV9NQUdJQyl7Zm9yKGxldCBpPTA7aTxlLmxlbmd0aDtpKyspQV49ZVtpXTtyZXR1cm4gQX1hc3luYyBtZW1CbG9jayhlLEEpe2xldCBpPXRoaXMuX2FwcGVuZEFycmF5KHRoaXMuX2ludFRvQnl0ZUFycmF5KGUubGVuZ3RoKSx0aGlzLl9pbnRUb0J5dGVBcnJheShBKSk7aT10aGlzLl9hcHBlbmRBcnJheShpLHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKSxpPXRoaXMuX2FwcGVuZEFycmF5KGksdGhpcy5faW50VG9CeXRlQXJyYXkoMCkpLGk9dGhpcy5fYXBwZW5kQXJyYXkoaSxlKTtsZXQgcz10aGlzLmNoZWNrc3VtKGUpO2F3YWl0IHRoaXMuY2hlY2tDb21tYW5kKCJ3cml0ZSB0byB0YXJnZXQgUkFNIix0aGlzLkVTUF9NRU1fREFUQSxpLHMpfWFzeW5jIG1lbUZpbmlzaChlKXtsZXQgQT1lPT09MD8xOjAsaT10aGlzLl9hcHBlbmRBcnJheSh0aGlzLl9pbnRUb0J5dGVBcnJheShBKSx0aGlzLl9pbnRUb0J5dGVBcnJheShlKSk7YXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoImxlYXZlIFJBTSBkb3dubG9hZCBtb2RlIix0aGlzLkVTUF9NRU1fRU5ELGksdm9pZCAwLDIwMCl9YXN5bmMgZmxhc2hTcGlBdHRhY2goZSl7bGV0IEE9dGhpcy5faW50VG9CeXRlQXJyYXkoZSk7YXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoImNvbmZpZ3VyZSBTUEkgZmxhc2ggcGlucyIsdGhpcy5FU1BfU1BJX0FUVEFDSCxBKX10aW1lb3V0UGVyTWIoZSxBKXtsZXQgaT1lKihBLzFlNik7cmV0dXJuIGk8M2UzPzNlMzppfWFzeW5jIGZsYXNoQmVnaW4oZSxBKXtsZXQgaT1NYXRoLmZsb29yKChlK3RoaXMuRkxBU0hfV1JJVEVfU0laRS0xKS90aGlzLkZMQVNIX1dSSVRFX1NJWkUpLHM9dGhpcy5jaGlwLmdldEVyYXNlU2l6ZShBLGUpLGE9bmV3IERhdGUsbj1hLmdldFRpbWUoKSxFPTNlMzt0aGlzLklTX1NUVUI9PSExJiYoRT10aGlzLnRpbWVvdXRQZXJNYih0aGlzLkVSQVNFX1JFR0lPTl9USU1FT1VUX1BFUl9NQixlKSksdGhpcy5kZWJ1ZygiZmxhc2ggYmVnaW4gIitzKyIgIitpKyIgIit0aGlzLkZMQVNIX1dSSVRFX1NJWkUrIiAiK0ErIiAiK2UpO2xldCBvPXRoaXMuX2FwcGVuZEFycmF5KHRoaXMuX2ludFRvQnl0ZUFycmF5KHMpLHRoaXMuX2ludFRvQnl0ZUFycmF5KGkpKTtvPXRoaXMuX2FwcGVuZEFycmF5KG8sdGhpcy5faW50VG9CeXRlQXJyYXkodGhpcy5GTEFTSF9XUklURV9TSVpFKSksbz10aGlzLl9hcHBlbmRBcnJheShvLHRoaXMuX2ludFRvQnl0ZUFycmF5KEEpKSx0aGlzLklTX1NUVUI9PSExJiYobz10aGlzLl9hcHBlbmRBcnJheShvLHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKSksYXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoImVudGVyIEZsYXNoIGRvd25sb2FkIG1vZGUiLHRoaXMuRVNQX0ZMQVNIX0JFR0lOLG8sdm9pZCAwLEUpO2xldCByPWEuZ2V0VGltZSgpO3JldHVybiBlIT0wJiZ0aGlzLklTX1NUVUI9PSExJiZ0aGlzLmluZm8oIlRvb2sgIisoci1uKS8xZTMrIi4iKyhyLW4pJTFlMysicyB0byBlcmFzZSBmbGFzaCBibG9jayIpLGl9YXN5bmMgZmxhc2hEZWZsQmVnaW4oZSxBLGkpe2xldCBzPU1hdGguZmxvb3IoKEErdGhpcy5GTEFTSF9XUklURV9TSVpFLTEpL3RoaXMuRkxBU0hfV1JJVEVfU0laRSksYT1NYXRoLmZsb29yKChlK3RoaXMuRkxBU0hfV1JJVEVfU0laRS0xKS90aGlzLkZMQVNIX1dSSVRFX1NJWkUpLG49bmV3IERhdGUsRT1uLmdldFRpbWUoKSxvLHI7dGhpcy5JU19TVFVCPyhvPWUscj10aGlzLkRFRkFVTFRfVElNRU9VVCk6KG89YSp0aGlzLkZMQVNIX1dSSVRFX1NJWkUscj10aGlzLnRpbWVvdXRQZXJNYih0aGlzLkVSQVNFX1JFR0lPTl9USU1FT1VUX1BFUl9NQixvKSksdGhpcy5pbmZvKCJDb21wcmVzc2VkICIrZSsiIGJ5dGVzIHRvICIrQSsiLi4uIik7bGV0IGg9dGhpcy5fYXBwZW5kQXJyYXkodGhpcy5faW50VG9CeXRlQXJyYXkobyksdGhpcy5faW50VG9CeXRlQXJyYXkocykpO2g9dGhpcy5fYXBwZW5kQXJyYXkoaCx0aGlzLl9pbnRUb0J5dGVBcnJheSh0aGlzLkZMQVNIX1dSSVRFX1NJWkUpKSxoPXRoaXMuX2FwcGVuZEFycmF5KGgsdGhpcy5faW50VG9CeXRlQXJyYXkoaSkpLCh0aGlzLmNoaXAuQ0hJUF9OQU1FPT09IkVTUDMyLVMyInx8dGhpcy5jaGlwLkNISVBfTkFNRT09PSJFU1AzMi1TMyJ8fHRoaXMuY2hpcC5DSElQX05BTUU9PT0iRVNQMzItQzMifHx0aGlzLmNoaXAuQ0hJUF9OQU1FPT09IkVTUDMyLUMyIikmJnRoaXMuSVNfU1RVQj09PSExJiYoaD10aGlzLl9hcHBlbmRBcnJheShoLHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKSksYXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoImVudGVyIGNvbXByZXNzZWQgZmxhc2ggbW9kZSIsdGhpcy5FU1BfRkxBU0hfREVGTF9CRUdJTixoLHZvaWQgMCxyKTtsZXQgdz1uLmdldFRpbWUoKTtyZXR1cm4gZSE9MCYmdGhpcy5JU19TVFVCPT09ITEmJnRoaXMuaW5mbygiVG9vayAiKyh3LUUpLzFlMysiLiIrKHctRSklMWUzKyJzIHRvIGVyYXNlIGZsYXNoIGJsb2NrIiksc31hc3luYyBmbGFzaEJsb2NrKGUsQSxpKXtsZXQgcz10aGlzLl9hcHBlbmRBcnJheSh0aGlzLl9pbnRUb0J5dGVBcnJheShlLmxlbmd0aCksdGhpcy5faW50VG9CeXRlQXJyYXkoQSkpO3M9dGhpcy5fYXBwZW5kQXJyYXkocyx0aGlzLl9pbnRUb0J5dGVBcnJheSgwKSkscz10aGlzLl9hcHBlbmRBcnJheShzLHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKSxzPXRoaXMuX2FwcGVuZEFycmF5KHMsZSk7bGV0IGE9dGhpcy5jaGVja3N1bShlKTthd2FpdCB0aGlzLmNoZWNrQ29tbWFuZCgid3JpdGUgdG8gdGFyZ2V0IEZsYXNoIGFmdGVyIHNlcSAiK0EsdGhpcy5FU1BfRkxBU0hfREFUQSxzLGEsaSl9YXN5bmMgZmxhc2hEZWZsQmxvY2soZSxBLGkpe2xldCBzPXRoaXMuX2FwcGVuZEFycmF5KHRoaXMuX2ludFRvQnl0ZUFycmF5KGUubGVuZ3RoKSx0aGlzLl9pbnRUb0J5dGVBcnJheShBKSk7cz10aGlzLl9hcHBlbmRBcnJheShzLHRoaXMuX2ludFRvQnl0ZUFycmF5KDApKSxzPXRoaXMuX2FwcGVuZEFycmF5KHMsdGhpcy5faW50VG9CeXRlQXJyYXkoMCkpLHM9dGhpcy5fYXBwZW5kQXJyYXkocyxlKTtsZXQgYT10aGlzLmNoZWNrc3VtKGUpO3RoaXMuZGVidWcoImZsYXNoX2RlZmxfYmxvY2sgIitlWzBdLnRvU3RyaW5nKDE2KSsiICIrZVsxXS50b1N0cmluZygxNikpLGF3YWl0IHRoaXMuY2hlY2tDb21tYW5kKCJ3cml0ZSBjb21wcmVzc2VkIGRhdGEgdG8gZmxhc2ggYWZ0ZXIgc2VxICIrQSx0aGlzLkVTUF9GTEFTSF9ERUZMX0RBVEEscyxhLGkpfWFzeW5jIGZsYXNoRmluaXNoKGU9ITEpe2xldCBBPWU/MDoxLGk9dGhpcy5faW50VG9CeXRlQXJyYXkoQSk7YXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoImxlYXZlIEZsYXNoIG1vZGUiLHRoaXMuRVNQX0ZMQVNIX0VORCxpKX1hc3luYyBmbGFzaERlZmxGaW5pc2goZT0hMSl7bGV0IEE9ZT8wOjEsaT10aGlzLl9pbnRUb0J5dGVBcnJheShBKTthd2FpdCB0aGlzLmNoZWNrQ29tbWFuZCgibGVhdmUgY29tcHJlc3NlZCBmbGFzaCBtb2RlIix0aGlzLkVTUF9GTEFTSF9ERUZMX0VORCxpKX1hc3luYyBydW5TcGlmbGFzaENvbW1hbmQoZSxBLGkpe2xldCBFPXRoaXMuY2hpcC5TUElfUkVHX0JBU0Usbz1FKzAscj1FK3RoaXMuY2hpcC5TUElfVVNSX09GRlMsaD1FK3RoaXMuY2hpcC5TUElfVVNSMV9PRkZTLHc9RSt0aGlzLmNoaXAuU1BJX1VTUjJfT0ZGUyxjPUUrdGhpcy5jaGlwLlNQSV9XMF9PRkZTLGc7dGhpcy5jaGlwLlNQSV9NT1NJX0RMRU5fT0ZGUyE9bnVsbD9nPWFzeW5jKF8sTSk9PntsZXQgUz1FK3RoaXMuY2hpcC5TUElfTU9TSV9ETEVOX09GRlMsST1FK3RoaXMuY2hpcC5TUElfTUlTT19ETEVOX09GRlM7Xz4wJiZhd2FpdCB0aGlzLndyaXRlUmVnKFMsXy0xKSxNPjAmJmF3YWl0IHRoaXMud3JpdGVSZWcoSSxNLTEpfTpnPWFzeW5jKF8sTSk9PntsZXQgUz1oLEk9MTcsUj04LFo9Xz09PTA/MDpfLTEsd0E9KE09PT0wPzA6TS0xKTw8UnxaPDxJO2F3YWl0IHRoaXMud3JpdGVSZWcoUyx3QSl9O2xldCBmPTE8PDE4LEY9Mjg7aWYoaT4zMil0aHJvdyBuZXcgVSgiUmVhZGluZyBtb3JlIHRoYW4gMzIgYml0cyBiYWNrIGZyb20gYSBTUEkgZmxhc2ggb3BlcmF0aW9uIGlzIHVuc3VwcG9ydGVkIik7aWYoQS5sZW5ndGg+NjQpdGhyb3cgbmV3IFUoIldyaXRpbmcgbW9yZSB0aGFuIDY0IGJ5dGVzIG9mIGRhdGEgd2l0aCBvbmUgU1BJIGNvbW1hbmQgaXMgdW5zdXBwb3J0ZWQiKTtsZXQgZD1BLmxlbmd0aCo4LEM9YXdhaXQgdGhpcy5yZWFkUmVnKHIpLFE9YXdhaXQgdGhpcy5yZWFkUmVnKHcpLGw9LTIxNDc0ODM2NDgsQjtpPjAmJihsfD0yNjg0MzU0NTYpLGQ+MCYmKGx8PTEzNDIxNzcyOCksYXdhaXQgZyhkLGkpLGF3YWl0IHRoaXMud3JpdGVSZWcocixsKTtsZXQgRD03PDxGfGU7aWYoYXdhaXQgdGhpcy53cml0ZVJlZyh3LEQpLGQ9PTApYXdhaXQgdGhpcy53cml0ZVJlZyhjLDApO2Vsc2V7aWYoQS5sZW5ndGglNCE9MCl7bGV0IE09bmV3IFVpbnQ4QXJyYXkoQS5sZW5ndGglNCk7QT10aGlzLl9hcHBlbmRBcnJheShBLE0pfWxldCBfPWM7Zm9yKEI9MDtCPEEubGVuZ3RoLTQ7Qis9NClEPXRoaXMuX2J5dGVBcnJheVRvSW50KEFbQl0sQVtCKzFdLEFbQisyXSxBW0IrM10pLGF3YWl0IHRoaXMud3JpdGVSZWcoXyxEKSxfKz00fWZvcihhd2FpdCB0aGlzLndyaXRlUmVnKG8sZiksQj0wO0I8MTAmJihEPWF3YWl0IHRoaXMucmVhZFJlZyhvKSZmLEQhPTApO0IrKyk7aWYoQj09PTEwKXRocm93IG5ldyBVKCJTUEkgY29tbWFuZCBkaWQgbm90IGNvbXBsZXRlIGluIHRpbWUiKTtsZXQgcD1hd2FpdCB0aGlzLnJlYWRSZWcoYyk7cmV0dXJuIGF3YWl0IHRoaXMud3JpdGVSZWcocixDKSxhd2FpdCB0aGlzLndyaXRlUmVnKHcsUSkscH1hc3luYyByZWFkRmxhc2hJZCgpe2xldCBBPW5ldyBVaW50OEFycmF5KDApO3JldHVybiBhd2FpdCB0aGlzLnJ1blNwaWZsYXNoQ29tbWFuZCgxNTksQSwyNCl9YXN5bmMgZXJhc2VGbGFzaCgpe3RoaXMuaW5mbygiRXJhc2luZyBmbGFzaCAodGhpcyBtYXkgdGFrZSBhIHdoaWxlKS4uLiIpO2xldCBlPW5ldyBEYXRlLEE9ZS5nZXRUaW1lKCksaT1hd2FpdCB0aGlzLmNoZWNrQ29tbWFuZCgiZXJhc2UgZmxhc2giLHRoaXMuRVNQX0VSQVNFX0ZMQVNILHZvaWQgMCx2b2lkIDAsdGhpcy5DSElQX0VSQVNFX1RJTUVPVVQpO2U9bmV3IERhdGU7bGV0IHM9ZS5nZXRUaW1lKCk7cmV0dXJuIHRoaXMuaW5mbygiQ2hpcCBlcmFzZSBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IGluICIrKHMtQSkvMWUzKyJzIiksaX10b0hleChlKXtyZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGUsQT0+KCIwMCIrQS50b1N0cmluZygxNikpLnNsaWNlKC0yKSkuam9pbigiIil9YXN5bmMgZmxhc2hNZDVzdW0oZSxBKXtsZXQgaT10aGlzLnRpbWVvdXRQZXJNYih0aGlzLk1ENV9USU1FT1VUX1BFUl9NQixBKSxzPXRoaXMuX2FwcGVuZEFycmF5KHRoaXMuX2ludFRvQnl0ZUFycmF5KGUpLHRoaXMuX2ludFRvQnl0ZUFycmF5KEEpKTtzPXRoaXMuX2FwcGVuZEFycmF5KHMsdGhpcy5faW50VG9CeXRlQXJyYXkoMCkpLHM9dGhpcy5fYXBwZW5kQXJyYXkocyx0aGlzLl9pbnRUb0J5dGVBcnJheSgwKSk7bGV0IGE9YXdhaXQgdGhpcy5jaGVja0NvbW1hbmQoImNhbGN1bGF0ZSBtZDVzdW0iLHRoaXMuRVNQX1NQSV9GTEFTSF9NRDUscyx2b2lkIDAsaSk7cmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5JiZhLmxlbmd0aD4xNiYmKGE9YS5zbGljZSgwLDE2KSksdGhpcy50b0hleChhKX1hc3luYyByZWFkRmxhc2goZSxBLGk9bnVsbCl7bGV0IHM9dGhpcy5fYXBwZW5kQXJyYXkodGhpcy5faW50VG9CeXRlQXJyYXkoZSksdGhpcy5faW50VG9CeXRlQXJyYXkoQSkpO3M9dGhpcy5fYXBwZW5kQXJyYXkocyx0aGlzLl9pbnRUb0J5dGVBcnJheSg0MDk2KSkscz10aGlzLl9hcHBlbmRBcnJheShzLHRoaXMuX2ludFRvQnl0ZUFycmF5KDEwMjQpKTtsZXQgYT1hd2FpdCB0aGlzLmNoZWNrQ29tbWFuZCgicmVhZCBmbGFzaCIsdGhpcy5FU1BfUkVBRF9GTEFTSCxzKTtpZihhIT0wKXRocm93IG5ldyBVKCJGYWlsZWQgdG8gcmVhZCBtZW1vcnk6ICIrYSk7bGV0IG49bmV3IFVpbnQ4QXJyYXkoMCk7Zm9yKDtuLmxlbmd0aDxBOyl7bGV0e3ZhbHVlOkV9PWF3YWl0IHRoaXMudHJhbnNwb3J0LnJlYWQodGhpcy5GTEFTSF9SRUFEX1RJTUVPVVQpLm5leHQoKTtpZihFIGluc3RhbmNlb2YgVWludDhBcnJheSlFLmxlbmd0aD4wJiYobj10aGlzLl9hcHBlbmRBcnJheShuLEUpLGF3YWl0IHRoaXMudHJhbnNwb3J0LndyaXRlKHRoaXMuX2ludFRvQnl0ZUFycmF5KG4ubGVuZ3RoKSksaSYmaShFLG4ubGVuZ3RoLEEpKTtlbHNlIHRocm93IG5ldyBVKCJGYWlsZWQgdG8gcmVhZCBtZW1vcnk6ICIrRSl9cmV0dXJuIG59YXN5bmMgcnVuU3R1Yigpe2lmKHRoaXMuc3luY1N0dWJEZXRlY3RlZClyZXR1cm4gdGhpcy5pbmZvKCJTdHViIGlzIGFscmVhZHkgcnVubmluZy4gTm8gdXBsb2FkIGlzIG5lY2Vzc2FyeS4iKSx0aGlzLmNoaXA7dGhpcy5pbmZvKCJVcGxvYWRpbmcgc3R1Yi4uLiIpO2xldCBlPWF3YWl0IHJ0KHRoaXMuY2hpcC5DSElQX05BTUUpO2lmKGU9PT12b2lkIDApdGhyb3cgdGhpcy5kZWJ1ZygiRXJyb3IgbG9hZGluZyBTdHViIGpzb24iKSxuZXcgRXJyb3IoIkVycm9yIGxvYWRpbmcgU3R1YiBqc29uIik7bGV0IEE9W2UuZGVjb2RlZFRleHQsZS5kZWNvZGVkRGF0YV07Zm9yKGxldCBhPTA7YTxBLmxlbmd0aDthKyspaWYoQVthXSl7bGV0IG49YT09PTA/ZS50ZXh0X3N0YXJ0OmUuZGF0YV9zdGFydCxFPUFbYV0ubGVuZ3RoLG89TWF0aC5mbG9vcigoRSt0aGlzLkVTUF9SQU1fQkxPQ0stMSkvdGhpcy5FU1BfUkFNX0JMT0NLKTthd2FpdCB0aGlzLm1lbUJlZ2luKEUsbyx0aGlzLkVTUF9SQU1fQkxPQ0ssbik7Zm9yKGxldCByPTA7cjxvO3IrKyl7bGV0IGg9cip0aGlzLkVTUF9SQU1fQkxPQ0ssdz1oK3RoaXMuRVNQX1JBTV9CTE9DSzthd2FpdCB0aGlzLm1lbUJsb2NrKEFbYV0uc2xpY2UoaCx3KSxyKX19dGhpcy5pbmZvKCJSdW5uaW5nIHN0dWIuLi4iKSxhd2FpdCB0aGlzLm1lbUZpbmlzaChlLmVudHJ5KTtsZXR7dmFsdWU6aX09YXdhaXQgdGhpcy50cmFuc3BvcnQucmVhZCh0aGlzLkRFRkFVTFRfVElNRU9VVCkubmV4dCgpLHM9U3RyaW5nLmZyb21DaGFyQ29kZSguLi5pKTtpZihzIT09Ik9IQUkiKXRocm93IG5ldyBVKGBGYWlsZWQgdG8gc3RhcnQgc3R1Yi4gVW5leHBlY3RlZCByZXNwb25zZSAke3N9YCk7cmV0dXJuIHRoaXMuaW5mbygiU3R1YiBydW5uaW5nLi4uIiksdGhpcy5JU19TVFVCPSEwLHRoaXMuY2hpcH1hc3luYyBjaGFuZ2VCYXVkKCl7dGhpcy5pbmZvKCJDaGFuZ2luZyBiYXVkcmF0ZSB0byAiK3RoaXMuYmF1ZHJhdGUpO2xldCBlPXRoaXMuSVNfU1RVQj90aGlzLnJvbUJhdWRyYXRlOjAsQT10aGlzLl9hcHBlbmRBcnJheSh0aGlzLl9pbnRUb0J5dGVBcnJheSh0aGlzLmJhdWRyYXRlKSx0aGlzLl9pbnRUb0J5dGVBcnJheShlKSk7YXdhaXQgdGhpcy5jb21tYW5kKHRoaXMuRVNQX0NIQU5HRV9CQVVEUkFURSxBKSx0aGlzLmluZm8oIkNoYW5nZWQiKSxhd2FpdCB0aGlzLnRyYW5zcG9ydC5kaXNjb25uZWN0KCksYXdhaXQgdGhpcy5fc2xlZXAoNTApLGF3YWl0IHRoaXMudHJhbnNwb3J0LmNvbm5lY3QodGhpcy5iYXVkcmF0ZSx0aGlzLnNlcmlhbE9wdGlvbnMpfWFzeW5jIG1haW4oZT0iZGVmYXVsdF9yZXNldCIpe2F3YWl0IHRoaXMuZGV0ZWN0Q2hpcChlKTtsZXQgQT1hd2FpdCB0aGlzLmNoaXAuZ2V0Q2hpcERlc2NyaXB0aW9uKHRoaXMpO3JldHVybiB0aGlzLmluZm8oIkNoaXAgaXMgIitBKSx0aGlzLmluZm8oIkZlYXR1cmVzOiAiK2F3YWl0IHRoaXMuY2hpcC5nZXRDaGlwRmVhdHVyZXModGhpcykpLHRoaXMuaW5mbygiQ3J5c3RhbCBpcyAiK2F3YWl0IHRoaXMuY2hpcC5nZXRDcnlzdGFsRnJlcSh0aGlzKSsiTUh6IiksdGhpcy5pbmZvKCJNQUM6ICIrYXdhaXQgdGhpcy5jaGlwLnJlYWRNYWModGhpcykpLGF3YWl0IHRoaXMuY2hpcC5yZWFkTWFjKHRoaXMpLHR5cGVvZiB0aGlzLmNoaXAucG9zdENvbm5lY3Q8InUiJiZhd2FpdCB0aGlzLmNoaXAucG9zdENvbm5lY3QodGhpcyksYXdhaXQgdGhpcy5ydW5TdHViKCksdGhpcy5yb21CYXVkcmF0ZSE9PXRoaXMuYmF1ZHJhdGUmJmF3YWl0IHRoaXMuY2hhbmdlQmF1ZCgpLEF9cGFyc2VGbGFzaFNpemVBcmcoZSl7aWYodHlwZW9mIHRoaXMuY2hpcC5GTEFTSF9TSVpFU1tlXT4idSIpdGhyb3cgbmV3IFUoIkZsYXNoIHNpemUgIitlKyIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIGNoaXAgdHlwZS4gU3VwcG9ydGVkIHNpemVzOiAiK3RoaXMuY2hpcC5GTEFTSF9TSVpFUyk7cmV0dXJuIHRoaXMuY2hpcC5GTEFTSF9TSVpFU1tlXX1fdXBkYXRlSW1hZ2VGbGFzaFBhcmFtcyhlLEEsaSxzLGEpe2lmKHRoaXMuZGVidWcoIl91cGRhdGVfaW1hZ2VfZmxhc2hfcGFyYW1zICIraSsiICIrcysiICIrYSksZS5sZW5ndGg8OHx8QSE9dGhpcy5jaGlwLkJPT1RMT0FERVJfRkxBU0hfT0ZGU0VUKXJldHVybiBlO2lmKGk9PT0ia2VlcCImJnM9PT0ia2VlcCImJmE9PT0ia2VlcCIpcmV0dXJuIHRoaXMuaW5mbygiTm90IGNoYW5naW5nIHRoZSBpbWFnZSIpLGU7bGV0IG49cGFyc2VJbnQoZVswXSksRT1wYXJzZUludChlWzJdKSxvPXBhcnNlSW50KGVbM10pO2lmKG4hPT10aGlzLkVTUF9JTUFHRV9NQUdJQylyZXR1cm4gdGhpcy5pbmZvKCJXYXJuaW5nOiBJbWFnZSBmaWxlIGF0IDB4IitBLnRvU3RyaW5nKDE2KSsiIGRvZXNuJ3QgbG9vayBsaWtlIGFuIGltYWdlIGZpbGUsIHNvIG5vdCBjaGFuZ2luZyBhbnkgZmxhc2ggc2V0dGluZ3MuIiksZTtzIT09ImtlZXAiJiYoRT17cWlvOjAscW91dDoxLGRpbzoyLGRvdXQ6M31bc10pO2xldCByPW8mMTU7YSE9PSJrZWVwIiYmKHI9eyI0MG0iOjAsIjI2bSI6MSwiMjBtIjoyLCI4MG0iOjE1fVthXSk7bGV0IGg9byYyNDA7aSE9PSJrZWVwIiYmKGg9dGhpcy5wYXJzZUZsYXNoU2l6ZUFyZyhpKSk7bGV0IHc9RTw8OHxyK2g7cmV0dXJuIHRoaXMuaW5mbygiRmxhc2ggcGFyYW1zIHNldCB0byAiK3cudG9TdHJpbmcoMTYpKSxwYXJzZUludChlWzJdKSE9PUU8PDgmJihlPWUuc3Vic3RyaW5nKDAsMikrKEU8PDgpLnRvU3RyaW5nKCkrZS5zdWJzdHJpbmcoMykpLHBhcnNlSW50KGVbM10pIT09citoJiYoZT1lLnN1YnN0cmluZygwLDMpKyhyK2gpLnRvU3RyaW5nKCkrZS5zdWJzdHJpbmcoNCkpLGV9YXN5bmMgd3JpdGVGbGFzaChlKXtpZih0aGlzLmRlYnVnKCJFc3BMb2FkZXIgcHJvZ3JhbSIpLGUuZmxhc2hTaXplIT09ImtlZXAiKXtsZXQgcz10aGlzLmZsYXNoU2l6ZUJ5dGVzKGUuZmxhc2hTaXplKTtmb3IobGV0IGE9MDthPGUuZmlsZUFycmF5Lmxlbmd0aDthKyspaWYoZS5maWxlQXJyYXlbYV0uZGF0YS5sZW5ndGgrZS5maWxlQXJyYXlbYV0uYWRkcmVzcz5zKXRocm93IG5ldyBVKGBGaWxlICR7YSsxfSBkb2Vzbid0IGZpdCBpbiB0aGUgYXZhaWxhYmxlIGZsYXNoYCl9dGhpcy5JU19TVFVCPT09ITAmJmUuZXJhc2VBbGw9PT0hMCYmYXdhaXQgdGhpcy5lcmFzZUZsYXNoKCk7bGV0IEEsaTtmb3IobGV0IHM9MDtzPGUuZmlsZUFycmF5Lmxlbmd0aDtzKyspe2lmKHRoaXMuZGVidWcoIkRhdGEgTGVuZ3RoICIrZS5maWxlQXJyYXlbc10uZGF0YS5sZW5ndGgpLEE9ZS5maWxlQXJyYXlbc10uZGF0YSx0aGlzLmRlYnVnKCJJbWFnZSBMZW5ndGggIitBLmxlbmd0aCksQS5sZW5ndGg9PT0wKXt0aGlzLmRlYnVnKCJXYXJuaW5nOiBGaWxlIGlzIGVtcHR5Iik7Y29udGludWV9QT10aGlzLnVpOFRvQnN0cih5aSh0aGlzLmJzdHJUb1VpOChBKSw0KSksaT1lLmZpbGVBcnJheVtzXS5hZGRyZXNzLEE9dGhpcy5fdXBkYXRlSW1hZ2VGbGFzaFBhcmFtcyhBLGksZS5mbGFzaFNpemUsZS5mbGFzaE1vZGUsZS5mbGFzaEZyZXEpO2xldCBhPW51bGw7ZS5jYWxjdWxhdGVNRDVIYXNoJiYoYT1lLmNhbGN1bGF0ZU1ENUhhc2goQSksdGhpcy5kZWJ1ZygiSW1hZ2UgTUQ1ICIrYSkpO2xldCBuPUEubGVuZ3RoLEU7aWYoZS5jb21wcmVzcyl7bGV0IEM9dGhpcy5ic3RyVG9VaTgoQSk7QT10aGlzLnVpOFRvQnN0cihsaShDLHtsZXZlbDo5fSkpLEU9YXdhaXQgdGhpcy5mbGFzaERlZmxCZWdpbihuLEEubGVuZ3RoLGkpfWVsc2UgRT1hd2FpdCB0aGlzLmZsYXNoQmVnaW4obixpKTtsZXQgbz0wLHI9MCxoPUEubGVuZ3RoO2UucmVwb3J0UHJvZ3Jlc3MmJmUucmVwb3J0UHJvZ3Jlc3MocywwLGgpO2xldCB3PW5ldyBEYXRlLGM9dy5nZXRUaW1lKCksZz01ZTMsZj1uZXcgZGkoe2NodW5rU2l6ZToxfSksRj0wO2ZvcihmLm9uRGF0YT1mdW5jdGlvbihDKXtGKz1DLmJ5dGVMZW5ndGh9O0EubGVuZ3RoPjA7KXt0aGlzLmRlYnVnKCJXcml0ZSBsb29wICIraSsiICIrbysiICIrRSksdGhpcy5pbmZvKCJXcml0aW5nIGF0IDB4IisoaStGKS50b1N0cmluZygxNikrIi4uLiAoIitNYXRoLmZsb29yKDEwMCoobysxKS9FKSsiJSkiKTtsZXQgQz10aGlzLmJzdHJUb1VpOChBLnNsaWNlKDAsdGhpcy5GTEFTSF9XUklURV9TSVpFKSk7aWYoZS5jb21wcmVzcyl7bGV0IFE9RjtmLnB1c2goQywhMSk7bGV0IGw9Ri1RLEI9M2UzO3RoaXMudGltZW91dFBlck1iKHRoaXMuRVJBU0VfV1JJVEVfVElNRU9VVF9QRVJfTUIsbCk+M2UzJiYoQj10aGlzLnRpbWVvdXRQZXJNYih0aGlzLkVSQVNFX1dSSVRFX1RJTUVPVVRfUEVSX01CLGwpKSx0aGlzLklTX1NUVUI9PT0hMSYmKGc9QiksYXdhaXQgdGhpcy5mbGFzaERlZmxCbG9jayhDLG8sZyksdGhpcy5JU19TVFVCJiYoZz1CKX1lbHNlIHRocm93IG5ldyBVKCJZZXQgdG8gaGFuZGxlIE5vbiBDb21wcmVzc2VkIHdyaXRlcyIpO3IrPUMubGVuZ3RoLEE9QS5zbGljZSh0aGlzLkZMQVNIX1dSSVRFX1NJWkUsQS5sZW5ndGgpLG8rKyxlLnJlcG9ydFByb2dyZXNzJiZlLnJlcG9ydFByb2dyZXNzKHMscixoKX10aGlzLklTX1NUVUImJmF3YWl0IHRoaXMucmVhZFJlZyh0aGlzLkNISVBfREVURUNUX01BR0lDX1JFR19BRERSLGcpLHc9bmV3IERhdGU7bGV0IGQ9dy5nZXRUaW1lKCktYztpZihlLmNvbXByZXNzJiZ0aGlzLmluZm8oIldyb3RlICIrbisiIGJ5dGVzICgiK3IrIiBjb21wcmVzc2VkKSBhdCAweCIraS50b1N0cmluZygxNikrIiBpbiAiK2QvMWUzKyIgc2Vjb25kcy4iKSxhKXtsZXQgQz1hd2FpdCB0aGlzLmZsYXNoTWQ1c3VtKGksbik7aWYobmV3IFN0cmluZyhDKS52YWx1ZU9mKCkhPW5ldyBTdHJpbmcoYSkudmFsdWVPZigpKXRocm93IHRoaXMuaW5mbygiRmlsZSAgbWQ1OiAiK2EpLHRoaXMuaW5mbygiRmxhc2ggbWQ1OiAiK0MpLG5ldyBVKCJNRDUgb2YgZmlsZSBkb2VzIG5vdCBtYXRjaCBkYXRhIGluIGZsYXNoISIpO3RoaXMuaW5mbygiSGFzaCBvZiBkYXRhIHZlcmlmaWVkLiIpfX10aGlzLmluZm8oIkxlYXZpbmcuLi4iKSx0aGlzLklTX1NUVUImJihhd2FpdCB0aGlzLmZsYXNoQmVnaW4oMCwwKSxlLmNvbXByZXNzP2F3YWl0IHRoaXMuZmxhc2hEZWZsRmluaXNoKCk6YXdhaXQgdGhpcy5mbGFzaEZpbmlzaCgpKX1hc3luYyBmbGFzaElkKCl7dGhpcy5kZWJ1ZygiZmxhc2hfaWQiKTtsZXQgZT1hd2FpdCB0aGlzLnJlYWRGbGFzaElkKCk7dGhpcy5pbmZvKCJNYW51ZmFjdHVyZXI6ICIrKGUmMjU1KS50b1N0cmluZygxNikpO2xldCBBPWU+PjE2JjI1NTt0aGlzLmluZm8oIkRldmljZTogIisoZT4+OCYyNTUpLnRvU3RyaW5nKDE2KStBLnRvU3RyaW5nKDE2KSksdGhpcy5pbmZvKCJEZXRlY3RlZCBmbGFzaCBzaXplOiAiK3RoaXMuREVURUNURURfRkxBU0hfU0laRVNbQV0pfWFzeW5jIGdldEZsYXNoU2l6ZSgpe3RoaXMuZGVidWcoImZsYXNoX2lkIik7bGV0IEE9YXdhaXQgdGhpcy5yZWFkRmxhc2hJZCgpPj4xNiYyNTU7cmV0dXJuIHRoaXMuREVURUNURURfRkxBU0hfU0laRVNfTlVNW0FdfWFzeW5jIHNvZnRSZXNldChlKXtpZih0aGlzLklTX1NUVUIpe2lmKHRoaXMuY2hpcC5DSElQX05BTUUhPSJFU1A4MjY2Iil0aHJvdyBuZXcgVSgiU29mdCByZXNldHRpbmcgaXMgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIG9uIEVTUDgyNjYiKTtlPyhhd2FpdCB0aGlzLmZsYXNoQmVnaW4oMCwwKSxhd2FpdCB0aGlzLmZsYXNoRmluaXNoKCEwKSk6YXdhaXQgdGhpcy5jb21tYW5kKHRoaXMuRVNQX1JVTl9VU0VSX0NPREUsdm9pZCAwLHZvaWQgMCwhMSl9ZWxzZXtpZihlKXJldHVybjthd2FpdCB0aGlzLmZsYXNoQmVnaW4oMCwwKSxhd2FpdCB0aGlzLmZsYXNoRmluaXNoKCExKX19YXN5bmMgYWZ0ZXIoZT0iaGFyZF9yZXNldCIsQSl7c3dpdGNoKGUpe2Nhc2UiaGFyZF9yZXNldCI6dGhpcy5yZXNldENvbnN0cnVjdG9ycy5oYXJkUmVzZXQmJih0aGlzLmluZm8oIkhhcmQgcmVzZXR0aW5nIHZpYSBSVFMgcGluLi4uIiksYXdhaXQgdGhpcy5yZXNldENvbnN0cnVjdG9ycy5oYXJkUmVzZXQodGhpcy50cmFuc3BvcnQsQSkucmVzZXQoKSk7YnJlYWs7Y2FzZSJzb2Z0X3Jlc2V0Ijp0aGlzLmluZm8oIlNvZnQgcmVzZXR0aW5nLi4uIiksYXdhaXQgdGhpcy5zb2Z0UmVzZXQoITEpO2JyZWFrO2Nhc2Uibm9fcmVzZXRfc3R1YiI6dGhpcy5pbmZvKCJTdGF5aW5nIGluIGZsYXNoZXIgc3R1Yi4iKTticmVhaztkZWZhdWx0OnRoaXMuaW5mbygiU3RheWluZyBpbiBib290bG9hZGVyLiIpLHRoaXMuSVNfU1RVQiYmdGhpcy5zb2Z0UmVzZXQoITApO2JyZWFrfX19O0FBKCk7ZXhwb3J0e05BIGFzIENsYXNzaWNSZXNldCxXQSBhcyBDdXN0b21SZXNldCwkdCBhcyBFU1BMb2FkZXIsdkEgYXMgSGFyZFJlc2V0LE8gYXMgUk9NLExBIGFzIFRyYW5zcG9ydCxKQSBhcyBVc2JKdGFnU2VyaWFsUmVzZXQsTHQgYXMgZGVjb2RlQmFzZTY0RGF0YSxydCBhcyBnZXRTdHViSnNvbkJ5Q2hpcE5hbWUsU2kgYXMgdmFsaWRhdGVDdXN0b21SZXNldFN0cmluZ1NlcXVlbmNlfTsKLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjoKCnBha28vZGlzdC9wYWtvLmVzbS5tanM6CiAgKCohIHBha28gMi4xLjAgaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvIEBsaWNlbnNlIChNSVQgQU5EIFpsaWIpICopCiovCg==
    `.trim();

    /* ----------------------------------------------------------------------------
     * Bundle helpers (import + adapter)
     * What:  Provide the two functions expected by connect():
     *        - importEsptoolFromBase64(): dynamic-import the Base64 bundle
     *        - prepareEsptool(mod): map bundle exports to { makeTransport, makeLoader }
     * -------------------------------------------------------------------------- */
    async function importEsptoolFromBase64() {
      try {
        // Preferred: import straight from a data: URL
        return await import(`data:application/javascript;base64,${ESPT_BUNDLE_BASE64}`);
      } catch {
        // Fallback: Blob URL (handles some CSPs/loaders)
        const blob = new Blob([atob(ESPT_BUNDLE_BASE64)], { type: 'text/javascript' });
        const url  = URL.createObjectURL(blob);
        try {
          return await import(url);
        } finally {
          URL.revokeObjectURL(url);
        }
      }
    } // END importEsptoolFromBase64

    function prepareEsptool(mod) {
      // Flatten default export if present
      const m = (mod && typeof mod === 'object' && mod.default && typeof mod.default === 'object')
        ? { ...mod, ...mod.default }
        : mod || {};

      // Transport factory: try common shapes
      function makeTransport(port) {
        if (typeof m.makeTransport === 'function')     return m.makeTransport(port);
        if (typeof m.Transport === 'function')         return new m.Transport(port);
        if (typeof m.EsptoolTransport === 'function')  return new m.EsptoolTransport(port);
        throw new Error('No transport factory available in esptool bundle.');
      }

      // Loader factory: try common shapes
      async function makeLoader(transport, baud, term) {
        if (typeof m.makeLoader === 'function')  return m.makeLoader(transport, baud, term);
        if (typeof m.ESPLoader === 'function')   return new m.ESPLoader(transport, baud, term);
        if (m.default && typeof m.default.ESPLoader === 'function') {
          return new m.default.ESPLoader(transport, baud, term);
        }
        throw new Error('No loader class/factory available in esptool bundle.');
      }

      return { makeTransport, makeLoader };
    } // END prepareEsptool

    /* ----------------------------------------------------------------------------
     * function wireUI()
     * What:  Attaches listeners to Connect/Flash buttons and firmware <input>.
     * When:  Run once on DOM ready. Prints probes so you can see what was found.
     * Ends:  Leaves buttons correctly typed and (dis)abled to match state.
     * -------------------------------------------------------------------------- */
    function wireUI() {
      //log('dom: ready, wiring UI… (state=', document.readyState, ')');
	  log('System ready for .bin');
      const btnConnect = $('#connect');
      const btnFlash   = $('#flash');
      const fileInput  = $('#firmware');

      // Refresh cached references now that DOM is guaranteed to exist
      statusEl = $('#status');
      debugEl  = $('#debug');

      // Progress nodes (in case the DOM changed)
      progressBar  = $('#progress-bar');
      progressText = $('#progress-text');

      // Probe what can be seen on the page
      /*log('[probe] elements',
          'connect=', !!btnConnect,
          'flash=',   !!btnFlash,
          'file=',    !!fileInput);*/

      if (btnConnect) btnConnect.type = 'button';
      if (btnFlash)   btnFlash.type   = 'button';

      let selectedFile = null;

      // File chooser -> remember and log size
      fileInput?.addEventListener('change', () => {
        selectedFile = fileInput.files?.[0] || null;
        if (selectedFile) {
          log('Firmware:', selectedFile.name, selectedFile.size, 'bytes');
        }
        if (btnFlash) btnFlash.disabled = !selectedFile || !loader;
        updateFlashButtonState();
      });

      // Connect button
      btnConnect?.addEventListener('click', async (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        btnConnect.disabled = true;
        try {
          setStatus('Connecting…');
          await connect();
          updateFlashButtonState();
        } catch (e) {
          console.error('[WebSerial] connect error:', e);
          // alert handled inside connect()
        } finally {
          btnConnect.disabled = false;
          updateFlashButtonState();
        }
      });

      // Flash button
      btnFlash?.addEventListener('click', async (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        if (!selectedFile) return alert('Choose a .bin first.');
        if (!loader)       return alert('Connect to the device first.');

        let succeeded = false;
        btnFlash.disabled = true;

        try {
          await flashFile(selectedFile);
          succeeded = true;
        } catch (e) {
          alert(e?.message || String(e));
        } finally {
          // Stay disabled after a successful flash; otherwise restore based on state
          if (succeeded) {
            btnFlash.disabled = true;
            // Optionally also force the styled state helper:
            // setFlashEnabled(false);
          } else {
            btnFlash.disabled = !selectedFile || !loader;
          }
        }
      });

      setStatus('Ready. Pick a firmware file, then click Connect.');
    } // end wireUI()

    /* Kick off UI wiring */
    onReady(wireUI);
  </script>
</body>
</html>
